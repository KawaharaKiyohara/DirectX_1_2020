<!DOCTYPE html>
<html>
<head>
<title>原文.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
 tex2jax: {
 inlineMath: [["\\(","\\)"] ],
 displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
 }
 });
</script>
<h1 id="chapter-0-%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">Chapter 0 はじめに</h1>
<p> 本書のサンプルコードはVisualStudio2019で作成、動作確認が行われています。サンプルコードを動かすためにはVisualStudio2019のインストールをお願いします。また、本書ではC++とDirectX12をメインに利用して、シェーダープログラミングを学んでいきます。ただし、本書の目的はC++とDirectX12を学ぶことではなく、シェーダープログラミングの概要、アルゴリズムを学んでいくことです。ですので、DirectX12を直接触るのではなく、薄くラップした独自ライブラリを利用しています。ただし、DirectX12を学びたいという読者のために、極力薄くラップしており、DirectX12のエッセンスを残したまま、プログラミングできるように設計しております。本書籍には独自の3Dモデルやアニメーションデータのフォーマットが用意されております。これらを出力するための3dsMax、Blenderのスクリプトから、ランタイムでの読み込み、表示を行うプログラムまで全てGithubからダウンロードできます。本書と公開されているサンプルプログラムが少しでも3DCGプログラミングの本質の理解の助けになることができれば幸いです。</p>
<h2 id="01-visualstudio2019%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">0.1 VisualStudio2019のインストール</h2>
<p>下記のURLからVisualStudio2019のインストールを行ってください。</br>
https://visualstudio.microsoft.com/ja/vs/</p>
<h2 id="02-%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89">0.2 サンプルプログラムのダウンロード</h2>
<p>下記のURLからサンプルプログラムをダウンロードしてください。</br>
https://ほげほげほげ</p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h1 id="chapter-1-%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E5%85%A5%E9%96%80">Chapter 1 レンダリングパイプライン入門</h1>
<lead>
このチャプターではCPUとGPUについて学び、画面に3Dモデルの絵が表示されるまでの流れを学びます。
</lead>
<h2 id="11-cpu%E3%81%A8gpu">1.1 CPUとGPU</h2>
<p> CPUはゲームの進行を司る司令塔のようなものです。ゲームのキャラクターに「Aボタンが押されたらジャンプしなさい」や「Bボタンが押されたらダッシュしなさい」といった指示を出します。一方GPUはCPUからの指示で画面に絵を描く部下のようなものです。PlayStation(以下PS1)の登場で、3DCGを利用したゲームを家庭で楽しめるようになりました。3DCGを利用したゲームを実現するためには、高速な演算を可能とする必要があります。これを実現するために、PS1にはCPUとは別に高速なベクトル演算基、GPUを搭載していました。PS1以降の家庭用ゲーム機は3DCGのゲームを制作できるようにCPUとGPUを搭載するようになってきました。</p>
<h3 id="111-%E3%82%B3%E3%82%A2">1.1.1 コア</h3>
<p> CPUとGPUには計算を行う「コア」と呼ばれるものが搭載されています。さて、先ほどの説明の「GPUは高速な演算が可能」という説明と矛盾して聞こえると思いますが、CPUのコアは非常に高速な計算が可能です。一方、GPUのコアはそれほど計算は速くはありません。ですが、GPUはCPUに比べるとシンプルな設計になっているため、大量に用意することができます。一方CPUは複雑な処理を行う必要があるため、コアが高価になり、大量に用意することができません。intelのcore-i7というCPUのコア数が8個なのに対して、NVIDIAのRTX1080というGPUのコア数はは2560個です。</br></p>
<p> 3DCGを利用したゲームでは、大量の演算が行われます。例えば、100万頂点の3Dモデルをディスプレイに表示するためには、全ての頂点をディスプレイ空間に変換するための演算が行われます。</br></br>
<img src="fig/1_1.png" alt="図1.1 頂点変換"></br></br>
 その他にもディスプレイのピクセルのカラーを決定するための計算も必要です。ディスプレイ(正確にはレンダリングターゲット)の解像度が縦1920、横1080の場合、ピクセルの数は1920×1080の約200万ピクセルになります。この全てのピクセルのカラーを計算する必要があるわけです。</br></br>
<img src="fig/1_2.png" alt="図1.2 ピクセルカラーの決定"></br>
 3Dモデルを画面に表示するためには、大量の単純計算が必要になります。例えば、これをC++言語で記述すると下記のようになります。</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//100万個の頂点の座標変換を行う。</span>
Vector4 convertedVertex[<span class="hljs-number">1000000</span>];
<span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> vertexNo = <span class="hljs-number">0</span>; vertexNo &lt; <span class="hljs-number">1000000</span>; vertexNo++)
{
    convertedVertex[vertexNo] = worldMatrix * vertex[vertexNo];
    convertedVertex[vertexNo] = viewMatrix * convertedVertex[vertexNo];
    convertedVertex[vertexNo] = projMatrix * convertedVertex[vertexNo];
}
    
</div></code></pre>
<p> プログラムの意味は分からなくても構いません。注目してほしいのは、100万個の頂点に対して計算を行っているということです。この計算をあなたが行うことを想像してみてください。とてつもない時間がかかることが容易に想像できます。ですが、もしもこの計算を100万人で分担したらどうなるでしょう？１人で計算をしたときよりも、驚くほど短時間で計算が完了します。これがCPUとGPUの関係になります。</br>
<img src="fig/GPUとCPUの関係.png" width="720"></br>
 CPUはとても計算も速く、複雑な仕事ができます。しかし、高性能であるゆえに高価であり、大量に用意することはできません。一方GPUは計算が遅く、単純な仕事しかできません。しかし、低性能であるがゆえ、安価であり、大量に用意することができます。そこで、単純だが、量が多い計算をGPUにお願いすることで、CPU１人で計算するよりも、圧倒的に高速に計算を完了させることができるようになります。そして、これに非常に適している処理が、3DCGのレンダリングだったのです。</p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h3 id="113-%E3%81%BE%E3%81%A8%E3%82%81">1.1.3 まとめ</h3>
<ol>
<li><strong>CPUは司令塔、GPUは絵を描くことに特化したアーティスト</strong></br>
CPUは複雑な処理をこなすことができる司令塔です。GPUは複雑な処理は苦手ですが、絵を描くという一芸に秀でたアーティストです。</li>
<li><strong>GPUは大量の単純計算を行うことが得意</strong></br>
GPUは単一コアの計算速度はCPUよりも劣るが、コアを大量に持っているため、単純な計算を並列に行うことが可能となっており、ケースによってはCPUよりも高速に演算を行うことができる。</li>
<li><strong>3DCGをレンダリングするためには、大量の演算を行う必要がある</strong></br>
3DCGを画面にレンダリングするためには、頂点座標の変換や、ピクセルカラーの決定という大量の演算を行う必要がある。</li>
</ol>
<h2 id="12-%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%A8%E3%82%B0%E3%83%A9%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%83%A1%E3%83%A2%E3%83%AA">1.2 メインメモリとグラフィックメモリ</h2>
<p> 前節で見てきた、CPUとGPUは人間で例えると脳みそに当たります。コンピューターに指示を出したり、計算を行ったりします。しかし、人間の脳みそと大きく異なる点があります。それは記憶することができないということです。このモノを覚えるという機能を持っているのが、メモリと呼ばれるものです。</br>
 CPUとGPUは別人なので、脳みそが別々です。人間が２人いるようなものだと考えてください。２人いるので、当然記憶も別物になります。メインメモリにはゲームのキャラクターの体力、攻撃力、守備力といったゲームを制御するためのデータが記憶されています。一方グラフィックメモリには3DCGをレンダリングするために必要なデータが記録されています。具体的には、3Dモデルの頂点データとなる頂点バッファ、模様を表すテクスチャなどです。</br></p>
<p align="center">
<img src="fig/メインメモリとグラフィックメモリに乗っているデータ.png" ></br>
</p>
&emsp;CPUとGPUは別人なので、脳みそは別物です。ですので、CPUからアクセスできるメモリはメインメモリ、GPUからアクセスできるメモリはグラフィックメモリとなります。基本的にCPUからグラフィックメモリにアクセスしたり、GPUからメインメモリにアクセスしたりすることは、シンプルなプログラミングで行うことはできません。
<pre class="hljs"><code><div><span class="hljs-comment">//プレイヤーの体力を表示。</span>
<span class="hljs-comment">//このデータはメインメモリに記憶されているので、簡単にアクセスできる。</span>
prntf(<span class="hljs-string">"%d"</span>, playerHp); 

<span class="hljs-comment">//しかし、下記のようにテクスチャはグラフィックメモリに記録されているので、</span>
<span class="hljs-comment">//このように、直接アクセスして、画素を変更するようなことは簡単には行えない。</span>
<span class="hljs-comment">/*texture[0].r = 232;
texture[0].g = 104;
texture[0].b = 110;*/</span>
</div></code></pre>
<h3 id="121-%E3%83%A1%E3%83%A2%E3%83%AA%E8%BB%A2%E9%80%81">1.2.1 メモリ転送</h3>
<p> この後のチャプターで具体的にシェーダープログラミングを行っていくと分かってくるのですが、実はCPUとGPUとでメモリが分かれていることで困ることが出てきます。具体的には、GPUからメインメモリのデータに対してアクセスしたいケースがたくさん出てくるからです。しかし、GPUからアクセスできるのはグラフィックメモリだけです。ですので、CPUはGPUのDMA(Direct Memory Access)コントローラーなどを利用して、メインメモリの内容をグラフィックメモリにコピーします。例えば、3Dモデルの頂点データやテクスチャなどはメインメモリに一旦ロードされることがほとんどです。ですので、これらのデータをグラフィックメモリにコピーしてやる必要があります。下記のコードはDirectX12のAPIを利用して、メインメモリからグラフィックメモリにデータをコピーするコードです。</p>
<pre class="hljs"><code><div>ID3D12Device* d3dDevice = g_graphicsEngine.GetD3DDevice();
<span class="hljs-comment">//DirectXTKのResourceUpdateBatchクラスを利用して、</span>
<span class="hljs-comment">//頂点バッファをグラフィックメモリにコピーする。</span>
<span class="hljs-function">DirectX::ResourceUploadBatch <span class="hljs-title">re</span><span class="hljs-params">(d3dDevice.Get())</span></span>;
re.Begin();
<span class="hljs-comment">//コピーするリソースの情報を設定。</span>
D3D12_SUBRESOURCE_DATA subResourceData;
subResourceData.pData = srcVertices; <span class="hljs-comment">//頂点バッファの先頭アドレス。  </span>
subResourceData.RowPitch = m_vertexBufferView.SizeInBytes; <span class="hljs-comment">//コピーするデータのサイズ。</span>
subResourceData.SlicePitch = <span class="hljs-number">1</span>;
<span class="hljs-comment">//コピーを実行。</span>
re.Upload(
	m_vertexBuffer.Get(),
	<span class="hljs-number">0</span>,
	&amp;subResourceData,
	<span class="hljs-number">1</span>);
re.End(ge12.GetCommandQueue().Get());
</div></code></pre>
<p>GPUからメインメモリのデータが必要な例では、そのほかにも、下記のようなプレイヤーの体力に応じて画面が赤くなるような表現があります。</br></p>
<p align="center">
<!-- webから引っ張ってきた画像です。使用してOKな画像に差し替えをお願いします。. -->
<img src="fig/ダメージ表現.jpg"></img></br>
</p>
このような表現を行うためには、GPUはメインメモリに記憶されている、プレイヤーの残り体力にアクセスしないと行うことはできません。しかし、GPUがアクセスできるのはグラフィックメモリだけです。ですので、DMAコントローラーなどを利用してメインメモリの内容をグラフィックメモリにコピーする仕組みが必要になるのです。
<h3 id="122-%E3%81%AA%E3%81%9C%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%8C%E5%88%86%E3%81%8B%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%AE">1.2.2 なぜメモリが分かれているの？</h3>
<p> さて、なぜCPUとGPUとでメモリが分かれているのでしょうか？もしもCPUとGPUでメモリが共通であれば、あんな複雑なプログラムを書く必要はなくなります。端的に理由を説明すると、「CPUとGPUとで最高性能を求めると、メモリ要件が異なってくるから」というものになります。メインメモリはゲーム以外の用途でも利用されます。そのため、汎用性の高く、複雑な要件が求められます。例えば、メモリに載らなくなったデータをハードディスクに退避させる仕組みや、ユーザーが自由にメモリを増設できる仕組みなどです。一方グラフィックメモリはグラフィックに関する用途でしか利用されません。そして、求められる要件も「とにかく高速にデータの転送を行えるようにしてほしい」というシンプルなものです。GPUは大量の演算を行います。その時に演算に必要なデータ、頂点データ、テクスチャ、インデックス情報などを大量にメモリからロードする必要があります。そのため、グラフィックメモリは拡張性や汎用性を無視してもいいが、高速にデータを転送することができる必要があるわけです。このように、CPUとGPUとで求められる要件が異なっているため、メモリが分かれています。</br></br>
<img src="fig/メインメモリとグラフィックメモリにが別の理由.png"></img></br></p>
<p>下記は、私が使っているPCのメモリのスペック表です。メインメモリはDDR4、グラフィックメモリはGDDR5になっています。データを読み込む速度の指標となるメモリ帯域が、メインメモリは42.7GB/sであるのに対して、グラフィックメモリは192.2GB/sと約4.5倍の速度になっています。
<img src="fig/メモリ帯域表.png" ></br></p>
<h3 id="123-%E3%83%A6%E3%83%8B%E3%83%95%E3%82%A1%E3%82%A4%E3%83%89%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3">1.2.3 ユニファイドメモリアーキテクチャ</h3>
<p> ここまで、CPUとGPUとでメモリは分かれていているものだと説明してきました。しかし、分かれていることによりプログラムは複雑になり読みにくくなってしまいます。CPUとGPUのメモリを統合してしまえば、プログラムはシンプルになるのですが、1.2.2で説明したように、CPUとGPUとで最高性能を求めると、メモリに求める要件というものが異なってくるため、ハードウェア的に統合することは難しいのが現実です。そこで、ソフトウェア的に、プログラマーから見た場合はあたかもメモリが統一されているかのように振る舞うことができる、ユニファイドメモリアーキテクチャが登場しました。</br></p>
<p align="center">
<img src="fig/ユニファイドメモリアーキテクチャ.png"></img></br>
</p>
このアーキテクチャでは仮想メモリという偽物のメモリを用意しています。CPUとGPUはこの仮想メモリにアクセスします。そして、ハードウェアがアクセスしているメモリに応じて、適切な物理メモリ、本物のメモリにアクセスしています。この仕組みによって、プログラマーから見るとGPUもCPUも同じメモリにアクセスしているようにプログラムを記述することができます。つまり、ユニファイドメモリアーキテクチャであれば、1.2.1のメモリ転送の項目で記述した、頂点バッファのデータコピーは下記のようにシンプルに書けるようになるわけです。
<pre class="hljs"><code><div><span class="hljs-comment">//頂点バッファの内容をグラフィックメモリにコピー。</span>
<span class="hljs-built_in">memcpy</span>(m_vertexBuffer, srcVertices, vertexBufferSize);
</div></code></pre>
<p>しかし、DirectX12では、基本的にメモリは分かれている前提でのプログラミングを行うようになっています。</br></p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<blockquote>
<p>Intel HD Graphicsなどのcpuに統合されているGPUでは、グラフィックメモリというものは用意されておらず、CPUが使用しているメインメモリの一部を使用するような形になります。そのため、統合プロサッサは真のユニファイドメモリアーキテクチャといえるのですが、メモリ帯域が足りない、メモリの容量も足りないと言った問題を抱えてしまうため、パフォーマンスの面ではどうしても単体のGPUに劣ってしまいます。</p>
</blockquote>
<h3 id="124-%E3%81%BE%E3%81%A8%E3%82%81">1.2.4 まとめ</h3>
<ol>
<li><strong>CPUとGPUとでメモリは物理的に分かれている</strong></br>
CPUとGPUとで最高性能を求めると、メモリ要件が異なってくるため、メモリが別々になっています。</li>
<li><strong>基本的にCPUはメインメモリ、GPUはグラフィックメモリにしかアクセスできない</strong></br>
これは、後々シェーダープログラミングを行っていくときに重要になってくるので、しっかりと押さえておいてください。</li>
<li><strong>メインメモリ→グラフィックメモリ、グラフィックメモリ→メインメモリにデータを転送する仕組みが必要</strong></br>
これも2と同様に、後々重要になってきます。</li>
</ol>
<h2 id="13-%E7%B5%B5%E3%81%8C%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%82%8B%E3%81%BE%E3%81%A7">1.3 絵が表示されるまで</h2>
<p>ここまでCPUとGPU、メインメモリとグラフィックメモリについて学んできました。3DCGを画面に表示するためには、絵を描きなさい！と命令を出す司令塔のCPUと絵を描くことに特化したアーティストのGPUの二つのプロセッサが存在していることを学びました。では、もう少し具体的に、最終的に絵が出るまでどのような流れになっているのかを見ていきましょう。</p>
<h3 id="131-%E3%83%89%E3%83%AD%E3%83%BC%E3%82%B3%E3%83%BC%E3%83%AB">1.3.1 ドローコール</h3>
<p> 絵を描くためにはGPUに対して絵を描きなさい！と命令を出す必要があります。この命令はドローコールと呼ばれます。Unityなどでゲームを作ったことがある方なら聞いたことがあるのではないかと思います。「処理を早くするためにはドローコールを減らしなさい」と言われているのを聞いたことがあるのではないでしょうか。このドローコールの最適化に関しては、最適化のチャプターで詳しく説明します。</br>
 さて、少しGPUの気持ちになって考えてみてください。あなたは「絵を描きなさい！」と命令されました。さてどんな絵を描けばいいのでしょうか？かわいい女の子のキャラクターを描けばいいのでしょうか？もしくは、カッコいい男の子のキャラクター、ひょっとすると可愛らしいゆるキャラかもしれません。「絵を描きなさい！」という命令だけでは、どんな絵を描けばいいのか分かりませんよね？なので、ドローコールを行う前に、どんな絵を描くのか？といった情報もGPUに教えてやる必要があります。下記のコードは犬の3Dモデルを描くためにドローコールを行う疑似コードです。</p>
<pre class="hljs"><code><div><span class="hljs-comment">//犬のモデルの頂点バッファを設定する。</span>
SetVertexBuffer( dogVertexBuffer );
<span class="hljs-comment">//犬のモデルのテクスチャを設定する。</span>
SetTexture( dogTexture ) ;
<span class="hljs-comment">//ここまでに設定した内容でドローコールを実行。</span>
Draw();
</div></code></pre>
<p>このコードはあくまでも疑似コードなので、実際のコードはここまでシンプルではありませんが、ドローコールに必要な情報を端的に表しています。3Dモデルの絵を描いてもらうためには、頂点座標、模様を表すテクスチャなどが必要になります。このドローコールが実行されるとGPUは絵を描きだすわけです。</p>
<h3 id="132-%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3">1.3.2 レンダリングパイプライン</h3>
<p> CPUからドローコールが実行されると、そこからGPUは絵を描き始めるわけです。この時、GPUは決められた手順で絵を描いていきます。この絵を描くための手順がレンダリングパイプラインと呼ばれています。例えば、あなたが絵を描くときは下記のような手順を踏むのではないでしょうか。</p>
<ol>
<li>キャンパスを用意する。</li>
<li>鉛筆を用意する。</li>
<li>鉛筆を使って下書きを行う。</li>
<li>絵具を用意する。</li>
<li>絵具を使って絵を仕上げる。</li>
</ol>
<p> これと同じように、GPUも画面に絵を表示するまでの決められた手順というものがあります。これがレンダリングパイプラインと呼ばれているものです。この手順は近年、非常に複雑になってきているのですが、ここでは手順を必要最小限にして説明にとどめておきます。さらに詳しい話は、Chpater8のレンダリングパイプライン発展で説明します。</p>
<div style="page-break-before:always"></div>
<ol>
<li>入力アセンブラ : グラフィックメモリから設定されている頂点バッファ、インデックスバッファなどをロードする 。</li>
</ol>
<p align="center">
<img src="fig/入力アセンブラ_0.png" width="400"></img></br>
</p>
<ol start="2">
<li>頂点シェーダー : 頂点データをスクリーン空間に変換する。</br></li>
</ol>
<p align="center">
<img src="fig/座標変換.png" width="400"></img></br>
</p>
<ol start="3">
<li>ラスタライザ : 絵を描くために塗りつぶす必要があるピクセルを決定する。</br></li>
</ol>
<p align="center">
<img src="fig/ラスタライザ.png" width="300"></img></br>
</p>
<ol start="4">
<li>ピクセルシェーダー : ピクセルのカラーを決定する。</br></li>
</ol>
<p align="center">
<img src="fig/1_2.png" width="300"></img></br>
</p>
<p> これらがGPUが行う仕事、レンダリングパイプラインを簡単に説明したものです。まず、<strong>入力アセンブラ</strong>は絵を描くために必要な頂点バッファやインデックスバッファと呼ばれるデータを準備します。続いて、<strong>頂点シェーダー</strong>で頂点座標にワールド行列、ビュー行列、プロジェクション行列を乗算して、スクリーン空間に変換します。スクリーン空間に変換できたら、<strong>ラスタライザ</strong>で絵を表示するために塗りつぶす必要があるピクセルを決定します。最後に<strong>ピクセルシェーダー</strong>で陰影の計算などを行ってピクセルカラーを決定してピクセルを塗りつぶしていきます。
 これらの仕事はステージと呼ばれます。この中で、頂点シェーダーとピクセルシェーダーは、プラグラマが自由にプログラミングできるステージとなっており、非常に高い柔軟性を持っています。一方ラスタライザや入力アセンブラは、ある程度固定化されたステージで、プログラマが自由にプログラミングすることはできません。これらのステージについてまとめたものが表1.3.1です。
</br></p>
<p><strong>表1.3.1</strong></p>
<table>
<thead>
<tr>
<th>ステージ名</th>
<th>説明</th>
<th>柔軟性</th>
</tr>
</thead>
<tbody>
<tr>
<td>入力アセンブラ</td>
<td>データの準備</td>
<td>低い</td>
</tr>
<tr>
<td>頂点シェーダー</td>
<td>座標変換</td>
<td>高い</td>
</tr>
<tr>
<td>ラスタライザ</td>
<td>塗りつぶすピクセルの決定</td>
<td>低い</td>
</tr>
<tr>
<td>ピクセルシェーダー</td>
<td>ピクセルカラーの計算</td>
<td>高い</td>
</tr>
</tbody>
</table>
<p> このうち、頂点シェーダーとピクセルシェーダーは本書のメインテーマとなっており、Chapter2以降でさらに詳しく見ていくことにします。</p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h3 id="133-%E5%85%A5%E5%8A%9B%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9">1.3.3 入力アセンブラ</h3>
<p> 入力アセンブラはCPUからドローコールが実行されると、GPUが真っ先に実行する仕事です。入力アセンブラの仕事は、絵を描くためのデータを準備することです。準備するデータは頂点バッファ、インデックスバッファ、入力レイアウト、プリミティブタイプなどのデータです。ドローコールが実行されると、GPUはグラフィックメモリから必要なデータをレジスタという場所に運んできます。</br></p>
<p><strong>[図?.? グラフィックメモリから必要なデータを運んでいる]</strong></p>
<p align="center">
<img src="fig/入力アセンブラ_0.png" ></img></br>
</p>
<p><strong>[図?.? 必要なデータをレジスタに運ぶ]</strong></p>
<p align="center">
<img src="fig/入力アセンブラ_1.png"></img></br>
</p>
<p>レジスタとは、非常に高速に読み書きができるメモリです。グラフィックメモリはメインメモリに比べて高速だという話をしましたが、レジスタはさらに高速です。ですので、絵を描くときには毎回グラフィックメモリにデータを参照しに行くのではなく、一旦レジスタにデータを運んできて、そこからデータを参照することで処理の高速化を実現しています。</p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h3 id="134-%E9%A0%82%E7%82%B9%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC">1.3.4 頂点シェーダー</h3>
<p> このステージでは、3Dモデルの頂点座標をスクリーン空間に変換します。</p>
<p align="center">
<img src="fig/座標変換.png" width="400"></img></br>
</p>
&emsp;頂点シェーダーはプログラマブルなステージです。つまりプログラミングを行う必要があります。頂点シェーダーの主な仕事は3Dモデルの頂点をスクリーン空間に変換することなので、ほとんどの場合で、下記のような処理を実装します。
<ol>
<li>ローカル座標系の頂点をワールド座標系に変換する。</li>
<li>ワールド座標系の頂点をカメラ座標系に変換する。</li>
<li>カメラ座標系の頂点をスクリーン座標系に変換する。</li>
</ol>
<p>処理の詳しい説明はChapter2の頂点シェーダー入門で説明しますので、ここでは簡単にだけ説明しますが、Blender、3dsMax、mayaなどといった3DCGソフトウェアで作成された3Dモデルをテレビ画面など表示するために、それらの頂点をスクリーン空間に変換する必要があります。このときに、ベクトル(座標)と行列の乗算が行われて、座標変換が行われています。ですので、先ほどの1～3ではベクトルと行列の乗算が行われていることになります。</p>
<ol>
<li>
<p>ローカル座標系の頂点をワールド座標系に変換する。</p>
<p>→ <strong>ワールド座標系の座標　＝　ローカル座標系の座標　×　ワールド行列</strong></p>
</li>
<li>
<p>ワールド座標系の頂点をカメラ座標系に変換する。</p>
<p>→ <strong>カメラ座標系の座標　＝　ワールド座標系の座標　×　カメラ行列</strong></p>
</li>
<li>
<p>カメラ座標系の頂点をスクリーン座標系に変換する。</p>
<p>→ <strong>スクリーン座標系の座標　＝　カメラ座標系の座標　×　プロジェクション行列</strong></p>
</li>
</ol>
<p> さて、確かにスクリーン空間への座標変換が頂点シェーダーの仕事なのですが、この処理を行うだけであるならば、プログラマブルである必要はありません。プログラマブルであるということは、自由にプログラミングができるわけなので、極端に言えば、必ずしも座標変換する必要はないのです！これについてはChapter2以降で詳しく見ていきます。ここでは、頂点シェーダーというのは、頂点座標をスクリーン空間に変換しているのだと理解しておいてください。</p>
<div style="page-break-before:always"></div>
<h3 id="135-%E3%83%A9%E3%82%B9%E3%82%BF%E3%83%A9%E3%82%A4%E3%82%B6">1.3.5 ラスタライザ</h3>
<p> ラスタライザは頂点シェーダーで座標変換された3Dモデルを画面に表示するために、塗りつぶす必要があるピクセルを決定します。</p>
<p align="center">
<img src="fig/ラスタライザ.png" width="300"></img></br>
</p>
&emsp;ラスタライザは頂点シェーダと違い、プログラマブルではなく、固定的なステージです。ただし、柔軟性が全くないわけではなく、いくつかの設定で処理を変更することができます。例えば下記のような設定があります。
<h4 id="%E5%A1%97%E3%82%8A%E3%81%A4%E3%81%B6%E3%81%97%E8%A8%AD%E5%AE%9A">塗りつぶし設定</h4>
<p> この設定では、ピクセルの塗りつぶし方を変更することができます。DirectX12には2種類の塗りつぶしモードがあり、D3D12_FILL_MODE_WIREFRAMEとD3D12_FILL_MODE_SOLIDがあります。
D3D12_FILL_MODE_WIREFRAMEを設定した場合はワイヤーフレームモードで塗りつぶされます。
<img src="fig/wireframe.png" width="170"></img></br></p>
<p>D3D12_FILL_MODE_SOLIDを設定した場合は、皆さんのイメージ通りの塗りつぶしが行われます。
<img src="fig/solid.png" width="170"></img></br></p>
<h4 id="%E3%82%AB%E3%83%AA%E3%83%B3%E3%82%B0%E8%A8%AD%E5%AE%9A%E5%A1%97%E3%82%8A%E3%81%A4%E3%81%B6%E3%81%97%E3%81%AA%E3%81%97%E8%A8%AD%E5%AE%9A">カリング設定(塗りつぶしなし設定)</h4>
<p> この設定では、ポリゴンカリングを設定することができ、DirectX12では、D3D12_CULL_MODE_FRONT(ポリゴンの表側をカリング)、D3D12_CULL_MODE_BACK(ポリゴンの裏側をカリング)、D3D12_CULL_MODE_NONE(カリングなし)が設定できます。</br></br>
D3D12_CULL_MODE_FRONTを設定するとポリゴンの表側が塗りつぶされません。</br>
<img src="fig/cull_front.png" width="170"></img></br></p>
<p>D3D12_CULL_MODE_BACKを設定するとポリゴンの裏側が塗りつぶしされません。</br>
<img src="fig/cull_back.png" width="170"></img></br></p>
<p>D3D12_CULL_MODE_NONEを設定するとカリングなしになります。</br>
<img src="fig/cull_back.png" width="170"></img></br>
 D3D12_CULL_MODE_FRONTを指定すると、ポリゴンの表面が表示されなくなるので、異様な見た目になります。D3D12_CULL_MODE_BACKを指定すると、ポリゴンの裏面が表示されなくなるので、普段皆さんが見慣れている見た目になります。D3D12_CULL_MODE_NONEを指定すると、表面も裏面も表示されるので、今回のケースだとD3D12_CULL_MODE_BACKと同じ結果になります。
 ポリゴンのカリング設定を適切に行うと無駄な処理が行われなくなります。今回のケースですとポリゴンの裏面を描画する必要はないので、D3D12_CULL_MODE_BACKを指定してやればいいわけです。さて、ここで疑問がでてきます。ポリゴンの裏面を描画するケースや、両面描画するケースってあるの？って思いませんでしたか？この疑問については、【todo あとで関連するチャプターを記入する】で取り上げさせてもらいますので、楽しみにしていてください。</p>
<h3 id="136-%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC">1.3.6 ピクセルシェーダー</h3>
<p> ピクセルシェーダーはライスタライザで決定されたピクセルのカラーを決定するステージです。</p>
<p align="center">
<img src="fig/1_2.png" width="300"></img></br>
</p>
ピクセルシェーダーはプログラマブルなステージです。ピクセルシェーダーは、ありとあらゆるグラフィックスアルゴリズムの中核をなしていて、シェーダープログラミングの花形といえるステージです。もっとも典型的な利用のされ方は、ピクセルの陰影付けです。ピクセルに法線という、向きを表す情報と、ライトの情報を持たせて、陰影を計算していきます。みんなが大好きなセルシェーディングでもピクセルシェーダーが活躍します。詳しくはChapter3以降で見ていきますので、ここではこれくらいにしておきましょう。
<h3 id="137-%E3%81%BE%E3%81%A8%E3%82%81">1.3.7 まとめ</h3>
<ol>
<li>絵を表示するためには、CPUからGPUに対して描画命令(ドローコール)を行う必要がある。</li>
<li>画面に絵を表示するための決められた手順があり、レンダリングパイプラインと呼ばれている。</li>
<li>このチャプターでは、入力アセンブラ、頂点シェーダー、ラスタライザ、ピクセルシェーダーを学んだ。</li>
<li>入力アセンブラ：絵を描くために必要なデータを準備する。</li>
<li>頂点シェーダー : 頂点データをスクリーン空間に変換する。</li>
<li>ラスタライザ：塗りつぶすピクセルを決定する。</li>
<li>ピクセルシェーダー：ピクセルのカラーを決定する。</li>
</ol>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h1 id="chapter-2-%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E5%85%A5%E9%96%80-%E3%81%9D%E3%81%AE%EF%BC%91">Chapter 2 シェーダー入門 その１</h1>
<p> Chapter1でレンダリングパイプラインについて学びました。このパイプラインには処理ごとにステージ分けされていて、柔軟性が低い、入力アセンブラやラスタライザなどのステージは固定機能ステージと呼ばれています。一方柔軟性が高い、頂点シェーダーやピクセルシェーダーなどのプログラマブルステージと呼ばれています。DirectXでプログラマブルステージが用意されたのはDirectX8以降で、それ以前のバージョンでは固定機能ステージしか用意されていませんでした。表1.3.1で各ステージの柔軟性を見ましたが、表2.1のようにすべてのステージで柔軟性が低いになっていると考えてください。DirectX7以前のバージョンとステージ名は違うのですが、対比させるためにあえて同じにしています。</p>
<p><strong>表 2.1</strong></p>
<table>
<thead>
<tr>
<th>ステージ名</th>
<th>説明</th>
<th>柔軟性</th>
</tr>
</thead>
<tbody>
<tr>
<td>入力アセンブラ</td>
<td>データの準備</td>
<td>低い</td>
</tr>
<tr>
<td>頂点処理(現在の頂点シェーダーに相当)</td>
<td>座標変換</td>
<td>低い</td>
</tr>
<tr>
<td>ラスタライザ</td>
<td>塗りつぶすピクセルの決定</td>
<td>低い</td>
</tr>
<tr>
<td>ピクセル処理(現在のピクセルシェーダーに相当)</td>
<td>ピクセルカラーの計算</td>
<td>低い</td>
</tr>
</tbody>
</table>
<p> 頂点変換とピクセルカラー決定の固定機能はDirectX9までは存在していましたが、DirectX10で削除され、それ以降は固定機能は用意されなくなっています。これはDirectX以外のグラフィックスAPIの、Valukan、OpenGLES、Sonyや任天堂などが提供する専用SDK(PS4、PS3、WiiUなどで使用できるDirectXのようなもの)でも同じで、頂点変換やピクセルカラー決定の固定機能はグラフィックプログラミングの世界では過去のものとなっています。</p>
<h2 id="21-directx7%E4%BB%A5%E5%89%8D%E3%81%AE%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3">2.1 DirectX7以前のレンダリングパイプライン</h2>
<p> では、DirectX7以前のレンダリングパイプラインについて見ていきましょう。以前のレンダリングパイプラインでもCPUでドローコールが実行されることで、GPUは動き出します。図2.1のようにセットされた頂点バッファから頂点をフェッチ(取り出して)して、その頂点の座標をスクリーン座標系に変換して、塗りつぶすピクセルを決定して、そのピクセルの色を決定します。</p>
<p><strong>図2.1</strong>
<img src="fig/固定機能レンダリングパイプライン.png"></img></br></p>
<p>DirectX9までは3Dモデルの頂点をスクリーン空間に変換する頂点変換、ラスタライズ後に3Dモデルをスクリーン上で表示するためのピクセルカラーの決定といった処理をGPUがハードウェア的に用意してくれていました。しかし、DirectX10以降では、この機能はハードウェア側で用意されなくなり、プログラマーがプログラミングする必要が出てきました。そして、そのプログラムがシェーダーと呼ばれています。</p>
<h2 id="22-%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC">2.2 シェーダー</h2>
<p> シェーダーの導入でレンダリングパイプラインの頂点処理とピクセル処理を自分でプログラミングして、自由に頂点処理やピクセル処理を実装することができるようになりました。つまり、自分で頂点座標をスクリーン座標系へ変換したり、ピクセルカラーを決定するプログラムを書くことになります。つまりDirectX10以降ではシェーダーを書かないと絵は表示できなくなりました。図2.2はシェーダー導入後のレンダリングパイプラインです。</p>
<p><strong>図2.2</strong>
<img src="fig/DirectX10以降のレンダリングパイプライン.png"></img></br></p>
<p> この図のように、頂点処理とピクセル処理がシェーダーをロードして実行するという内容に変わっています。ではなぜ固定機能が削除されてシェーダーが登場したのでしょうか？せっかく用意されていたものがなくなって、同じものを作らないと絵を表示できなくなったなんて面倒だと思いませんか？では、シェーダーが生まれてきた背景を学んで行きましょう。</p>
<h2 id="23-%E3%81%AA%E3%81%9C%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%8C%E7%94%9F%E3%81%BE%E3%82%8C%E3%81%9F%E3%81%AE%E3%81%8B">2.3 なぜシェーダーが生まれたのか</h2>
<p> 固定機能しか存在していなかったDirectX7までは、マイクロソフトが用意したグラフィック表現しか行うことができませんでした。ピクセルカラーの決定で重要な要素としてライティングがあります。DirectX9までに用意されていた陰影計算モデルはディフューズライト、スペキュラライト、アンビエントライトくらいです。これらのライトの詳しい話は後々行うので、ここでは詳しく説明はしませんが、これらのライトで実現可能なグラフィック表現というと、せいぜい図2.3程度のものです。</p>
<p><strong>図2.3</strong></br>
<img src="fig/solid.png" width="200"></img></br></p>
<p> しかし、これらの機能だけでは、図2.4のようなアニメっぽい表現の実現は困難です。</p>
<p><strong>図2.4</strong></br>
<img src="fig/セルシェーダー.jpg" width="400"></img></br>
 このようなアニメ調の表現を実現するためには特殊なライティングアルゴリズムを実装する必要があります。しかし、シェーダーが生まれる前は新しいグラフィック表現を実現するためには、DirectXのバージョンアップを待つ必要がありました。また、ゲーム開発者という人たちは、他とは違うユニークな表現を行いたがるものです。その人たちの要望にすべて答えようとすると、DirectXのAPIはどんどん肥大化していくことになります。そこで、DirectXはバージョン8から開発者が行いたい表現をすぐに実現できるように、プログラマブルシェーダーを採用した設計に舵をとることとなります。</p>
<h2 id="24-%E9%A0%82%E7%82%B9%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E5%85%A5%E9%96%80">2.4 頂点シェーダー入門</h2>
<p> では、いよいよ実際にシェーダーを書いていってみましょう。まずはシンプルな三角形を表示するだけのプログラムを作ってみましょう。Sample_02_04/Sample_02_04.slnを立ち上げてください。VisualStudioのプロジェクトが立ち上がったら図2.6のボタンを押すかF5キーを押してプログラムを実行してください。すると図2.7のような灰色のウィンドウが立ち上がります。</p>
<p><strong>図2.6</strong></br>
<img src="fig/2_6.png" width="300"></img></br></p>
<p><strong>図2.7</strong></br>
<img src="fig/2_7.png" width="300"></img></br></p>
<h3 id="241-%E3%82%A6%E3%82%A3%E3%83%B3%E3%83%89%E3%82%A6%E3%82%BA%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E3%83%A1%E3%82%A4%E3%83%B3%E9%96%A2%E6%95%B0">2.4.1 ウィンドウズプログラムのメイン関数</h3>
<p> さて、頂点シェーダーの話に入る前に、Windowsアプリのプログラムについて見ていこうと思います。Windowsプログラミングはそれだけで書籍を一冊余裕で書けるくらいのボリュームがあるのですが、本書のメインはシェーダープログラムですので、ここはそこまでは掘り下げません。まず、VisualStudioのソリューションエクスプローラーからmain.cppを開いて下さい。</p>
<p><strong>図2.8</strong></br>
<img src="fig/2_4_1_1.png" width="300"></img></br>
もし、ソリューションエクスプローラーが表示されていない場合は、図2.4.2を参考にして、ソリューションエクスプローラーを表示してください。</p>
<p><strong>図2.9</strong></br>
<img src="fig/2_4_1_2.png" width="400"></img></br></p>
<p>main.cppを開けたら、13行目からのwWinMain関数を見てください。</p>
<p>[リスト2.1 main.cpp(13行目～)]</p>
<pre class="hljs"><code><div><span class="hljs-comment">///////////////////////////////////////////////////////////////////</span>
<span class="hljs-comment">// ウィンドウプログラムのメイン関数。</span>
<span class="hljs-comment">///////////////////////////////////////////////////////////////////</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">wWinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, <span class="hljs-keyword">int</span> nCmdShow)</span>
</span>{
    ・
    ・
    ・
    ・
}
</div></code></pre>
<p>C++、C#、Javaなどでコンソールアプリケーションを作成したときに、メイン関数というものを書いたことがあると思います。メイン関数はエントリーポイントと呼ばれる特殊な関数で、プログラムのスタート地点となる関数です。Windowsプログラムにもエントリーポイントがあって、今回のサンプルですとwWinMain関数がそれにあたります。</p>
<h3 id="242-%E4%B8%89%E8%A7%92%E5%BD%A2%E3%82%92%E8%A1%A8%E7%A4%BA%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E6%BA%96%E5%82%99">2.4.2 三角形を表示するための準備</h3>
<p> プログラムが起動すると、三角形を表示するための準備を行うプログラムがmain.cppの25行目(リスト 2.2)から記述されています。よく分からないプログラムだと思いますが、あまり気にしなくて構いません。簡単にだけ説明します。</p>
<ol>
<li><strong>ルートシグネチャの作成</strong></br>
ここでは気にしなくて構いません。</li>
<li><strong>シェーダーをロード</strong></br>
頂点シェーダーとピクセルシェーダのロードを行っています。</li>
<li><strong>パイプラインステートの作成</strong></br>
パイプラインステートとはレンダリングパイプラインの各ステージの設定です。Chapter1で学んだラスタライザステージのカリング設定や塗りつぶし設定、そして頂点シェーダーやピクセルシェーダーも設定します。ここでは私が作成したPipelineStateというクラスを利用しています。このクラスの中で3Dモデルの描画でよく使われる設定のパイプラインステートが作成されています。</li>
<li><strong>三角形の頂点バッファを作成</strong></br>
表示する三角形の頂点データを作成しています。今回の頂点データは座標のみのデータです。</li>
<li><strong>インデックスバッファを作成</strong></br>
ここでは気にしなくて構いません。</li>
</ol>
<p>[リスト2.2 main.cpp(25行目～)]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//１．ルートシグネチャを作成。</span>
RootSignature rootSignature;
InitRootSignature(rootSignature);

<span class="hljs-comment">//２．シェーダーをロード。</span>
Shader vs, ps;
vs.LoadVS(<span class="hljs-string">L"Assets/shader/sample.fx"</span>, <span class="hljs-string">"VSMain"</span>);
ps.LoadPS(<span class="hljs-string">L"Assets/shader/sample.fx"</span>, <span class="hljs-string">"PSMain"</span>);

<span class="hljs-comment">//３．パイプラインステートを作成。</span>
PipelineState pipelineState;
InitPipelineState(pipelineState, rootSignature, vs, ps);

<span class="hljs-comment">//４．三角形の頂点バッファを作成。</span>
<span class="hljs-comment">//頂点配列を定義。</span>
SimpleVertex vertices[] = {
    { <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span> },
    { <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span> },
    { <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span> },
};

VertexBuffer triangleVB;
triangleVB.Init(<span class="hljs-keyword">sizeof</span>(vertices), <span class="hljs-keyword">sizeof</span>(vertices[<span class="hljs-number">0</span>]));
triangleVB.Copy(vertices);

<span class="hljs-comment">//５．三角形のインデックスバッファを作成。</span>
<span class="hljs-comment">//インデックス配列</span>
short indices[] = {
    <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>
};
IndexBuffer triangleIB;
triangleIB.Init(<span class="hljs-keyword">sizeof</span>(indices), <span class="hljs-number">2</span>);
triangleIB.Copy(indices);
</div></code></pre>
<h3 id="243-%E4%B8%89%E8%A7%92%E5%BD%A2%E3%82%92%E8%A1%A8%E7%A4%BA%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E3%83%89%E3%83%AD%E3%83%BC%E3%82%B3%E3%83%BC%E3%83%AB">2.4.3 三角形を表示するためのドローコール</h3>
<p> 頂点バッファやシェーダーのロードなどの準備が終わったら、次は三角形を表示するためのドローコールです。ドローコールはmain.cppの74行目(リスト2.3)から記述されています。ここで行われているのは「1.3.1 ドローコール」に書かれていた疑似コードと相当します。ドローコールを実行する前に、これから描画する絵の情報を設定しています。</p>
<ol>
<li><strong>ルートシグネチャを設定</strong></br>
ここでは気にしなくて構いません。</li>
<li><strong>パイプラインステートの設定</strong></br>
ラスタライザ、入力アセンブラ、使用されるシェーダーなどの情報が一気に設定されます。</li>
<li><strong>プリミティブトポロジーの設定</strong></br>
ここでは気にしなくて構いません。</li>
<li><strong>頂点バッファの設定</strong></br>
今回は三角形を表示するので、さきほど作成した頂点バッファを指定しています。</li>
<li><strong>インデックスバッファの設定</strong></br>
ここでは気にしなくて構いません。</li>
<li><strong>ドローコール</strong></br>
これがGPUへの描画命令です。</li>
</ol>
<p>[リスト2.3 main.cpp(25行目～)]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//１．ルートシグネチャを設定。</span>
renderContext.SetRootSignature(rootSignature);
<span class="hljs-comment">//２．パイプラインステートを設定。</span>
renderContext.SetPipelineState(pipelineState);
<span class="hljs-comment">//３．プリミティブのトポロジーを設定。</span>
renderContext.SetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
<span class="hljs-comment">//４．頂点バッファを設定。</span>
renderContext.SetVertexBuffer(triangleVB);
<span class="hljs-comment">//５．インデックスバッファを設定。</span>
renderContext.SetIndexBuffer(triangleIB);
<span class="hljs-comment">//６．ドローコール</span>
renderContext.DrawIndexed(<span class="hljs-number">3</span>);
</div></code></pre>
<p>では、続いてGPU側のプログラムを見ていきましょう。</p>
<h3 id="244-%E9%A0%82%E7%82%B9%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC">2.4.4 頂点シェーダー</h3>
<p> DirectXではHLSL(High Level Shader Language)という言語を使って、シェーダ―プログラミングを行います。文法はC言語によく似ているので、C言語系列の言語(C++、Java、C#など)を勉強した人であれば言語仕様は比較的簡単に理解できると思います。頂点シェーダーもHLSLで記述されます。</br>
 頂点シェーダーは3Dモデルの全ての頂点に対して実行されるプログラムです。2.4.3のドローコールで設定されている3Dモデルの頂点数が100頂点の場合は、設定されている頂点シェーダーが100回実行されます(厳密には少し違いますが・・・)。では、頂点シェーダーを見ていきましょう。Sample_02_04/Assets/shader/sample.fxを開いてください。</p>
<p>[リスト2.4 sample.fx(9行目～)]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//頂点シェーダー。</span>
<span class="hljs-comment">//１．引数は変換前の頂点情報。</span>
<span class="hljs-comment">//２．戻り値は変換後の頂点情報。</span>
<span class="hljs-comment">//３．VSMainは</span>
<span class="hljs-function">VSOutput <span class="hljs-title">VSMain</span><span class="hljs-params">(VSInput In)</span> 
</span>{
	VSOutput vsOut = (VSOutput)<span class="hljs-number">0</span>;
	<span class="hljs-keyword">return</span> vsOut;
}
</div></code></pre>
<p> 9行目からのプログラムが頂点シェーダーのエントリーポイントです。VSMainという関数が頂点の数分だけ実行されます。では、もう少し詳細に見ていきましょう。</br></p>
<ol>
<li><strong>引数は変換前の頂点情報</strong></br>
引数にはこれから処理される頂点１つ分の情報が入っています。入力アセンブラがグラフックメモリから持ってきた頂点情報が頂点シェーダーに渡されていることになります。VSInputはユーザー定義の構造体で、入力される頂点データ構造です。詳細については後述します。</li>
<li><strong>戻り値は変換後の頂点情報</strong></br>
戻り値は頂点シェーダーで変換された頂点情報です。頂点シェーダーは必ず処理した結果の頂点情報を戻り値として返す必要があります。VSOutputはユーザー定義の構造体で、出力される頂点データ構造です。詳細については後述します。</br></li>
</ol>
<p> 頂点シェーダーの典型的な処理は、ワールド行列、ビュー行列、プロジェクション行列を使って、頂点座標をスクリーン空間に変換することです。しかし今回のサンプルでは頂点シェーダーは何もしていません。ですからサンプルを実行しても灰色のウィンドウが表示されるだけなのです。</p>
<h3 id="245-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E5%85%A5%E5%8A%9B%E3%81%95%E3%82%8C%E3%81%9F%E9%A0%82%E7%82%B9%E5%BA%A7%E6%A8%99%E3%82%92%E3%81%9D%E3%81%AE%E3%81%BE%E3%81%BE%E5%87%BA%E5%8A%9B%E3%81%AB%E6%B8%A1%E3%81%99">2.4.5 【ハンズオン】入力された頂点座標をそのまま出力に渡す</h3>
<p> では、Sample.fxを改造して、変換後の頂点データを返せるようにしてみましょう。リスト2.5のように頂点シェーダーを改造して下さい。</p>
<p>[リスト2.5 sample.fx(9行目～)]</p>
<pre class="hljs"><code><div>//頂点シェーダー。
//１．引数は変換前の頂点情報。
//２．戻り値は変換後の頂点情報。
//３．VSMainは
VSOutput VSMain(VSInput In) 
{
	VSOutput vsOut = (VSOutput)0;
    //入力された頂点座標を変換せずに出力する。
    vsOut.pos = In.pos;
	return vsOut;
}
</div></code></pre>
<p> リスト2.5のプログラムを入力すると図2.10のような三角形が表示されたと思います。</br></br>
<strong>図2.10</strong></br>
<img src="fig/2_10.png" width="400"></img></br>
 今回入力してもらった頂点シェーダーは、頂点座標の変換は行わずに、そのまま出力しています。では、なぜ変換していないのに画面に絵が表示されたのでしょうか？答えは入力された頂点データがすでに変換済みのデータになっていたからです。たまたまスクリーンに映せる座標になっていたと考えてもらっても構いません。</p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h3 id="246-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E5%85%A5%E5%8A%9B%E3%81%95%E3%82%8C%E3%81%9F%E9%A0%82%E7%82%B9%E5%BA%A7%E6%A8%99%E3%82%92%E6%8B%A1%E5%A4%A7%E3%81%97%E3%81%A6%E5%87%BA%E5%8A%9B%E3%81%AB%E6%B8%A1%E3%81%99">2.4.6 【ハンズオン】入力された頂点座標を拡大して出力に渡す</h3>
<p> では、次は頂点座標を２倍にして出力座標に渡してみましょう。リスト2.6のように頂点シェーダーを改造してください。</br>
[リスト2.6 sample.fx(9行目～)]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//頂点シェーダー。</span>
<span class="hljs-comment">//１．引数は変換前の頂点情報。</span>
<span class="hljs-comment">//２．戻り値は変換後の頂点情報。</span>
<span class="hljs-comment">//３．VSMainは</span>
<span class="hljs-function">VSOutput <span class="hljs-title">VSMain</span><span class="hljs-params">(VSInput In)</span> 
</span>{
	VSOutput vsOut = (VSOutput)<span class="hljs-number">0</span>;
    <span class="hljs-comment">//頂点座標を拡大して出力座標に渡す</span>
    vsOut.pos = In.pos;
    vsOut.pos.x *= <span class="hljs-number">2.0f</span>; <span class="hljs-comment">//X座標を２倍にする。</span>
    vsOut.pos.y *= <span class="hljs-number">2.0f</span>; <span class="hljs-comment">//Y座標を２倍にする。</span>
	<span class="hljs-keyword">return</span> vsOut;
}
</div></code></pre>
<p> リスト2.6のプログラムを入力すると図2.10のような三角形が表示されたと思います。</br></br>
<strong>図2.10</strong></br>
<img src="fig/2_11.png" width="400"></img></br></p>
<h3 id="247-%E8%AA%B2%E9%A1%8C%E5%85%A5%E5%8A%9B%E3%81%95%E3%82%8C%E3%81%9Fx%E5%BA%A7%E6%A8%99%E3%82%9215%E5%80%8Dy%E5%BA%A7%E6%A8%99%E3%82%9205%E5%80%8D%E3%81%97%E3%81%A6%E5%87%BA%E5%8A%9B%E3%81%AB%E6%B8%A1%E3%81%99">2.4.7 【課題】入力されたX座標を1.5倍、Y座標を0.5倍して出力に渡す</h3>
<p> 図2.12のように表示できるように、頂点シェーダーを改造してください。</br></p>
<p><strong>図2.12</strong></br>
<img src="fig/2_12.png" width="400"></img></br></p>
<p>答え:Sample_02_04/Assets/shader/sample_2_4_7.fx</p>
<h3 id="248-%E5%85%A5%E5%8A%9B%E9%A0%82%E7%82%B9%E6%A7%8B%E9%80%A0%E4%BD%93">2.4.8 入力頂点構造体</h3>
<p> では、ユーザー定義の入力頂点構造体について見ていきましょう。入力頂点構造体は次のように定義されています。</p>
<pre class="hljs"><code><div>//頂点シェーダーへの入力頂点構造体。
struct VSInput{
	float4 pos : POSITION;
};
</div></code></pre>
<p> C言語の構造体と非常によく似ていますが、少しだけ違う点があります。では、その違いについて見ていきましょう。</p>
<h4 id="hlsl%E3%81%AE%E7%B5%84%E3%81%BF%E8%BE%BC%E3%81%BF%E5%9E%8B">HLSLの組み込み型</h4>
<p>まず、HLSLにはfloat4という型があります。float4はx,y,z,wからなる４要素のベクトル型です。下記のような構造体として定義されていると考えるとイメージしやすいのではないでしょうか。</br></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">float4</span>{</span>
	<span class="hljs-keyword">float</span> x;
    <span class="hljs-keyword">float</span> y;
    <span class="hljs-keyword">float</span> z;
    <span class="hljs-keyword">float</span> w;
};
</div></code></pre>
<p> シェーダープログラミングでは、ベクトルと行列の演算を多用するため、それらを扱うための型が言語として組み込まれています。表2.2は利用頻度の高い、HLSL独自の組み込み型のリストです。</br></p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<p><strong>表 2.2</strong></p>
<table>
<thead>
<tr>
<th>型名</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>float2</td>
<td>float型のx,yの２要素を持つ浮動小数ベクトル型</td>
</tr>
<tr>
<td>float3</td>
<td>float型のx,y,zの２要素を持つ浮動小数ベクトル型</td>
</tr>
<tr>
<td>float4</td>
<td>float型のx,y,z,wの２要素を持つ浮動小数ベクトル型</td>
</tr>
<tr>
<td>int2</td>
<td>int型のx,yの２要素を持つ浮動小数ベクトル型</td>
</tr>
<tr>
<td>int3</td>
<td>int型のx,y,zの２要素を持つ浮動小数ベクトル型</td>
</tr>
<tr>
<td>int4</td>
<td>int型のx,y,z,wの２要素を持つ浮動小数ベクトル型</td>
</tr>
<tr>
<td>float3x3</td>
<td>float型の３×３行列</td>
</tr>
<tr>
<td>float4x3</td>
<td>float型の４×３行列</td>
</tr>
<tr>
<td>float4x4</td>
<td>float型の４×４行列</td>
</tr>
</tbody>
</table>
<p> いきなり大量に型が出てきたので、辟易としたかもしれませんが、ベクトル型とマトリクス型があるということだけ押さえておけば十分です。</p>
<h4 id="%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%82%AF%E3%82%B9">セマンティクス</h4>
<p> セマンティクスは、頂点のどのデータを頂点シェーダーで使用するのかを指定するためのものになります。3Dモデルの頂点が持っているデータというのは座標だけではありません。色を表すカラー、向きを表す法線、サンプリングするテクスチャの位置を表すUV座標など多岐にわたります。表2.3は代表的な頂点データです。</p>
<p><strong>表 2.3</strong></p>
<table>
<thead>
<tr>
<th>名前</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>座標</td>
<td>頂点の位置を表すデータ。x,y,zの３成分があれば十分なのだが、行列演算との関係上wを含んだ４要素で扱われることが多い。</td>
</tr>
<tr>
<td>法線</td>
<td>頂点の向きを表すデータ。x,y,zの３成分で扱われることが多い。</td>
</tr>
<tr>
<td>接ベクトル</td>
<td>法線マップを利用した法線の算出の際に使用される。</td>
</tr>
<tr>
<td>カラー</td>
<td>頂点色を表すデータ。x,y,z,wの４成分で扱われることが多い。xがR成分、yがG成分、zがB成分、wがα成分になる。</td>
</tr>
<tr>
<td>UV座標</td>
<td>ポリゴンに貼り付けるテクスチャの位置を表す座標。x,yの２成分で扱われることが多い。</td>
</tr>
<tr>
<td>スキンウェイト</td>
<td>スキンアニメーションを行うときに使用される。関連付けされているボーンへの影響度。</td>
</tr>
<tr>
<td>スキンインデックス</td>
<td>スキンアニメーションを行うときに使用される。関連付けされているボーンの番号。</td>
</tr>
</tbody>
</table>
<p> その他にも頂点データはいくつか種類があります。実は頂点データは複数のデータの集合体なのです。次のプログラムは頂点バッファをC++で定義したものです。</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//頂点構造体</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span>{</span>
	<span class="hljs-keyword">float</span> position[<span class="hljs-number">4</span>];      <span class="hljs-comment">//座標</span>
    <span class="hljs-keyword">float</span> normal[<span class="hljs-number">3</span>];        <span class="hljs-comment">//法線</span>
    <span class="hljs-keyword">float</span> color[<span class="hljs-number">4</span>];         <span class="hljs-comment">//カラー</span>
    <span class="hljs-keyword">float</span> uv[<span class="hljs-number">2</span>];            <span class="hljs-comment">//UV座標</span>
};
<span class="hljs-comment">//頂点バッファ</span>
Vertex vertexBuffer[<span class="hljs-number">5</span>];
</div></code></pre>
<p> 次の図2.13は頂点バッファを図示化したものです。</p>
<p><strong>図2.13</strong></br>
<img src="fig/2_13.png"></img></br></p>
<p> さて、ここから本題です。図2.13のような頂点バッファと、リスト2.7のような頂点シェーダーが設定されてドローコールが実行されている場合を考えてください。</br>
[リスト2.7]</p>
<pre class="hljs"><code><div>//頂点シェーダーへの入力頂点構造体。
struct VSInput{
	float4 hoge : POSITION;
};

//頂点シェーダーの出力。
struct VSOutput{
	float4 pos : SV_POSITION;
};

//頂点シェーダー。
VSOutput VSMain(VSInput In) 
{
	VSOutput vsOut = (VSOutput)0;
    vsOut.pos = In.hoge; //1.In.hogeは頂点のどのデータを参照している？？？
	return vsOut;
}
</div></code></pre>
<p> この時、頂点シェーダーに入力されているIn.ほhogeは頂点データの何を引っ張ってきているのでしょうか？座標でしょうか？法線でしょうか？カラーでしょうか？答えは座標です。なぜ座標のデータが引っ張ってこれているかというと、頂点データから座標を取ってきなさいとセマンティクスで指定されているからです。</p>
<pre class="hljs"><code><div>//頂点シェーダーへの入力頂点構造体。
struct VSInput{
	float4 hoge : POSITION;　//これがセマンティクス！！！
};
</div></code></pre>
<p> 下記のようにセマンティクスが指定されている場合は、hoge2はUV座標のデータを取ってきています。</p>
<pre class="hljs"><code><div>//頂点シェーダーへの入力頂点構造体。
struct VSInput{
	float4 hoge : POSITION;　　
    float2 hoge2 : TEXCOORD;
};
</div></code></pre>
<p> 表2.4は代表的な入力セマンティクスの一覧です。</br>
<strong>表 2.4</strong></p>
<table>
<thead>
<tr>
<th>名前</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>POSITION</td>
<td>オブジェクトスペースの頂点座標</td>
</tr>
<tr>
<td>COLOR</td>
<td>頂点カラー</td>
</tr>
<tr>
<td>NORMAL</td>
<td>法線ベクトル</td>
</tr>
<tr>
<td>TANGENT</td>
<td>接ベクトル</td>
</tr>
<tr>
<td>TEXCOORD</td>
<td>UV座標</td>
</tr>
<tr>
<td>BLENDWEIGHT</td>
<td>スキンアニメーションで使用するブレンディング率</td>
</tr>
<tr>
<td>BLENDINDICES</td>
<td>スキンアニメーションで使用するボーン番号</td>
</tr>
</tbody>
</table>
<p> このようにセマンティクスの役割は、シェーダーでどの頂点データを使用するのかを指定することとなります。</p>
<h3 id="249-%E5%87%BA%E5%8A%9B%E9%A0%82%E7%82%B9%E6%A7%8B%E9%80%A0%E4%BD%93">2.4.9 出力頂点構造体</h3>
<p> 最後に出力頂点構造体です。出力頂点構造体は頂点シェーダーから出力されるデータで、かならずしも入力頂点構造体とイコールではありません。また、この構造体もユーザー定義です。リスト2.7のプログラムであれば、VSOutput構造体が該当します。</p>
<h4 id="%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%82%AF%E3%82%B9">セマンティクス</h4>
<p> 出力頂点構造体のデータにもセマンティクスが指定されています。これは出力されるデータをどのようなデータとして扱うかを指定したものです。頂点シェーダーから出力されたデータはピクセルシェーダーに引き渡されます。この時に、頂点シェーダーから出力されたデータとバインドするために必要となります。考え方は入力構造体のセマンティクスと同じです。一点だけ注意が必要なのは、出力データとして座標を指定したい場合はSV_Positionを指定する必要があります。出力セマンティクスにPOSITIONを指定すると期待した動作にはならないので注意が必要です。</p>
<h3 id="2410-%E3%81%BE%E3%81%A8%E3%82%81">2.4.10 まとめ</h3>
<ol>
<li>３Ｄの絵を描くためには、描きたい絵の頂点バッファ、インデックスバッファ、パイプラインステージなどを作成する必要がある。</li>
<li>絵を描くためには、描きたい絵の情報を設定してドローコールを実行する必要がある。</li>
<li>ドローコールが実行されるとGPUが絵を描く仕事を始める。</li>
<li>頂点シェーダーは絵を描く仕事(レンダリングパイプライン)の１行程である。</li>
<li>頂点シェーダーはHLSLという言語で記述できるプログラマブルなステージである。</li>
<li>頂点シェーダーで、どの頂点データを処理するのかということを指定するためにセマンティクスと呼ばれるものがある。</li>
</ol>
<h2 id="25-%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E5%85%A5%E9%96%80">2.5 ピクセルシェーダー入門</h2>
<p> 2.4節で頂点シェーダーについて見てきました。3Dモデルの頂点座標がスクリーン空間に変換されると、画面上に3Dモデルのポリゴンが表示される位置が確定します。ポリゴンを表示する位置が確定すると、続いてラスタライザステージで、そのポリゴンを表示するために塗りつぶす必要のあるピクセルが決定します。塗りつぶすピクセルが決定すると、その一つ一つのピクセルに対してピクセルシェーダーが実行されます。例えば、塗りつぶすピクセルの数が300ピクセルだった場合、ピクセルシェーダーは300回実行されます。頂点シェーダーが設定されている頂点の数分だけ実行されている関係とよく似ています。では、ピクセルシェーを見てみましょう。Sample_02_05/Assets/shader/sample.fxを開いてください。</p>
<p>[リスト2.8 sample.fx(21行目～)]</p>
<pre class="hljs"><code><div>//ピクセルシェーダー。
float4 PSMain( VSOutput vsOut ) : SV_Target0
{
	return float4( 1.0f, 0.0f, 0.0f, 1.0f);
}
</div></code></pre>
<p> 18行目からのプログラムがピクセルシェーダーのエントリーポイントです。PSMainという関数が塗りつぶすピクセルの数分だけ実行されます。ピクセルシェーダーも頂点シェーダーと同様にHLSL言語で記述されています。では、もう少し詳細に見ていきましょう。</br></p>
<ol>
<li>引数は頂点シェーダーから出力された頂点情報を元に計算されたデータ
ピクセルシェーダーの引数の型が頂点シェーダーからの出力頂点構造体のVSOutputになっていることに気づいた方がいるかもしれません。ピクセルシェーダーに渡されている情報は頂点シェーダーの出力結果を元に計算されたデータが渡ってきています。これについての詳細は後述します。</li>
<li>戻り値はピクセルを塗りつぶすカラー
戻り値はピクセルのカラーで光の３原色のＲＧＢとαを返します。こちらも詳細は後述します。</li>
</ol>
<p> ピクセルシェーダーの典型的な処理はピクセルの陰影付けです。しかし、ピクセルシェーダーは頂点シェーダーと異なり、多様な処理を行います。ですので、ここではピクセルのカラーを決定するということだけ覚えておいてください。</p>
<h3 id="251-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E4%B8%89%E8%A7%92%E5%BD%A2%E3%82%92%E9%9D%92%E8%89%B2%E3%81%AB%E3%81%99%E3%82%8B">2.5.1 【ハンズオン】三角形を青色にする</h3>
<p> では、sample.fxをリスト2.9のように改造して、三角形を青色にできるようにしてみましょう。
[リスト2.9 Sample.fx(21行目～)]</p>
<pre class="hljs"><code><div>//ピクセルシェーダー。
float4 PSMain( VSOutput vsOut ) : SV_Target0
{
	return float4( 0.0f, 0.0f, 1.0f, 1.0f);
}
</div></code></pre>
<h3 id="252-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E4%B8%89%E8%A7%92%E5%BD%A2%E3%82%92%E7%B7%91%E8%89%B2%E3%81%AB%E3%81%99%E3%82%8B">2.5.2 【ハンズオン】三角形を緑色にする</h3>
<p> 続いて、sample.fxをリスト2.10のように改造して、三角形を緑色にできるようにしてみましょう。
[リスト2.10 Sample.fx(21行目～)]</p>
<pre class="hljs"><code><div>//ピクセルシェーダー。
float4 PSMain( VSOutput vsOut ) : SV_Target0
{
	return float4( 0.0f, 1.0f, 0.0f, 1.0f );
}
</div></code></pre>
<h3 id="253-%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%AE%E6%88%BB%E3%82%8A%E5%80%A4%E3%81%AF%E5%85%89%E3%81%AE%E4%B8%89%E5%8E%9F%E8%89%B2%EF%BC%8B%CE%B1">2.5.3 ピクセルシェーダーの戻り値は光の三原色＋α</h3>
<p> さて、ここまでのハンズオンでピクセルシェーダーの戻り値が光の３原色を表していることは何となく分かったかもしれません。念のため光の３原色について説明をしておくと、光の三原色とは赤と緑と青のことです。そして、この３つの色を混ぜ合わせることで色を表現するのがＲＧＢ法です。各色には発色の強さがあり、最小で0.0、最大で1.0になります。ちなみにフォトショップやWindows標準ペイントツールなどでは、最小で0、最大で255で表現されます。ですが、シェーダーでは0.0～1.0の範囲で正規化されています。正規化されている方が色々な計算で都合がいいからだと思われます。さて、残りのαですが、ペイントツールではαは不透明度として扱われているともいますが、ここで出力されるαは必ずしも不透明度な分けではありません。これはアルファブレンディングの設定によって変わります。この詳細はChapter 7のレンダリングパイプライン発展で説明します。</p>
<h3 id="254%E8%AA%B2%E9%A1%8C%E4%B8%89%E8%A7%92%E5%BD%A2%E3%82%92%E9%BB%84%E8%89%B2%E3%81%AB%E3%81%99%E3%82%8B">2.5.4【課題】三角形を黄色にする</h3>
<p> 図2.14のように、三角形を黄色で表示できるように、sample.fxを改造して下さい。</br>
(ヒント:黄色は赤と緑を混ぜ合わせることで表現できます。</br></p>
<p><strong>図2.14</strong></br>
<img src="fig/2_14.png" width="400"></img></br></p>
<p>答え：Sample_02_05/Assets/shader/sample_2_5_4.fx</p>
<h3 id="255-%E9%A0%82%E7%82%B9%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%8B%E3%82%89%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%AB%E6%B8%A1%E3%81%95%E3%82%8C%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF">2.5.5 頂点シェーダーからピクセルシェーダーに渡されるデータ</h3>
<p> ピクセルシェーダーに渡されるデータは、頂点シェーダーから出力されたデータを元に補完されたデータが渡されています。頂点シェーダーで計算されるのはポリゴンの３頂点のデータのみです。しかし、そのポリゴンを表現するために塗りつぶす必要があるピクセルは100個かもしれません。その時、ピクセルシェーダーに�����どの頂点のデータを渡せばいいのでしょうか。答えは、その３つの頂点のデータを使って、各ピクセルシェーダーに渡すデータを補完しています。図2.15を見てください。</br>
<strong>図2.14</strong></br>
<img src="fig/ラスタライザ�����の値補間.png" width="400"></img></br>
 このポリゴンは頂点シェーダーでカラーの情報も出力しており、頂点ごとに異なるカラーを出力しています。この時、１と２のピクセルのカラーはどのように計算されるのでしょうか。赤でしょうか青でしょうか？正解は３つの頂点を使用して補完して計算されるになります。例えば１のピクセルであれば、恐らく赤と青のピクセルが半々に混ざった紫のっぽいカラーになります。２のピクセルは赤と青と緑が均等に混じったグレーのようなカラーになります。実はこの補完の計算はラスタライザで行われています。ラスタライザは塗りつぶすピクセルを決定するだけではなく、頂点シェーダーから渡されたデータを各ピクセルに渡すために補完するという仕事もあったのです。</p>
<h3 id="256-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E9%A0%82%E7%82%B9%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%8B%E3%82%89%E5%8F%97%E3%81%91%E5%8F%96%E3%81%A3%E3%81%9F%E3%82%AB%E3%83%A9%E3%83%BC%E3%82%92%E5%87%BA%E5%8A%9B%E3%81%99%E3%82%8B">2.5.6 【ハンズオン】頂点シェーダーから受け取ったカラーを出力する</h3>
<p> Sample_05は頂点データとしてカラーが設定されていて、リスト2.11のように頂点シェーダーから出力されています。</br>
[リスト2.11 Sample.fx(1行目～)]</p>
<pre class="hljs"><code><div>//頂点シェーダーへの入力頂点構造体。
struct VSInput{
	float4 pos : POSITION;
	float3 color : COLOR; //頂点からカラーのデータを引っ張ってくる。
};
//頂点シェーダーの出力。
struct VSOutput{
	float4 pos : SV_POSITION;
	float3 color : COLOR; //カラーの情報も出力する。
};
//頂点シェーダー。
//１．引数は変換前の頂点情報。
//２．戻り値は変換後の頂点情報。
VSOutput VSMain(VSInput In) 
{
	VSOutput vsOut = (VSOutput)0;
	vsOut.pos = In.pos;
	vsOut.color = In.color; //カラーの情報を出力する。
	return vsOut;
}
</div></code></pre>
<p> では、ピクセルシェーダーを下記のリスト2.12のように書き換えて、ラスタライザで補完されたデータをピクセルカラーとして出力するようにしてください。図2.16のようになったら正解です。</br>
[リスト2.11 Sample.fx(21行目～)]</p>
<pre class="hljs"><code><div>//ピクセルシェーダー。
float4 PSMain( VSOutput vsOut ) : SV_Target0
{
	float4 color;
	color.x = vsOut.color.x;
	color.y = vsOut.color.y;
	color.z = vsOut.color.z;
	color.w = 1.0f;
	return color;
}
</div></code></pre>
<p><strong>図2.16</strong></br>
<img src="fig/2_16.png" width="400"></img></br></p>
<h3 id="257-%E3%81%BE%E3%81%A8%E3%82%81">2.5.7 まとめ</h3>
<ol>
<li>頂点シェーダーの後でラスタライザが実行され、塗りつぶすピクセルが決定する。</li>
<li>ラスタライザではピクセルシェーダーに渡すためのデータも計算される。</li>
<li>ピクセルシェーダーは塗りつぶすピクセルの数分だけ実行される。</li>
<li>ピクセルシェーダーには頂点シェーダーから出力されたデータを元に計算したデータが渡される。</li>
<li>ピクセルシェーダーから出力されるデータは光の３原色＋α。</li>
</ol>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h1 id="chapter-3-%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E5%85%A5%E9%96%80-%E3%81%9D%E3%81%AE%EF%BC%92">Chapter 3 シェーダー入門 その２</h1>
<lead>
&emsp;このチャプターではChapter２から引き続き、シェーダーの基礎的な部分を勉強していきます。Chapter２では触れなかった座標変換、CPUからGPUへのデータ転送、テクスチャマッピング、テクスチャサンプリングなどを学んでいきます。
</lead>
<h2 id="31-%E5%BA%A7%E6%A8%99%E5%A4%89%E6%8F%9B">3.1 座標変換</h2>
<p> Chapter1で頂点シェーダーの仕事は、「3Dモデルの頂点をスクリーン空間に座標変換することである」ということを学びました。そして、Chapter2で簡単な頂点シェーダーを書いてみました。しかしChapter2の頂点シェーダでは座標変換済みの頂点が設定されていたので、シェーダーで座標変換は行っていませんでした。しかし、3Dモデルのキャラクターを画面上で移動させるということは、そのモデルの頂点座標に対して座標変換を行うことになります。しかし、近年のゲームであれば、一つの3Dモデルで頂点数が10万を超えることも珍しくありません。これだけの数の頂点の座標変換をCPUで行うということは現実的ではなく、一般的に座標変換はGPUで行われます。</p>
<h3 id="311-%E8%A1%8C%E5%88%97%E3%81%A8%E3%83%99%E3%82%AF%E3%83%88%E3%83%AB%E3%81%AE%E4%B9%97%E7%AE%97">3.1.1 行列とベクトルの乗算</h3>
<p> 頂点の座標変換は行列とベクトルの乗算で計算されます。ベクトルに行列を乗算すると、別の空間にベクトルを変換することができます。ゲームでは大雑把に分類すると、スクリーンに絵を表示するために表3.1の行列が必要になります。</br></p>
<p><strong>表3.1</strong></p>
<table>
<thead>
<tr>
<th>名前</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ワールド行列</td>
<td>ワールド空間に変換するための行列</td>
</tr>
<tr>
<td>カメラ行列</td>
<td>カメラ空間に変換するための行列</td>
</tr>
<tr>
<td>透視投影行列</td>
<td>スクリーン空間に変換するための行列</td>
</tr>
</tbody>
</table>
<p>この３つの行列を頂点座標に乗算することで、３Ｄモデルをスクリーン空間に変換しているのです。変換の順番は、ワールド空間➡カメラ空間➡スクリーン空間です。これがそのまま乗算の順番になります。では、３つの座標変換を詳細に見ていきましょう。</p>
<h3 id="312-%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E8%A1%8C%E5%88%97">3.1.2 ワールド行列</h3>
<p> ワールド行列は、3Dモデルをモデル空間からワールド空間に変換するための行列です。モデル空間というのは3DSMAx、Maya、Blenderなどの3DCGを作成するためのソフトウェアの空間です。この空間から、ゲームのワールドの空間に変換するための行列がワールド行列です。モデル空間では、多くの3Dモデルは足元が原点になります。もちろん、中にはモデルの中心が原点のものもありますし、遠く離れた場所が原点のモデルもあります。</br></p>
<p><strong>図3.1 足元が原点</strong></br>
<img src="fig/足元が原点.png" width="400"></img></br></p>
<p><strong>図3.2 原点が離れている</strong></br>
<img src="fig/足元がお留守.png" width="400"></img></br></p>
<p> モデル空間はアーディストがどのように3Dモデルを作成するのか次第の空間になります。モデル空間では、3Dモデルの足元は原点になっているので、ゲームの世界を歩き回ることができません。そこで、キャラクターの座標、回転クォータニオン、拡大率などから作成されるワールド行列をモデルの頂点に乗算することで、ワールド空間に変換する必要があります。図3.3は3Dモデルがモデル空間にいる状態です。</p>
<p><strong>図3.3 モデル空間</strong></br>
<img src="fig/モデル空間.png" width="400"></img></br></p>
<p> モデル空間にいる3Dモデルの全ての頂点座標にワールド行列を乗算することで、図3.4のように3Dモデルはワールド空間に移動することができるようになります。</p>
<p><strong>図3.4 ワールド空間に変換</strong></br>
<img src="fig/ワールド空間に変換.png" width="400"></img></br></p>
<h3 id="313-%E3%82%AB%E3%83%A1%E3%83%A9%E8%A1%8C%E5%88%97">3.1.3 カメラ行列</h3>
<p> ワールド空間に変換することができたら、次はカメラ空間に変換します。カメラ空間はカメラを原点とする空間です。カメラ空間はカメラの場所を原点、カメラの横方向をＸ軸、上方向をＹ軸、前方向をＺ軸とする空間です。</br></p>
<p><strong>図3.5 カメラ空間に変換</strong></br>
<img src="fig/カメラ空間に変換.png" width="400"></img></br>
 3Dモデルをカメラ空間に変換するためには、3Dモデルの全ての頂点に対して、カメラ行列を乗算する必要があります。カメラ行列が乗算されると、3Dモデルの頂点はカメラを原点とした空間に変換されます。図3.3ですと、ワールド空間では(10,20,30)だった座標はカメラ空間では(0,0,30)になることを表しています。</p>
<h3 id="314-%E9%80%8F%E8%A6%96%E5%A4%89%E6%8F%9B%E8%A1%8C%E5%88%97">3.1.4 透視変換行列</h3>
<p> カメラ空間に変換することができたら、次はスクリーン空間に変換します。正確には正規化されたスクリーン空間ですが、今は気にしなくて構いません。スクリーン空間はスクリーンの中心を原点とする2次元空間です。ワールド空間とカメラ空間は3次元空間だったのですが、スクリーン空間は2次元空間になります。</p>
<h3 id="315-%E8%A1%8C%E5%88%97%E3%82%92%E4%BD%9C%E3%82%8B%E3%81%AE%E3%81%AFcpugpu%E3%81%A9%E3%81%A3%E3%81%A1">3.1.5 行列を作るのはCPU？GPU？どっち？</h3>
<p> ここまでの話で、行列と頂点座標の乗算を行って空間変換を行い、画面に絵を出していることが分かりました。そして、行列と頂点座標の乗算を行っているのがGPUであることも分かりました。では、そもそも行列を作るのはCPUとGPUのどちらでしょうか？答えはCPUになります。ワールド行列を作成するためのキャラクターの座標、回転、拡大率や、カメラ行列を作成するための視点の位置、注視点の位置などの情報はCPUがアクセスできるメインメモリに載っています。また、行列と頂点の乗算の回数と比べると、行列を作成するための計算回数はそこまで多くありません。表3.2は10000頂点のモデルを表示するための計算回数を表しています。</br></p>
<p><strong>表3.2</strong></br></p>
<table>
<thead>
<tr>
<th>処理の名前</th>
<th>計算回数</th>
<th>計算するプロセッサ</th>
</tr>
</thead>
<tbody>
<tr>
<td>ワールド行列の作成</td>
<td>1キャラにつき数回</td>
<td>CPU</td>
</tr>
<tr>
<td>カメラ行列の作成</td>
<td>1フレームにつき数回</td>
<td>CPU</td>
</tr>
<tr>
<td>透視投影行列の作成</td>
<td>1フレームにつき数回</td>
<td>CPU</td>
</tr>
<tr>
<td>頂点座標とワールド行列の乗算</td>
<td>1キャラにつき10000回以上</td>
<td>GPU</td>
</tr>
<tr>
<td>頂点座標とカメラ行列の乗算</td>
<td>1キャラにつき10000回以上</td>
<td>GPU</td>
</tr>
<tr>
<td>頂点座標とスクリーン行列の乗算</td>
<td>1キャラにつき10000回以上</td>
<td>GPU</td>
</tr>
</tbody>
</table>
<p>表3.2が示すように、行列の作成の計算量は数回となっており、それほど多くありません。また、これらの行列の作成はゲームロジックと密接に関連づいているため、CPU(C++)で計算されることがほとんどです。</p>
<h3 id="316-%E3%83%A1%E3%83%A2%E3%83%AA%E8%BB%A2%E9%80%81">3.1.6 メモリ転送</h3>
<p> さて、絵を表示するために必要な行列はCPU側で計算されることが分かりました。そして、GPU側でこの行列を利用して、頂点座標の変換を行っていました。しかし、CPUで計算されたデータは基本的にメインメモリに記憶されています。ですが、GPUがアクセスできるメモリはグラフィックメモリのみとなります。ここで、Chapter1で勉強したメモリ転送が必要になってくるのです。</p>
<h4 id="%E5%AE%9A%E6%95%B0%E3%83%90%E3%83%83%E3%83%95%E3%82%A1">定数バッファ</h4>
<p> DirectX12にはメインメモリからグラフィックメモリにデータを転送する仕組みとして定数バッファと呼ばれるものを用意しています。定数バッファはDirectX12のAPIを利用することで作成できます。メインメモリからグラフィックメモリへのデータのコピーもDirectX12のAPIを利用します。リスト3.1は定数バッファを利用する疑似コードです。</br></p>
<p>[リスト3.1 定数バッファを利用する疑似コード]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//GPUで使用する行列をまとめた構造体。</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MatrixData</span>{</span>
	Matrix worldMatrix;		<span class="hljs-comment">//ワールド行列</span>
	Matrix cameraMatrix;	<span class="hljs-comment">//カメラ行列</span>
	Matrix projMatrix;		<span class="hljs-comment">//透視変換行列</span>
};
<span class="hljs-comment">//メイン関数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	MatrixData matData;
	<span class="hljs-comment">//グラフィックメモリ上に定数バッファを作成。</span>
	ConstantBuffer cb;
	cb.Create( <span class="hljs-keyword">sizeof</span>( matData ) ); 

	<span class="hljs-comment">//ゲームループ。</span>
	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
		・
		・
		・
		<span class="hljs-comment">//ワールド行列、カメラ行列、透視変換行列を計算する。</span>
		matData.worldMatrix.MakeWorldMatrix( 
			charaPos, charaRot, charaScale );
		matData.viewMatrix.MakeViewMatrix( cameraPos, cameraTarget );
		matData.projMatrix.MakeProjMatrix( nearPlane, farPlane );

		<span class="hljs-comment">//計算した行列データをグラフィックメモリにコピー</span>
		cb.Copy( matData );
	}
}
</div></code></pre>
<h4 id="%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF%E3%83%92%E3%83%BC%E3%83%97">ディスクリプタヒープ</h4>
<p> 定数バッファは作成しただけではGPUで使用することはできません。頂点バッファやインデックスバッファと同じようにドローコールを行う前に使用する前に設定する必要があります。DirectX12では定数バッファやテクスチャ、ストラクチャバッファなどをまとめて設定するための「ディスクリプタヒープ」というものが用意されています。ディスクリプタヒープは料理を運ぶトレイのようなものです。</br></p>
<p><strong>図3.6</strong></br>
<img src="fig/ディスクリプタヒープ.png" width="600"></img></br></p>
<p> 図3.6のようにトレイにおかず(定数バッファ、テクスチャ、ストラクチャバッファー)を乗せるようなイメージです。
リスト3.2はディスクリプタヒープを利用して絵を描く疑似コードです。</br>
[リスト3.2 ディスクリプタヒープを利用する疑似コード]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//メイン関数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	MatrixData matData;
	<span class="hljs-comment">//グラフィックメモリ上に定数バッファを作成。</span>
	ConstantBuffer cb;
	cb.Create( <span class="hljs-keyword">sizeof</span>( matData ) );
	<span class="hljs-comment">//ディスクリプタヒープを作成。 </span>
	DescriptorHeap ds; 
	<span class="hljs-comment">//ディスクリプタヒープに定数バッファを登録する。</span>
	ds.RegistConstantBuffer( cb );
	<span class="hljs-comment">//ゲームループ。</span>
	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
		・
		・
		・
		<span class="hljs-comment">//ワールド行列、カメラ行列、透視変換行列を計算する。</span>
		matData.worldMatrix.MakeWorldMatrix( 
			charaPos, charaRot, charaScale );
		matData.viewMatrix.MakeViewMatrix( cameraPos, cameraTarget );
		matData.projMatrix.MakeProjMatrix( nearPlane, farPlane );
		<span class="hljs-comment">//計算した行列データをグラフィックメモリにコピー</span>
		cb.Copy( matData );
		・
		・
		・
		<span class="hljs-comment">//ディスクリプタヒープを設定してドロー。</span>
		SetDescriptorHeap( ds );
		Draw();
	}
}

</div></code></pre>
<h3 id="317-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E8%A1%8C%E5%88%97%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%81%A6%E4%B8%89%E8%A7%92%E5%BD%A2%E3%82%92%E5%8B%95%E3%81%8B%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">3.1.7 【ハンズオン】ワールド行列を作成して三角形を動かしてみよう</h3>
<p> では、Sample_03_01を改造して、三角形を動かかしてみましょう。Sample_03_01/Sample_03_01.slnをダブルクリックして、VisualStudioのプロジェクトを立ち上げてください。VisualStudioが立ち上がったらmain.cppを開いてください。</p>
<h4 id="step-1-%E5%AE%9A%E6%95%B0%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%82%92%E4%BD%9C%E6%88%90c">step-1 定数バッファを作成(C++)</h4>
<p> まずは、定数バッファを作成するプログラムを追加しましょう。リスト3.3のプログラムを入力してください。</br></p>
<p>[リスト3.3 main.cpp 29行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 定数バッファを作成。</span>
ConstantBuffer cb;
cb.Init( <span class="hljs-keyword">sizeof</span>( Matrix ) ); <span class="hljs-comment">//Init関数の引数は定数バッファのサイズ。</span>
</div></code></pre>
<h4 id="step-2-%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF%E3%83%92%E3%83%BC%E3%83%97%E3%82%92%E4%BD%9C%E6%88%90c">step-2 ディスクリプタヒープを作成(C++)</h4>
<p> 続いて、ディスクリプタヒープを作成するプログラムを追加します。リスト3.4のプログラムを入力してください。</br>
[リスト3.4 main.cpp 32行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-2 ディスクリプタヒープを作成。</span>
DescriptorHeap ds;
ds.RegistConstantBuffer( <span class="hljs-number">0</span>, cb ); <span class="hljs-comment">//ディスクリプタヒープに定数バッファを登録。</span>
ds.Commit();					  <span class="hljs-comment">//ディスクリプタヒープへの登録を確定。</span>
</div></code></pre>
<p>DescriptorHeapクラスはDirectX12のディスクリプタを簡単に扱えるように、著者の方で用意したクラスです。DescriptorHeap::RegistConstantbufferの第一引数はレジスタ番号です。入力アセンブラが定数バッファをレジスタに設定するときにこの情報を利用します。登録はDescriptorHeap::Commit関数を呼び出すことで確定します。必ず呼び出すことを忘れないようにしてください。</p>
<h4 id="step-3-%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E8%A1%8C%E5%88%97%E3%82%92%E4%BD%9C%E6%88%90c">step-3 ワールド行列を作成(C++)</h4>
<p> リスト3.5のプログラムを入力してください。ここでは、x方向に0.5、y方向に0.4移動するワールド行列を作成しています。</br>
[リスト3.5 main.cpp 54行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 ワールド行列を作成。</span>
Matrix mWorld;
mWorld.MakeTranslation(<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.4f</span>, <span class="hljs-number">0.0f</span>);
</div></code></pre>
<h4 id="step-4-%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E8%A1%8C%E5%88%97%E3%82%92%E3%82%B0%E3%83%A9%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AB%E3%82%B3%E3%83%94%E3%83%BCc">step-4 ワールド行列をグラフィックメモリにコピー(C++)</h4>
<p> ワールド行列が計算できたら、メインメモリからグラフィックメモリにコピーをしましょう。リスト3.5のプログラムを入力してください。</br>
[リスト3.5 main.cpp 57行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 ワールド行列をグラフィックメモリにコピー。</span>
cb.CopyToVRAM(mWorld);
</div></code></pre>
<h4 id="step-5-%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF%E3%83%92%E3%83%BC%E3%83%97%E3%82%92%E8%A8%AD%E5%AE%9Ac">step-5 ディスクリプタヒープを設定(C++)</h4>
<p> いよいよC++側の最後のプログラムです。ディスクリプタヒープを設定するプログラムを追加します。リスト3.6のプログラムを入力してください。</br>
[リスト3.6 main.cpp 60行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-5 ディスクリプタヒープを設定。</span>
renderContext.SetDescriptorHeap(ds);
</div></code></pre>
<h4 id="step-6-%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BFb0%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%A4%89%E6%95%B0%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8Bhlsl">step-6 レジスタb0のデータにアクセスするための変数を定義する(HLSL)</h4>
<p> 次はHLSL側のプログラムになります。Assets/shader/sample.fxを開いてください。まずはレジスタb0に設定されている定数バッファにアクセスするための変数を定義します。リスト3.7のプログラムを入力してください。</br></p>
<pre class="hljs"><code><div>//step-6 レジスタb0のデータにアクセスするための変数を定義する。
float4x4 g_worldMatrix : register( b0 );
</div></code></pre>
<h4 id="step-7-%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E8%A1%8C%E5%88%97%E3%81%A8%E5%BA%A7%E6%A8%99%E3%82%92%E4%B9%97%E7%AE%97%E3%81%97%E3%81%A6%E5%BA%A7%E6%A8%99%E5%A4%89%E6%8F%9B%E3%82%92%E8%A1%8C%E3%81%86hlsl">step-7 ワールド行列と座標を乗算して座標変換を行う(HLSL)</h4>
<p> いよいよこれで最後です。定数バッファに設定されたワールド行列を利用して、座標変換を行います。リスト3.8のプログラムを入力してください。</br></p>
<pre class="hljs"><code><div>//step-7 ワールド行列と座標を乗算して座標変換を行う。
//元のコードはコメントアウト vsOut.pos = In.pos;
vsOut.pos = mul( g_worldMatrix, In.pos );
</div></code></pre>
<p>ここまで完了したらF5キーを押してプログラムを実行してみてください。図3.7のように三角形が少し右上に表示されていれば成功です。</br>
<strong>図3.7</strong></br>
<img src="fig/3_7.png" width="600"></img></br></p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h2 id="32-%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0">3.2 テクスチャマッピング</h2>
<h3 id="321-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E4%B8%89%E8%A7%92%E5%BD%A2%E3%81%AB%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%82%92%E8%B2%BC%E3%82%8B">3.2.1 【ハンズオン】三角形にテクスチャを貼る。</h3>
<p> では、ハンズオンを通して、三角形にテクスチャを貼り付ける方法について見ていきましょう。Sample_03_02/Sample_03_02.slnを立ち上げて、step1～step4のプログラムを入力してください。</br></p>
<h4 id="step1-%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%82%92%E3%83%AD%E3%83%BC%E3%83%89c">step1 テクスチャをロード(C++)</h4>
<p>[リスト3.9 main.cpp 33行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 テクスチャをロード。</span>
Texture tex;
tex.InitFromDDSFile(<span class="hljs-string">L"Assets/image/sample_00.dds"</span>);
</div></code></pre>
<h4 id="step-2-%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%82%92%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF%E3%83%92%E3%83%BC%E3%83%97%E3%81%AB%E7%99%BB%E9%8C%B2c">step-2 テクスチャをディスクリプタヒープに登録(C++)</h4>
<p>[リスト3.10 main.cpp 40行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-2 テクスチャをディスクリプタヒープに登録。</span>
ds.RegistShaderResource(<span class="hljs-number">0</span>, tex);
</div></code></pre>
<h4 id="step-3-t0%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF%E3%81%AB%E8%A8%AD%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%A4%89%E6%95%B0%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8Bhlsl">step-3 t0レジスタに設定されているテクスチャにアクセスするための変数を追加する(HLSL)</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//t0レジスタに設定されているテクスチャにアクセスするための変数を追加する。</span>
Texture2D g_texture : <span class="hljs-keyword">register</span>( t0 );
</div></code></pre>
<h4 id="step-4-%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%82%AB%E3%83%A9%E3%83%BC%E3%82%92%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%97%E3%81%A6%E8%BF%94%E3%81%99">step-4 テクスチャカラーをサンプリングして返す。</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 テクスチャカラーをサンプリングして返す。</span>
float4 texColor = g_texture.Sample( g_sampler, vsOut.uv);
<span class="hljs-keyword">return</span> texColor;	
<span class="hljs-comment">//これはコメントアウト return float4( 1.0f, 0.0f, 0.0f, 1.0f);</span>
</div></code></pre>
<h3 id="322%E8%AA%B2%E9%A1%8C%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%82%92%E5%90%88%E6%88%90%E3%81%99%E3%82%8B">3.2.2【課題】テクスチャを合成する。</h3>
<p> 図3.8のように、二つのテクスチャを合成して三角形に貼りなさい。２枚目のテクスチャはAssets/image/sample_01.ddsを使用してください。</br>
<strong>図3.8</strong></br>
<img src="fig/3_8.png" width="600"></img></br></p>
<p>答え:Sample_03_02/Assets/shader/sample_3_2_2.fx、Sample_03_02/main_3_2_2.cpp</p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h1 id="chapter-4-%E3%83%A9%E3%82%A4%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E5%9F%BA%E7%A4%8E">Chapter 4 ライティング基礎</h1>
<h2 id="41-%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%88">4.1 ディレクションライト</h2>
<h2 id="42-%E6%8B%A1%E6%95%A3%E5%8F%8D%E5%B0%84">4.2 拡散反射</h2>
<h2 id="43-%E9%8F%A1%E9%9D%A2%E5%8F%8D%E5%B0%84">4.3 鏡面反射</h2>
<h2 id="44-%E3%82%A2%E3%83%B3%E3%83%93%E3%82%A8%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88">4.4 アンビエントライト</h2>
<h1 id="chapter-5-%E3%83%A9%E3%82%A4%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E7%99%BA%E5%B1%95">Chapter 5 ライティング発展</h1>
<h2 id="51-%E3%83%AA%E3%83%A0%E3%83%A9%E3%82%A4%E3%83%88">5.1 リムライト</h2>
<h2 id="52-%E5%8D%8A%E7%90%83%E3%83%A9%E3%82%A4%E3%83%88">5.2 半球ライト</h2>
<h2 id="53-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88">5.3 ポイントライト</h2>
<h2 id="54-%E3%82%B9%E3%83%9D%E3%83%83%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88">5.4 スポットライト</h2>
<h2 id="55-%E3%82%B9%E3%83%95%E3%82%A3%E3%82%A2%E3%83%9E%E3%83%83%E3%83%97%E3%83%99%E3%83%BC%E3%82%B9%E3%81%AEibl">5.5 スフィアマップベースのIBL</h2>
<h2 id="56-%E3%82%AD%E3%83%A5%E3%83%BC%E3%83%96%E3%83%9E%E3%83%83%E3%83%97%E3%83%99%E3%83%BC%E3%82%B9%E3%81%AEibl">5.6 キューブマップベースのIBL</h2>
<h2 id="57-pbrphysics-base-rendering">5.7 PBR(Physics Base Rendering)</h2>
<h3 id="pbr%E3%81%A8%E3%81%AF">PBRとは</h3>
<h3 id="%E7%94%9F%E3%81%BE%E3%82%8C%E3%81%9F%E8%83%8C%E6%99%AF">生まれた背景</h3>
<h4 id="%E5%90%B8%E5%8F%8E">吸収</h4>
<p> 光は物体に入射すると波長が吸収されます。そして、吸収されなかった波長が反射されます。この反射する波長をデータとして表したものがアルベドテクスチャとなります。</br>
 アルベドテクスチャは反射する光をRGBで表現したデータなので、一見するとこれまで扱ってきた普通のテクスチャのように感じるかもしれません。しかし、アルベドテクスチャと、これまで扱ってきたテクスチャは厳密にいうと異なります。レガシーシェーダーで扱われていたテクスチャは、陰影情報も描き込まれていることがありました。しかし、アルベドテクスチャには陰影やハイライトは不要です。あくまでもアルベドテクスチャは光が入射したときに反射する光の波長をRGBで描き込んだものなので、陰影やハイライトなどを描き込んではいけないのです。PBRにおいて、これらはシェーダーでリアルタイムに計算するものだからです。</p>
<h3 id="brdf">BRDF</h3>
<p> 入射輝度に応じて放出輝度を計算する関数群。色々なBRDFが考案されている。物理ベースのBRDFは「ヘルムホルツの相反性」と「エネルギー保存則」に従います。ヘルムホルツの相反性は入射光と射出光を入れ替えても反射率が変化しないという性質です。エネルギー保存則は反射光が入射光の量を超えないことです。今回のサンプルでは、拡散反射はディズニーベースのBRDF、鏡面反射ではクックトランスBRDFを採用しています。では、各BRDFについて詳しく見ていきましょう。</p>
<h4 id="%E3%83%87%E3%82%A3%E3%82%BA%E3%83%8B%E3%83%BC%E3%83%99%E3%83%BC%E3%82%B9%E6%8B%A1%E6%95%A3%E5%8F%8D%E5%B0%84">ディズニーベース拡散反射</h4>
<h4 id="%E3%83%95%E3%83%AC%E3%83%8D%E3%83%AB%E5%8F%8D%E5%B0%84">フレネル反射</h4>
<p> ディズニーベース拡散反射は非常にシンプルはBRDFモデルとなっており、既存のランバート拡散反射にフレネル反射の効果を加えただけのものとなっています。ディズニーベースで用いられているフレネル反射は逆光には対応しておらず、順光の光を趣味レーションしたものです。</p>
<h4 id="%E3%82%AF%E3%83%83%E3%82%AF%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B9%E9%8F%A1%E9%9D%A2%E5%8F%8D%E5%B0%84">クックトランス鏡面反射</h4>
<h4 id="%E6%95%A3%E4%B9%B1">散乱</h4>
<p> 光は物体に入射すると、そのまま綺麗に反射するわけではありません。例えば、物体に入射した一部の光が内部で錯乱を起こして入射箇所から離れた場所から反射してくる表面化錯乱。表面の凸凹(マイクロジオメトリー）による光の乱反射による錯乱。これらの錯乱がどのような効果を生み出すのかというと、ボケた反射をうみだします。今回のサンプルで扱っているのは、主に後者のマイクロジオメトリーでの錯乱です。</p>
<h4 id="%E5%B9%BE%E4%BD%95%E5%AD%A6%E7%9A%84%E6%B8%9B%E8%A1%B0">幾何学的減衰</h4>
<p> 表面の凸凹は光を乱反射するだけではなく、入射してくる光を遮断もします。幾何学的減衰では凸凹具合を元に、光の遮断率を計算します。</p>
<h4 id="%E3%83%95%E3%83%AC%E3%83%8D%E3%83%AB%E5%8F%8D%E5%B0%84">フレネル反射</h4>
<p> </p>
<h4 id=""></h4>
<h1 id="chapter-6-%E3%81%84%E3%82%8D%E3%81%84%E3%82%8D%E3%81%AA%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%82%92%E5%88%A9%E7%94%A8%E3%81%97%E3%81%9F%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC">Chapter 6 いろいろなテクスチャを利用したシェーダー</h1>
<h1 id="chapter-7-%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E7%99%BA%E5%B1%95">Chapter 7 レンダリングパイプライン発展</h1>
<h1 id="chapter-8-2d%E6%8F%8F%E7%94%BB%E3%81%AE%E5%9F%BA%E7%A4%8E">Chapter 8 2D描画の基礎</h1>
<h1 id="chapter-9-2d%E6%8F%8F%E7%94%BB%E7%99%BA%E5%B1%95">Chapter 9 2D描画発展</h1>
<h1 id="chapter-10-%E3%83%9D%E3%82%B9%E3%83%88%E3%82%A8%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88">Chapter 10 ポストエフェクト</h1>
<h1 id="chapter-11-%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6%E3%82%A4%E3%83%B3%E3%82%B0">Chapter 11 シャドウイング</h1>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h1 id="chapter-12-%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0">Chapter 12 ディファードレンダリング</h1>
<p> このチャプターでは現在主流になってきているディファードレンダリングについてみていきます。</p>
<h2 id="121-%E3%83%95%E3%82%A9%E3%83%AF%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0">12.1 フォワードレンダリング</h2>
<p> ディファードレンダリングを見ていく前に、まずは、3Dゲームの黎明期から進化してきたレンダリング手法のフォワードレンダリングについて見ていきましょう。フォワードレンダリングを端的に説明すると、**「ポリゴンをレンダリングする時にライティングの計算を行う」**というものです。モデルのDrawを行うと頂点シェーダー、ピクセルシェーダーが実行されてピクセルカラーが決まります。このタイミングでライティングを行うのがフォワードレンダリングです。これまで皆さんが実装してきたものは全てフォワードレンダリングとなります。</p>
<h2 id="122-%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0">12.2 ディファードレンダリング</h2>
<p> ディファードレンダリングはxbox360、PlayStation3のころに生まれたレンダリング手法で、比較的新しい手法となっています。特にPlayStation3はこの手法が向いているアーキテクチャだったため、ディファードレンダリングが採用されているゲームがいくつかありました。ディファードレンダリングを端的に説明すると「ポリゴンをレンダリングする時にはライティングの計算は行わずに後で行う。」というものです。Deferredは遅延という意味なので、遅延レンダリングとも呼ばれます。フォワード系に慣れ親しんでいるとピンと来ないかもしれません。ライティングの計算をポストエフェクト的に行うと言った方が理解しやすいかもしれませんね。</p>
<h3 id="1221-g-buffer">12.2.1 G-Buffer</h3>
<p> ではディファードレンダリングで使用されるG-Bufferについてみていきましょう。ディファードレンダリングではポリゴンをレンダリングする時にはライティングの計算は行わずにMRT(MultiRenderingTarget)を活用して、複数枚のテクスチャ(G-Bufferと呼ばれる)にテクスチャカラー、法線情報、スペキュラ強度、深度値などを書き込みます。図12.1はPlayStation3のKillzone2のG-Bufferの内容です</br></p>
<p><strong>図12.1</strong></br>
<img src="fig/G-Buffer.png" width="600"></img></br>
 フォワードレンダリングでは「モデルを描画する=ライティングを行ってレンダリングターゲットに書き込む」だったのですが、ディファードレンダリング「モデルを描画する=ライティングに必要な情報をG-Bufferに書き込む。」というものになります。そして、G-Bufferを使用してポストエフェクト的にライティングの計算を行って、最終画象をレンダリングターゲットに書き込みます。</p>
<h2 id="123-%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88">12.3 ディファードレンダリングのメリット</h2>
<p> なぜ、PlayStation3やXbox360のころからディファードレンダリングを採用しているゲームが増えてきたのでしょうか？当然増えてきたのには何か理由があります。この節ではその理由についてみていきましょう。
 PlayStation3、Xbox360が登場したことによって、家庭用ゲーム機の世界にもプログラマブルシェーダーの波が押し寄せました。映像を少しでもいいものに、ほかのゲームと違うグラフィック表現などなど、いろいろな工夫が凝らされるようになった結果、1ピクセル当たりの計算量がどんどん増えていきました。例えばPlayStation3が発売されたばかりのころの１ピクセルのプログラムは次のようなものだったと思ってください。</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">/*!
 *@brief	ピクセルシェーダー。
 */</span>
<span class="hljs-function">float4 <span class="hljs-title">PSMain</span><span class="hljs-params">( VS_OUTPUT In )</span> : COLOR
</span>{
	<span class="hljs-comment">//ライトを計算。</span>
	float4 lig = <span class="hljs-number">0.0f</span>;
	float3 normal = normalize(In.normal);
	lig.xyz = CalcDiffuse( In.normal );
	lig.xyz += CalcSpecular( In.worldPos, normal );	
	lig += g_ambientLight;
	float4 color = tex2D( g_diffuseTextureSampler, In.uv );
	color.xyz *= lig;
	<span class="hljs-keyword">return</span> color;
}
</div></code></pre>
<p>これが時とともにもっと良いものを求めていった結果複雑化していき、次のようなコードになっていきました。</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">/*!
 * @brief	ピクセルシェーダー。
 */</span>
<span class="hljs-function">PSOutput <span class="hljs-title">PSMain</span><span class="hljs-params">( VS_OUTPUT In )</span>
</span>{
	float4 color = <span class="hljs-number">0.0f</span>;
	float4 diffuseColor = tex2D(g_diffuseTextureSampler, In.Tex0);
	color = diffuseColor;
	float3 normal = normalize(In.Normal);
	<span class="hljs-keyword">if</span>(g_flags.x){
		<span class="hljs-comment">//法線マップあり。</span>
		float3 tangent = normalize(In.Tangent);
		float3 binSpaceNormal = tex2D( g_normalMapSampler, In.Tex0);
		float4x4 tangentSpaceMatrix;
		float3 biNormal = normalize( cross( tangent, normal) );
		tangentSpaceMatrix[<span class="hljs-number">0</span>] = float4( tangent, <span class="hljs-number">0.0f</span>);
		tangentSpaceMatrix[<span class="hljs-number">1</span>] = float4( biNormal, <span class="hljs-number">0.0f</span>);
		tangentSpaceMatrix[<span class="hljs-number">2</span>] = float4( normal, <span class="hljs-number">0.0f</span>);
		tangentSpaceMatrix[<span class="hljs-number">3</span>] = float4( <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span> );
		<span class="hljs-comment">//-1.0～1.0の範囲にマッピングする。</span>
		binSpaceNormal = (binSpaceNormal * <span class="hljs-number">2.0f</span>)- <span class="hljs-number">1.0f</span>;
		normal = tangentSpaceMatrix[<span class="hljs-number">0</span>] * binSpaceNormal.x + tangentSpaceMatrix[<span class="hljs-number">1</span>] * binSpaceNormal.y + tangentSpaceMatrix[<span class="hljs-number">2</span>] * binSpaceNormal.z; 
		
	}
	float4 lig = DiffuseLight(normal);
	<span class="hljs-keyword">if</span>(g_flags.z){
		<span class="hljs-comment">//リムライト。</span>
		lig.xyz += CalcLimLight(normal, g_light.limLightDir, g_light.limLightColor.xyz);
	}
	<span class="hljs-keyword">if</span>(g_flags.w){
		<span class="hljs-comment">//スペキュラライト。</span>
		lig.xyz += SpecLight(normal, In.worldPos_depth.xyz, In.Tex0);
	}
	<span class="hljs-keyword">if</span>(g_flags.y){
		<span class="hljs-comment">//影</span>
		lig *= CalcShadow(In.worldPos_depth.xyz);
	}
	<span class="hljs-comment">//自己発光色</span>
	lig.xyz += g_light.emission;
	color *= lig;
	<span class="hljs-comment">//大気錯乱</span>
	<span class="hljs-keyword">if</span>(g_flags2.y == AtomosphereFuncObjectFromAtomosphere)
	{
		color = In.rayColor + color * In.mieColor;
	}
	<span class="hljs-comment">//ポイントライト。</span>
	color.xyz += diffuseColor.xyz * PointLight(normal, In.worldPos_depth.xyz, g_flags.z);
	<span class="hljs-comment">//アンビエントライトを加算。</span>
	color.xyz += diffuseColor.xyz * g_light.ambient.xyz;	
	<span class="hljs-keyword">if</span>(g_fogParam.z &gt; <span class="hljs-number">1.9f</span>){
		<span class="hljs-comment">//高さフォグ</span>
		<span class="hljs-keyword">float</span> h = max(In.worldPos_depth.y - g_fogParam.y, <span class="hljs-number">0.0f</span>);
		<span class="hljs-keyword">float</span> t = min(h / g_fogParam.x, <span class="hljs-number">1.0f</span>);
		color.xyz = lerp(float3(<span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.95f</span>), color.xyz, t);
	}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g_fogParam.z &gt; <span class="hljs-number">0.0f</span>){
		<span class="hljs-comment">//距離フォグ</span>
		<span class="hljs-keyword">float</span> z = length(In.worldPos_depth.xyz - g_cameraPos);
		z = max(z - g_fogParam.x, <span class="hljs-number">0.0f</span>);
		<span class="hljs-keyword">float</span> t = min( z / g_fogParam.y, <span class="hljs-number">1.0f</span>);
		color.xyz = lerp(color.xyz, float3(<span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.95f</span>), t);
	}
	PSOutput psOut = (PSOutput)<span class="hljs-number">0</span>;
	psOut.color = color;
	psOut.depth = In.worldPos_depth.w;
	<span class="hljs-keyword">if</span>(g_flags2.x){
		psOut.velocity.xy = In.velocity.xy / In.velocity.w-In.screenPos.xy / In.screenPos.w;
		psOut.velocity.xy *= <span class="hljs-number">0.5f</span>;
		psOut.velocity.xy += <span class="hljs-number">0.5f</span>;
		psOut.velocity.zw = <span class="hljs-number">0.0f</span>;
	}<span class="hljs-keyword">else</span>{
		<span class="hljs-comment">//速度なし。</span>
		psOut.velocity = <span class="hljs-number">0.5f</span>;
	}
	<span class="hljs-keyword">return</span> psOut;
}
</div></code></pre>
<p> これが１ピクセルに実行されるプログラムです。これによりピクセル単位のプログラムの処理時間が増大していきました。そこで、無駄なピクセルのプログラムは実行しないようにできないか？という考えから生まれてきたのがディファードレンダリングです。フォワードレンダリングは先にライティングを行うため、不要なピクセルのライティングが計算されてしまいます。例えば図12.2のように3Dモデルを画面の奥から手前の順番でレンダリングした場合のことを考えてみてください。</br>
<strong>図12.2</strong></br>
<img src="fig/12_2.png" width="600"></img></br>
 この図は顔のモデルを描画した後で、その手前に三角形の板ポリを描画している図です。これがフォワードレンダリングで行われた場合、三角形の板ポリに遮蔽された部分のライティングの計算が無駄になってしまいます。一方、ディファードレンダリングでは、モデル描画のパスではライティング計算は行わずに、G-Bufferの内容を使って、ポストエフェクト的にライティングの計算を行うため、無駄な計算は発生しません。例えば1920×1080の解像度であれば、どんな順番でモデルを描画したとしても1920×1080回のライティングの計算で完了することになります。</p>
<h2 id="124-%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E3%83%87%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88">12.4 ディファードレンダリングのデメリット</h2>
<p> 先ほどはディファードレンダリングのメリットを見ていきましたが、すべてのケースでフォワードレンダリングより優れているわけではありません。ではディファードレンダリングのデメリットについてみていきましょう。</p>
<h3 id="1241-%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AE%E9%80%9F%E5%BA%A6%E3%81%A8%E5%AE%B9%E9%87%8F%E3%81%AE%E5%95%8F%E9%A1%8C">12.4.1 メモリの速度と容量の問題</h3>
<p> ディファード系ではMRT(multiRenderingTarget)を活用するため、フォワード系に比べるとメモリ使用量が増大します。また、モデルの描画パスで複数のG-Bufferに対して書き込みを行うため、メモリの書き込み速度も問題になってきます。CPUやGPUの演算速度とメモリの読み書きの速度の差はどんどん大きくなってきています。そのため、アーキテクチャによってはディファード系の方が遅くなるというのは十分考えられます。実はディファード系がPlayStation3では増えていたが、Xbox360では増えなかったのはこれが理由です。メモリの速度とVRAMの容量がxbox360はPlayStation3より劣っていたため、ディファードに向きでした。</p>
<h3 id="1242-%E5%8D%8A%E9%80%8F%E6%98%8E%E6%8F%8F%E7%94%BB%E3%81%AE%E5%95%8F%E9%A1%8C">12.4.2 半透明描画の問題</h3>
<p> ディファード系は半透明オブジェクトの描画に弱いため、半透明のオブジェクトを描画する場合、不透明オブジェクトをディファードで描画した後でフォワードで半透明オブジェクトを描画するなどといった工夫が必要になります。そのため、半透明オブジェクトを多用する日本のゲームには向いていないといわれていました。</br>
 このようにいいことばかりではなく、ディファードの方が遅くなるケースは実はたくさんあります。最近ですとVRゲームは4K解像度の絵を右目用と左目用の２枚レンダリングを行う必要があり、ディファードでレンダリングを行うと4K解像度の複数枚のG-Bufferへの書き込みが発生してメモリ帯域を圧迫します。</p>
<h2 id="125-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E5%85%A5%E9%96%80--%E6%8B%A1%E6%95%A3%E5%8F%8D%E5%B0%84">12.5 【ハンズオン】ディファードレンダリング入門 ～ 拡散反射 ～</h2>
<p> では、ハンズオンでディファードレンダリングを実装してみましょう。Sample_12_0を立ち上げてください。</p>
<h3 id="step-1-%E3%83%A2%E3%83%87%E3%83%AB%E3%82%92%E5%88%9D%E6%9C%9F%E5%8C%96">step-1 	モデルを初期化。</h3>
<p> まず、レンダリングを行うモデルを用意します。シェーダーにmodel.fxを指定していますが、このシェーダーではライティングの計算は行っていません。このシェーダーの目的はアルベドカラーと法線をG-bufferに出力することです。</br></p>
<p>[リスト 12.1 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 モデルを用意。</span>
ModelInitData modelInitData;
modelInitData.m_tkmFilePath = <span class="hljs-string">"Assets/modelData/unityChan.tkm"</span>;
modelInitData.m_fxFilePath = <span class="hljs-string">"Assets/shader/model.fx"</span>;
Model model;
model.Init(modelInitData);
</div></code></pre>
<h3 id="step-2-g-buffer%E3%82%92%E4%BD%9C%E6%88%90">step-2 G-Bufferを作成</h3>
<p> アルベドカラーと法線を出力するためのG-Bufferを作成します。</br>
[リスト 12.2 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-2 G-Bufferを作成。</span>
RenderTarget albedRT;	<span class="hljs-comment">//アルベドカラー書き込み用のレンダリングターゲット。</span>
albedRT.Create(
	FRAME_BUFFER_W, FRAME_BUFFER_H, 
	<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, 
	DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_FORMAT_D32_FLOAT);
RenderTarget normalRT;	<span class="hljs-comment">//法線書き込み用のレンダリングターゲット。</span>
normalRT.Create(
	FRAME_BUFFER_W, FRAME_BUFFER_H, 
	<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, DXGI_FORMAT_R8G8B8A8_UNORM, XGI_FORMAT_UNKNOWN);

</div></code></pre>
<h3 id="step-3-%E3%83%9D%E3%82%B9%E3%83%88%E3%82%A8%E3%83%95%E3%82%A7%E3%82%AF%E3%83%88%E7%9A%84%E3%81%AB%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%A9%E3%82%A4%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%92%E8%A1%8C%E3%81%86%E3%81%9F%E3%82%81%E3%81%AE%E3%82%B9%E3%83%97%E3%83%A9%E3%82%A4%E3%83%88%E3%82%92%E6%BA%96%E5%82%99">step-3 ポストエフェクト的にディファードライティングを行うためのスプライトを準備。</h3>
<p> 続いて、ポストエフェクト的にライティングを行うので、画面全体にレンダリングされるスプライトを準備します。ここで指定しているsprite.fxでライティングの計算が行われます。</p>
<p>[リスト 12.3 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 ポストエフェクト的にディファードライティングを行うためのスプライトを準備。</span>
SpriteInitData spriteInitData;
<span class="hljs-comment">//画面全体にレンダリングするので幅と高さはフレームバッファの幅と高さと同じ。</span>
spriteInitData.m_width = FRAME_BUFFER_W;
spriteInitData.m_height = FRAME_BUFFER_H;
<span class="hljs-comment">//使用するテクスチャはアルベドテクスチャと法線テクスチャ。</span>
spriteInitData.m_textures[<span class="hljs-number">0</span>] = &amp;albedRT.GetRenderTargetTexture();
spriteInitData.m_textures[<span class="hljs-number">1</span>] = &amp;normalRT.GetRenderTargetTexture();
spriteInitData.m_fxFilePath = <span class="hljs-string">"Assets/shader/sprite.fx"</span>;
spriteInitData.m_expandConstantBuffer = &amp;light;
spriteInitData.m_expandConstantBufferSize = <span class="hljs-keyword">sizeof</span>(light);
<span class="hljs-comment">//初期化データを使ってスプライトを作成。</span>
Sprite defferdLightinSpr;
defferdLightinSpr.Init(spriteInitData);
</div></code></pre>
<p> このスプライトの描画でモデルのドローで作成されるテクスチャが利用されます。</p>
<h3 id="step-4-%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%82%BF%E3%83%BC%E3%82%B2%E3%83%83%E3%83%88%E3%82%92g-buffer%E3%81%AB%E5%A4%89%E6%9B%B4%E3%81%97%E3%81%A6%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%82%80">step-4 レンダリングターゲットをG-Bufferに変更して書き込む。</h3>
<p> この箇所がフォワードレンダリングでのモデルのドローにあたる部分です。これまでここで直接フレームバッファ(画面)にレンダリングしていたのですが、ディファードではレンダリング先がG-Bufferになります。</br>
[リスト 12.4 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 レンダリングターゲットをG-Bufferに変更して書き込む。</span>
RenderTarget* rts[] = {
	&amp;albedRT,
	&amp;normalRT
};
<span class="hljs-comment">//まず、レンダリングターゲットとして設定できるようになるまで待つ。</span>
renderContext.WaitUntilToPossibleSetRenderTargets(<span class="hljs-number">2</span>, rts);
<span class="hljs-comment">//レンダリングターゲットを設定。</span>
renderContext.SetRenderTargets(<span class="hljs-number">2</span>, rts);
<span class="hljs-comment">//レンダリングターゲットをクリア。</span>
renderContext.ClearRenderTargetViews(<span class="hljs-number">2</span>, rts);
model.Draw(renderContext);

<span class="hljs-comment">//レンダリングターゲットへの書き込み待ち。</span>
renderContext.WaitUntilFinishDrawingToRenderTargets(<span class="hljs-number">2</span>, rts);
</div></code></pre>
<p> このモデルのドローで図12.1と図12.2の２枚のテクスチャ(G-Buffer)が作成されます。この2枚のテクスチャを使用してstep-5でライティングの計算が行われます。</br>
<strong>図12.1 アルベド</strong></br>
<img src="fig/12.1.png" width=320></img></p>
<p><strong>図12.2 法線</strong></br>
<img src="fig/12.2.png" width=320></img></br></p>
<h3 id="step-5-%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E5%85%88%E3%82%92%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%81%AB%E6%88%BB%E3%81%97%E3%81%A6%E3%82%B9%E3%83%97%E3%83%A9%E3%82%A4%E3%83%88%E3%82%92%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%99%E3%82%8B">step-5 レンダリング先をフレームバッファに戻してスプライトをレンダリングする</h3>
<p> G-Bufferの作成が終わったら、次はディファードライティングです。step-4で作成されたアルベドテクスチャと法線テクスチャを使ってライティングの計算が行われます。</br>
[リスト 12.5 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-5 レンダリング先をフレームバッファに戻してスプライトをレンダリングする</span>
g_graphicsEngine-&gt;ChangeRenderTargetToFrameBuffer(renderContext);
<span class="hljs-comment">//G-Bufferの内容を元にしてスプライトをレンダリング。</span>
defferdLightinSpr.Draw(renderContext);
</div></code></pre>
<p> このスプライトのドローで、step-4で作成されたテクスチャを使用して、ライティングの計算がおこなれます。</br>
<strong>図12.3 ディファードライティング</strong></br>
<img src="fig/12.3.png"></img></br></p>
<h3 id="step-6-g-buffer%E3%81%AB%E5%87%BA%E5%8A%9B">step-6 G-Bufferに出力。</h3>
<p> 続いて、シェーダー側のmodel.fxです。モデルシェーダーではライティングの計算のような複雑な計算は行われておらず、アルベドと法線をレンダリングターゲットに出力しているだけのシンプルなプログラムになっています。</br>
[リスト 12.6 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-6 G-Bufferに出力。</span>
SPSOut psOut;
<span class="hljs-comment">//アルベドカラーを出力。</span>
psOut.albedo = g_texture.Sample(g_sampler, psIn.uv);
<span class="hljs-comment">//法線を出力。</span>
<span class="hljs-comment">//出力は0～1に丸められてしまうのでマイナスの値が失われてしまう。</span>
<span class="hljs-comment">//なので-1～1を0～1に変換する。</span>
<span class="hljs-comment">//(-1 ～ 1) ÷ 2.0       = ( -0.5 ～ 0.5 )</span>
<span class="hljs-comment">//( -0.5 ～ 0.5) + 0.5  = (  0.0 ～ 1.0 )</span>
psOut.normal = ( psIn.normal / <span class="hljs-number">2.0f</span> ) + <span class="hljs-number">0.5f</span>;
<span class="hljs-keyword">return</span> psOut;
</div></code></pre>
<h3 id="step-7-g-buffer%E3%81%AE%E5%86%85%E5%AE%B9%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%83%A9%E3%82%A4%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0">step-7 G-Bufferの内容を使ってライティング。</h3>
<p> いよいよ最後です。sprite.fxでは作成されたG-Bufferの情報を元にライティングの計算を行います。ライティングの計算自体はフォワードレンダリングで行っているものと違いはありません。</br>
[リスト 12.6 sprite.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-7 G-Bufferの内容を使ってライティング。</span>
float4 albedo = albedoTexture.Sample(Sampler, In.uv);
float3 normal = normalTexture.Sample(Sampler, In.uv).xyz;
normal = (normal * <span class="hljs-number">2.0f</span>)<span class="hljs-number">-1.0f</span>;
<span class="hljs-comment">//ライトを計算。</span>
float3 lig = <span class="hljs-number">0.0f</span>;
<span class="hljs-keyword">float</span> t = max( <span class="hljs-number">0.0f</span>, dot( normal, ligDirection) * <span class="hljs-number">-1.0f</span>);
lig = ligColor * t;
float4 finalColor = albedo;
finalColor.xyz *= lig;
<span class="hljs-keyword">return</span> finalColor;
</div></code></pre>
<p> 今回のハンズオンではライティングの計算もシンプルだったので、余り恩恵は受けませんが、この後のチャプターで勉強する物理ベースライティングでは、１ピクセル辺りのライティングの計算が更にヘビーになります。そのような重いシェーダーになってきたときはディファードレンダリングの恩恵が大きくなっていきます。</p>
<h2 id="126-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E5%85%A5%E9%96%80--%E9%8F%A1%E9%9D%A2%E5%8F%8D%E5%B0%84">12.6 【ハンズオン】ディファードレンダリング入門 ～ 鏡面反射 ～</h2>
<p> 続いてディファードレンダリングで鏡面反射を実装してみましょう。このハンズオンは12.5のハンズオンの続きになります。鏡面反射ではピクセルのワールド座標のデータが必要になるため、G-Bufferが１枚追加されます。図12.4が今回のハンズオンで作成されるG-Bufferです。</br>
<strong>図12.4</strong>
<img src="fig/スペキュラ反射のG-Buffer.png"></img></br></p>
<p> では、ハンズオンを行っていきましょう。12.5の内容を全て実装しているサンプルプログラムがあるので、そちらを利用します。Sample_12_1を立ち上げて下さい。</p>
<h3 id="step-1-%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E6%83%85%E5%A0%B1%E3%81%AB%E8%A6%96%E7%82%B9%E3%82%92%E8%BF%BD%E5%8A%A0">step-1　ライトの情報に視点を追加</h3>
<p> 今回実装する鏡面反射は[ほげほげ(章番号を入れる)]で勉強したフォン鏡面反射です。フォン鏡面反射の計算には視点の位置が必要になるので、ライティングの情報に視点のデータを追加します。main.cppにリスト12.7のプログラムを入力してください。</br>
[リスト12.7 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 ライトの情報に視点を追加</span>
light.eyePos = g_camera3D-&gt;GetPosition();
</div></code></pre>
<h3 id="step-2-%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%81%AE%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E5%BA%A7%E6%A8%99%E3%82%92%E8%A8%98%E6%86%B6%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEg-buffer%E3%82%92%E4%BD%9C%E6%88%90">step-2　ピクセルのワールド座標を記憶するためのG-Bufferを作成</h3>
<p> 鏡面反射の計算では、ピクセルから視点まで伸びるベクトルを計算する必要があります。その計算のためにワールド座標を記憶するためのG-Bufferを作成しましょう。リスト12.8のプログラムを入力してください。</br>
[リスト12.8 main.cpp]</p>
<pre class="hljs"><code><div>RenderTarget worldPosRT;
worldPosRT.Create(
	FRAME_BUFFER_W, 
	FRAME_BUFFER_H, 
	<span class="hljs-number">1</span>, 
	<span class="hljs-number">1</span>, 
	DXGI_FORMAT_R32G32B32A32_FLOAT,		<span class="hljs-comment">//ワールド座標を記録するので、32ビット浮動小数点バッファを利用する。</span>
	DXGI_FORMAT_UNKNOWN
);
</div></code></pre>
<p> ワールド座標はアルベドカラーや法線と違い、大きな数値になるため8ビットのバッファでは精度が足りません。ですので、32ビットの浮動小数点バッファを作成しています。</p>
<h3 id="step-3-%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%A9%E3%82%A4%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%81%AB%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E5%BA%A7%E6%A8%99%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%82%92%E8%BF%BD%E5%8A%A0">step-3　ディファードライティングで使用するテクスチャにワールド座標テクスチャを追加。</h3>
<p> ディファードライティングで先ほど作成したワールド座標のテクスチャを利用するため、spriteInitData.m_textureに追加します。リスト12.9のプログラムを入力して下さい。</br>
[リスト12.9 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 ディファードライティングで使用するテクスチャにワールド座標テクスチャを追加。</span>
spriteInitData.m_textures[<span class="hljs-number">2</span>] = &amp;worldPosRT.GetRenderTargetTexture();
</div></code></pre>
<h3 id="step-4-2%E7%95%AA%E7%9B%AE%E3%81%AE%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%82%BF%E3%83%BC%E3%82%B2%E3%83%83%E3%83%88%E3%81%ABworldposrt%E3%82%92%E8%BF%BD%E5%8A%A0">step-4　2番目のレンダリングターゲットにworldPosRTを追加</h3>
<p> step-3までで初期化のプログラムは終了です。続いて、ドローコールを改造します。レンダリングするG-Bufferの種類が増えたので、RenderToGBufferで設定するレンダリングターゲットを増やします。リスト12.10のプログラムを入力してください。</br>
[リスト12.10 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 2番目のレンダリングターゲットにworldPosRTを追加。</span>
RenderTarget* rts[] = {
	&amp;albedRT,	<span class="hljs-comment">//0番目のレンダリングターゲット</span>
	&amp;normalRT,	<span class="hljs-comment">//1番目のレンダリングターゲット</span>
	&amp;worldPosRT	<span class="hljs-comment">//2番目のレンダリングターゲット</span>
};
</div></code></pre>
<p> これでC++側のプログラムは終了です。では、続いてHLSL側のプログラムを実装していきましょう。</p>
<h3 id="step-5-%E9%A0%82%E7%82%B9%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%8B%E3%82%89%E3%81%AE%E5%87%BA%E5%8A%9B%E3%81%AB%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E5%BA%A7%E6%A8%99%E3%82%92%E8%BF%BD%E5%8A%A0">step-5　頂点シェーダーからの出力にワールド座標を追加。</h3>
<p> まずは、RenderToGBufferのシェーダーを改造します。G-Bufferにピクセルのワールド座標を描きこむので、頂点シェーダーで計算されたワールド座標をピクセルシェーダーに渡す必要があります。頂点シェーダーからの出力構造体にワールド座標を出力するためのメンバを追加しましょう。model.fxを開いて、リスト12.11のプログラムを入力してください。</br>
[リスト12.11 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-5 頂点シェーダーからの出力にワールド座標を追加。</span>
float3 worldPos		: TEXCOORD1;	<span class="hljs-comment">//ワールド座標。</span>
</div></code></pre>
<h3 id="step-6-%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%8B%E3%82%89%E3%81%AE%E5%87%BA%E5%8A%9B%E3%81%AB%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E5%BA%A7%E6%A8%99%E3%82%92%E8%BF%BD%E5%8A%A0">step-6　ピクセルシェーダーからの出力にワールド座標を追加。</h3>
<p> 続いて、ピクセルシェーダーからの出力構造体を改造します。ピクセルシェーダーからレンダリングターゲット２番目にワールド座標を出力する必要があるので、SV_Target2セマンティクスが指定されたメンバを追加しています。model.fxにリスト12.12のプログラムを入力してください。</br>
[リスト12.12 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step 6 ピクセルシェーダーからの出力にワールド座標を追加。</span>
float3 worldPos : SV_Target2;	<span class="hljs-comment">//ワールド座標。</span>
</div></code></pre>
<p> このシェーダーが実行されると、図12.5のワールド座標のG-Bufferが作成されます。</br>
<strong>図12.5</strong></br>
<img src="fig/ワールド座標テクスチャ.png" width=320></img></p>
<h3 id="step-7-%E9%A0%82%E7%82%B9%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%8B%E3%82%89%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E5%BA%A7%E6%A8%99%E3%82%92%E5%87%BA%E5%8A%9B">step-7　頂点シェーダーからワールド座標を出力</h3>
<p> では、プログラムの本体の改造をしていきましょう。まずは頂点シェーダーからワールド座標を出力できるようにしていきましょう。リスト12.13のプログラムを入力してください。
[リスト12.13 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-7 頂点シェーダーからワールド座標を出力。</span>
psIn.worldPos = psIn.pos;
</div></code></pre>
<h3 id="step-8-%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%8B%E3%82%89%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E5%BA%A7%E6%A8%99%E3%82%92%E5%87%BA%E5%8A%9B">step-8　ピクセルシェーダーからワールド座標を出力</h3>
<p> 続いて、ピクセルシェーダーを改造しましょう。ピクセルシェーダーの仕事は頂点シェーダー→ラスタライザで計算されたピクセルのワールド座標をG-Bufferに出力するだけです。リスト12.14のプログラムを入力してください。</br>
[リスト12.14 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-8 ピクセルシェーダーからワールド座標を出力。</span>
psOut.worldPos = psIn.worldPos;
</div></code></pre>
<h3 id="step-9-%E5%AE%9A%E6%95%B0%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%81%AB%E8%A6%96%E7%82%B9%E3%81%AE%E4%BD%8D%E7%BD%AE%E3%82%92%E8%BF%BD%E5%8A%A0">step-9　定数バッファに視点の位置を追加</h3>
<p> 次はディファードライティングのシェーダーを改造します。鏡面反射を実装するので、定数バッファに視点の位置を追加しましょう。sprite.fxを開いてリスト12.15のプログラムを入力してください。</br>
[リスト12.15 sprite.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-9 定数バッファに視点の位置を追加。</span>
float3 eyePos;			<span class="hljs-comment">//視点</span>
</div></code></pre>
<h3 id="step-10-%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E5%BA%A7%E6%A8%99%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%A4%89%E6%95%B0%E3%82%92%E8%BF%BD%E5%8A%A0">step-10　ワールド座標テクスチャにアクセスするための変数を追加</h3>
<p> RenderToGBufferのパスで作成されたワールド座標テクスチャを利用するので、テクスチャにアクセスするための変数を追加します。ワールド座標テクスチャはcpp側のSprite::Drawの中でt2レジスタに関連付けされています。リスト12.16のプログラムを入力してください。</br>
[リスト12.16 sprite.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-10 ワールド座標テクスチャにアクセスするための変数を追加</span>
Texture2D&lt;float4&gt; worldPosTexture : <span class="hljs-keyword">register</span>(t2);	<span class="hljs-comment">//ワールド座標。</span>
</div></code></pre>
<h3 id="step-11-%E3%82%B9%E3%83%9A%E3%82%AD%E3%83%A5%E3%83%A9%E5%8F%8D%E5%B0%84%E3%82%92%E8%A8%88%E7%AE%97">step-11　スペキュラ反射を計算</h3>
<p> では、最後にスペキュラ反射を計算するプロググラムを追加しましょう。スペキュラ反射は[Chpaterほげほげ]で解説したプログラムと同じです。リスト12.17のプログラムを入力して下さい。</br>
[リスト12.17 sprite.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-11 スペキュラ反射を計算。</span>
float3 worldPos = worldPosTexture.Sample( Sampler, In.uv).xyz;
float3 toEye = normalize( eyePos - worldPos );
float3 r = reflect( ligDirection, normal);
t = max( <span class="hljs-number">0.0f</span>, dot( toEye, r));
t = <span class="hljs-built_in">pow</span>( t, <span class="hljs-number">5.0f</span>);
lig += ligColor * t;
</div></code></pre>
<h3 id="step-12-%E5%8B%95%E4%BD%9C%E7%A2%BA%E8%AA%8D">step-12　動作確認</h3>
<p> ここまで入力できたら実行して動作を確認してください。うまくできていれば、図12.6のようにスペキュラ反射が発生しているはずです。</br>
<strong>図12.6</strong></br>
<img src="fig/12.4.png" width=400></img></br></p>
<h2 id="128-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E5%85%A5%E9%96%80%E6%B3%95%E7%B7%9A%E3%83%9E%E3%83%83%E3%83%97">12.8 【ハンズオン】ディファードレンダリング入門～法線マップ～</h2>
<h2 id="129-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E5%85%A5%E9%96%80%E3%82%B9%E3%83%9A%E3%82%AD%E3%83%A5%E3%83%A9%E3%83%9E%E3%83%83%E3%83%97">12.9 【ハンズオン】ディファードレンダリング入門～スペキュラマップ～</h2>
<h2 id="127-%E5%8D%8A%E9%80%8F%E6%98%8E%E6%8F%8F%E7%94%BB">12.7 半透明描画</h2>
<p> ディファードレンダリングは半透明描画が弱いと言われています。では、なぜディファードレンダリングは半透明描画が弱いのか考えていきましょう。結論を先に説明すると、半透明のオブジェクトを描画すると、G-Bufferの内容が上書きされてしまうからです。G-Bufferは手前に描画されたピクセルの情報で上書きされてしまうため、奥のピクセルの情報は失われます。不透明の</p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h1 id="chapter-13-%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%A8%E3%83%95%E3%82%A9%E3%83%AF%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E8%9E%8D%E5%90%88">Chapter 13 ディファードレンダリングとフォワードレンダリングの融合</h1>
<p> 現在主流になっているレンダリングエンジンはディファードオンリー、フォワードオンリーというわけではなく、ディファードとフォワードを融合したものとなっています。ディファードレンダリングは無駄なピクセルのシェーダーが実行されないというメリットがあります。現在のリッチゲームは1ピクセル当たりのシェーダーが複雑になってきており、無駄な計算が発生しないディファードレンダリングがメインストリームになっています。しかし、ディファードレンダリングにはいくつかの欠点があります。その欠点を解消するために、ディファードとフォワードのハイブリッド仕様のレンダリングエンジンを作成するケースが増えていっています。では、ディファードの欠点を詳しくみていって、それに対処できるハイブリッド式のエンジンをハンズオンで作成していきましょう。</p>
<h2 id="131-%E5%8D%8A%E9%80%8F%E6%98%8E%E5%95%8F%E9%A1%8C">13.1 半透明問題</h2>
<p> ディファードレンダリングは半透明描画が弱いと言われています。では、なぜディファードレンダリングは半透明描画が弱いのか考えていきましょう。結論を先に説明すると、半透明のオブジェクトを描画すると、G-Bufferの内容が上書きされてしまうからです。G-Bufferは手前に描画されたピクセルの情報で上書きされてしまうため、奥のピクセルの情報は失われます。不透明のオブジェクトであれば、上書きされてしまっても問題ないのですが、半透明のオブジェクトが描画された時に、ピクセルの情報を上書きしてしまうのは問題です。なぜなら、半透明オブジェクトは透過しているので、奥のオブジェクトはまだ画面に表示されているからです。具体例を見てみましょう。図13.1は女の子のモデルと半透明の板ポリを描画している様子です。</br>
<strong>図13.1</strong></br>
<img src="fig/ディファードレンダリング半透明問題_1.png" width=600></img></br>
 女の子のモデルはランバート拡散反射の計算で陰影がついていることが分かります。さて、では女の子の手前に半透明の板ポリを移動するとどうなるでしょうか。図13.2を見てください。</br></p>
<p><strong>図13.2</strong></br>
<img src="fig/ディファードレンダリング半透明問題_2.png" width=400></img></br>
 女の子から陰影がなくなってしまいました。これは手前に描画された板ポリによって、G-Bufferの法線情報が上書きされてしまったことによって起きた現象です。図13.3はG-Bufferの変化です。</br></p>
<p><strong>図13.3</strong></br>
<img src="fig/半透明描画の法線上書きの問題.png" width=400></img></br>
 この問題は法線だけではなく、スペキュラ強度、深度値など多くのG-Bufferで発生します。半透明のオブジェクトを描画する場合、奥のオブジェクトも表示されているため、きちんと陰影を計算してやる必要があります。しかし、シンプルなディファードレンダリングの場合、奥のオブジェクトの情報は失われてしまうため、正しい陰影計算を行うことができません。これがディファードレンダリングで半透明描画が難しい理由です(今回紹介した半透明描画に関する問題をサンプルプログラム、Sample13_01で確認することができます。興味がある方は実行して動作を確認してみてください)。
 この半透明に起因する問題を解決する最も簡単な方法は、不透明オブジェクトはディファード、半透明オブジェクトはフォワードでレンダリングすることです。下記はフォワードとディファードを融合させたエンジンの１フレームの描画の流れです。</br></p>
<ol>
<li>
<p>不透明オブジェクトをG-Bufferにレンダリング</br>
<img src="fig/半透明問題解決版_G_BUffer.png"></img></br></p>
</li>
<li>
<p>G-Bufferの内容を使ってディファードライティング</br>
<img src="fig/半透明問題解決版_ディファードライティング.png" width=400></img></br></p>
</li>
<li>
<p>半透明オブジェクトをフォワードでレンダリング</br>
<img src="fig/半透明問題解決版_フォワードレンダリング.png" width=400></img></br></p>
</li>
</ol>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h2 id="132-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%81%A8%E3%83%95%E3%82%A9%E3%83%AF%E3%83%BC%E3%83%89%E3%81%AE%E3%83%8F%E3%82%A4%E3%83%96%E3%83%AA%E3%83%83%E3%83%89%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%B3%E3%81%AE%E5%AE%9F%E8%A3%85">13.2 【ハンズオン】ディファードとフォワードのハイブリッドエンジンの実装</h2>
<p> では、半透明問題の解決のためにディファードとフォワードのハイブリッドエンジンを実装してきましょう。今回使用するサンプルプログラムのSample_13_02は不透明オブジェクトのみディファードでレンダリングしているサンプルです。このサンプルを改造して半透明オブジェクトをレンダリングしても、正しいライティングの結果を得られるようにしていきましょう。</br></p>
<h3 id="step-1-%E5%8D%8A%E9%80%8F%E6%98%8E%E3%81%AE%E7%90%83%E4%BD%93%E3%83%A2%E3%83%87%E3%83%AB%E3%82%92%E5%88%9D%E6%9C%9F%E5%8C%96">step-1 半透明の球体モデルを初期化</h3>
<p> まずは、半透明オブジェクトの球体モデルを初期化しましょう。半透明オブジェクトの描画で使用されるピクセルシェーダーは不透明オブジェクトのものとは別のシェーダーです。不透明オブジェクトのピクセルシェーダーはG-Bufferに出力しますが、半透明オブジェクトのピクセルシェーダーはライティングの計算を行います。リスト13.1のプログラムをmain.cppに入力してください。</br>
[リスト13.1 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 半透明の球体モデルを初期化。</span>
ModelInitData transModelInitData;
transModelInitData.m_tkmFilePath = <span class="hljs-string">"Assets/modelData/sphere.tkm"</span>;
transModelInitData.m_fxFilePath = <span class="hljs-string">"Assets/shader/model.fx"</span>;
<span class="hljs-comment">//半透明モデルはモデルを描くときにライティングを行うので、ライトの情報を渡す。</span>
transModelInitData.m_expandConstantBuffer = &amp;light;
transModelInitData.m_expandConstantBufferSize = <span class="hljs-keyword">sizeof</span>(light);
<span class="hljs-comment">//ピクセルシェーダのエントリーポイントが不透明モデルとは異なる。</span>
<span class="hljs-comment">//不透明モデルはPSMain、半透明モデルはPSMainTransを使用する。</span>
<span class="hljs-comment">//ピクセルシェーダの実装は後で確認。</span>
transModelInitData.m_psEntryPointFunc = <span class="hljs-string">"PSMainTrans"</span>;
<span class="hljs-comment">//半透明の球体モデルを初期化。</span>
Model sphereModel;
sphereModel.Init(transModelInitData);
</div></code></pre>
<h3 id="step-2-%E5%8D%8A%E9%80%8F%E6%98%8E%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E6%8F%8F%E7%94%BB">step-2 半透明オブジェクトを描画</h3>
<p> 続いて、半透明オブジェクトを描画します。半透明オブジェクトの描画がディファードライティングの後で行われている点に注目してください。また、半透明オブジェクトを描画する際の深度ステンシルビューはG-Bufferを作成したときに作られた深度ステンシルビューを使用しています。このようにすることで、ディファードライティングが終わった後で、オブジェクトをレンダリングしても、正しい前後関係が得られます。リスト13.2のプログラムを入力してください。</br>
[リスト13.2 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-2 半透明オブジェクトを描画</span>
<span class="hljs-comment">//深度ステンシルビューはG-Bufferを作成したときのものに変更する。</span>
renderContext.SetRenderTarget(
	g_graphicsEngine-&gt;GetCurrentFrameBuffuerRTV(), 
	rts[<span class="hljs-number">0</span>]-&gt;GetDSVCpuDescriptorHandle()
);
<span class="hljs-comment">//半透明オブジェクトを描画！</span>
sphereModel.Draw(renderContext);
</div></code></pre>
<h3 id="step-3-%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E6%83%85%E5%A0%B1%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%AE%9A%E6%95%B0%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%82%92%E8%BF%BD%E5%8A%A0">step-3 ライトの情報を受け取るための定数バッファを追加</h3>
<p> step-3はシェーダー側のプログラムです。半透明オブジェクトをレンダリングするためのシェーダーを追加しましょう。まずはライティングを行うためにライトの情報にアクセスするための定数バッファを追加しましょう。Assets/shader/model.fxを開いてリスト13.3のプログラムを入力してください。</br>
[リスト13.3 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 ライトの情報を受け取るための定数バッファを追加。</span>
cbuffer DirectionLight : <span class="hljs-keyword">register</span>(b1){
	float3 ligColor;		<span class="hljs-comment">//ライトのカラー</span>
	float3 ligDirection;	<span class="hljs-comment">//ライトの方向。</span>
	float3 eyePos;			<span class="hljs-comment">//視点</span>
};
</div></code></pre>
<h3 id="step-4-%E5%8D%8A%E9%80%8F%E6%98%8E%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E7%94%A8%E3%81%AE%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%82%92%E5%AE%9F%E8%A3%85">step-4 半透明オブジェクト用のピクセルシェーダーを実装</h3>
<p> これで最後のハンズオンです。半透明オブジェクトのためのピクセルシェーダーの本体を実装しましょう。内容はこれまでに勉強してきたフォワードレンダリングです。リスト13.4のプログラムを入力してください。</br>
[リスト13.4 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 半透明オブジェクト用のピクセルシェーダーを実装。</span>
<span class="hljs-function">float4 <span class="hljs-title">PSMainTrans</span><span class="hljs-params">( SPSIn psIn )</span> : SV_Target0
</span>{
	<span class="hljs-comment">//フォワードレンダリング。</span>
	<span class="hljs-comment">//普通にライティングをする。</span>
	<span class="hljs-comment">//拡散反射光を計算。</span>
	float3 lig = <span class="hljs-number">0.0f</span>;
	float3 normal = psIn.normal;
	<span class="hljs-keyword">float</span> t = max( <span class="hljs-number">0.0f</span>, dot( psIn.normal, ligDirection) * <span class="hljs-number">-1.0f</span>);
	lig = ligColor * t;
	
	float4 finalColor = g_texture.Sample(g_sampler, psIn.uv);
	finalColor.xyz *= lig;
	<span class="hljs-keyword">return</span> finalColor;
}
</div></code></pre>
<h3 id="step-5-%E5%8B%95%E4%BD%9C%E7%A2%BA%E8%AA%8D">step-5 動作確認</h3>
<p> ここまで入力できたら実行して動作を確認してください。うまくできていれば、図13.4のように半透明の球体モデルを描画できているはずです。</br>
<strong>図13.4</strong></br>
<img src="fig/13.4.png" width=400></img></br></p>
<h2 id="132-%E7%89%B9%E6%AE%8A%E3%81%AA%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%8C%E5%9B%B0%E9%9B%A3">13.2 特殊なシェーディングが困難</h2>
<p> ディファードレンダリングは全てピクセルに対して、同じ陰影計算が行われます。そのため、特定のマテリアルだけ計算を変更したいということが難しくなります。かみ砕いて説明すると、リアルなグラフィックの世界にアニメ調のキャラクターを登場させることが困難になります。</p>
<h1 id="chapter-14-3d%E3%82%B2%E3%83%BC%E3%83%A0%E3%81%A7%E4%BD%BF%E3%81%88%E3%82%8B%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E7%99%BA%E5%B1%95">Chapter 14 3Dゲームで使えるシェーダー発展</h1>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h1 id="chapter-15-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%88%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC">Chapter 15 コンピュートシェーダー</h1>
<h2 id="151-gpgpu">15.1 GPGPU</h2>
<p> GPGPUとはGeneral-purpose computing on graphics processing unitsの略でGPUに汎用計算を行わせることを指しています。汎用計算とは画像処理以外の処理のことを指します。例えばコリジョン処理など。本来GPUは画像処理を行うために進化してきましたが、プログラマブルシェーダーの登場により、GPUでそれなりに複雑なロジックを実行することができるようになりました。また、CPUはGPUとは異なる進化を遂げてきたため、単純な計算であればCPUとは比べ物にならない速度で処理することができます。そのため、GPUに画像処理だけさせるのは勿体ない、もっと色々な処理をGPUに実行させよう！という考えが生まれます。これがGPGPUの始まりです。近年では仮想通貨のマイニングにGPUが使われたり、AIを飛躍的に進化させた機械学習という大量のデータを扱うアルゴリズムを高速に実行するためにGPUが使われたりしていました(ただし、最近は機械学習に特化したプロセッサをgoogleやMicrosoftが独自に開発したため、GPUが使われることは減っています)。</p>
<h2 id="152-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%88%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC">15.2 コンピュートシェーダー</h2>
<p> さて、ではどのようにGPUで汎用的な計算を行うのでしょうか？これまで皆さんが勉強してきたのは、頂点処理を行うための頂点シェーダーと、ピクセル処理を行うためのピクセルシェーダーのみです。固定機能の時代に比べると、ある程度自由にプログラミングができるようになったとはいえ、まだまだ制約は多いです。頂点シェーダーからの出力結果に計算の結果を簡単に加工することはできませんし、ピクセルシェーダーからの出力もカラー情報しか出力できません。DirectX9までは、この二つのシェーダーステージしか用意されていませんでした。(しかし、ゲーム開発者はこの制限のなかでもGPGPUをおこなっていましたが・・・)。そこで、GPUに汎用的な処理を行わせるプログラムを簡単に記述したい、という開発者の要望に答える形で、DirectX10にコンピュートシェーダーという新しいシェーダーステージが追加されました。
コンピュートシェーダーはhlslで記述することができ、より柔軟に計算結果を出力することができるようになっています。</p>
<h2 id="153-%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E5%85%A5%E5%8A%9B%E3%81%A8%E5%87%BA%E5%8A%9B">15.3 データの入力と出力</h2>
<p> 多くの処理ではいろいろな計算を行うためにはデータを入力する必要があります。そしてその入力に対する計算結果を出力する必要もあるでしょう。クラスの平均点を求める関数であれば、リスト15.1のような実装になると思います。</br></p>
<p>【リスト15.1】</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CalcAvarage</span><span class="hljs-params">( <span class="hljs-keyword">int</span> numStudent, <span class="hljs-keyword">int</span>* scoreArray )</span>
</span>{
	<span class="hljs-keyword">int</span> totalScore = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> I = <span class="hljs-number">0</span>; I &lt; numStudent; i++ ){
	totalScore += scoreArray[i];
	}
	<span class="hljs-keyword">return</span> totalScore / numStudent;
}
</div></code></pre>
<p>このクラスの平均点を求める計算をGPUに行わせる場合も同様にGPUに対して生徒数と点数の配列を送ってやる必要があります。そして、GPUで行った計算結果を出力する必要があります。</p>
<h2 id="154-structuredbuffer">15.4 StructuredBuffer</h2>
<p> StructuredBufferとは構造化バッファと呼ばれるもので、構造体の配列のように扱うことができます。今回扱うサンプルプログラムでは、シェーダーへの入力、出力として使用しています。</p>
<h2 id="155-%E3%82%A2%E3%83%B3%E3%82%AA%E3%83%BC%E3%83%80%E3%83%BC%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%83%93%E3%83%A5%E3%83%BC%E3%81%A8%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E3%83%93%E3%83%A5%E3%83%BC">15.5 アンオーダーアクセスビューとシェーダーリソースビュー</h2>
<p> データの入力はピクセルシェーダーや頂点シェーダーと同じように、定数バッファやシェーダーリソースビューなどを利用して入力します。しかし、これらは読み取り専用となっており、データの出力では利用できません。そこで、今回はデータの出力が可能なアンオーダーアクセスビューを使用します。ビューというのはリソースの振る舞いについて定義するためのものです。例えば、シェーダーリソースビューが指定されたリソースは読み取り専用になります。一方アンオーダーアクセスビューが設定されたリソースはランダムアクセスが可能になり、読み書きが可能になります。リスト15.1のプログラムですと、CaclAvarageの引数で渡しているデータはシェーダーリソースビュー、戻り値のデータはアンオーダーアクセスビューに関連付けされます。</br></p>
<p><strong>図15.1</strong></br>
<img src="fig/15_2.png"></img></br></p>
<h2 id="156-%E5%AD%A6%E7%94%9F%E3%81%AE%E5%B9%B3%E5%9D%87%E7%82%B9%E3%82%92%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0">15.6 学生の平均点を計算するプログラム</h2>
<p> では、具体的なプログラムを見て、コンピュートシェーダーの使い方を学んでいきましょう。Sample_15_1/Sample_15_1.slnを起動して実行してください。このプログラムは3人の生徒の試験の成績をランダムに生成して、その平均点を計算して図15.2のように表示しているだけの簡単なプログラムです。</br>
<strong>図15.2</strong></br>
<img src="fig/15_1.png"></img></br></p>
<h3 id="1561-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%88%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%AE%E3%83%AD%E3%83%BC%E3%83%89">15.6.1　コンピュートシェーダーのロード</h3>
<p> まず、コンピュートシェーダーをロードする必要があります。シェーダーのロードの処理は頂点シェーダーやピクセルシェーダーと同じように、シェーダーファイルのファイルパスとエントリーポイントとなる関数名を指定します。</br>
[リスト 15.2 main.cpp 27行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//コンピュートシェーダのロード</span>
Shader cs;
cs.LoadCS(<span class="hljs-string">L"Assets/shader/sample.fx"</span>, <span class="hljs-string">"CSMain"</span>);
</div></code></pre>
<h3 id="1562-%E5%85%A5%E5%8A%9B%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%82%92%E4%BD%9C%E6%88%90">15.6.2　入力データを受け取るバッファを作成</h3>
<p> 続いて、入力データを受け取るバッファを作成します。コンピュートシェーダもGPU上で動作するので、当然アクセスできるのはグラフィックメモリですので、グラフィックメモリ上にバッファを作成する必要があります。今回は入力データは読み取り専用のストラクチャードバッファとして作成しています。</br>
[リスト 15.3 main.cpp 39行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//入力データを受け取るバッファを作成。</span>
<span class="hljs-keyword">int</span> inputData[] = {
	<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>
};

StructuredBuffer inputSB;
inputSB.Init(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-number">3</span>, inputData);
</div></code></pre>
<h3 id="1563-%E5%87%BA%E5%8A%9B%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%82%92%E4%BD%9C%E6%88%90">15.6.3 出力データを受け取るバッファを作成</h3>
<p> 入力データが作成できたら、今度は出力データを記憶するバッファを作成します。出力データは読み書き可能なストラクチャードバッファとして作成しています。</br>
[リスト 15.4 main.cpp 47行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//出力データを受け取るバッファを作成。</span>
RWStructuredBuffer outputSb;
outputSb.Init(<span class="hljs-keyword">sizeof</span>(OutputData), <span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<h3 id="1564-%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF%E3%83%92%E3%83%BC%E3%83%97%E3%81%B8%E3%81%AE%E7%99%BB%E9%8C%B2">15.6.4 ディスクリプタヒープへの登録</h3>
<p> 入力データと出力データをディスクリプタヒープに登録します。これも頂点シェーダー、ピクセルシェーダと変わりありません。入力データはシェーダーリソースビュー、出力データはアンオーダーアクセスビューとして登録します。</br>
[リスト 15.5 main.cpp 49行目～]</p>
<pre class="hljs"><code><div>DescriptorHeap ds;
ds.RegistShaderResource(<span class="hljs-number">0</span>, inputSB);
ds.RegistUnorderAccessResource(<span class="hljs-number">0</span>, outputSb);
ds.Commit();
</div></code></pre>
<h3 id="1565-%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81%E3%82%B3%E3%83%BC%E3%83%AB">15.6.5 ディスパッチコール</h3>
<p> ディスパッチコールを実行することで、設定されていたコンピュートシェーダーが実行されます。絵を描くときのドローコール似たような感じです。ディスパッチコールを行うために必要なリソースを設定して実行します。</br>
[リスト 15.6 main.cpp 76行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//////////////////////////////////////</span>
<span class="hljs-comment">//ここからDirectComputeへのディスパッチ命令。</span>
<span class="hljs-comment">//////////////////////////////////////</span>
renderContext.SetComputeRootSignature(rs);
renderContext.SetPipelineState(pipelineState);
renderContext.SetComputeDescriptorHeap(ds);
renderContext.Dispatch(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
</div></code></pre>
<h3 id="1566-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%88%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC">15.6.6 コンピュートシェーダー</h3>
<p> では、最後にコンピュートシェーダーのコードを見ていきましょう。やっていることは平均点、最高点、最小点の計算を行っているだけです。</br>
 入力データにアクセスするための変数と、出力データにアクセスするための変数が用意されています。入力データはシェーダーリソースビューなのでtレジスタに割り当てられています。出力データはuレジスタに割り当てられています。
[リスト 15.7 Assets/shader/sample.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 平均点、最高得点、最低得点を計算するコンピュートシェーダー。</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_STUDENT 3.0f <span class="hljs-comment">//生徒の数</span></span>

<span class="hljs-comment">//出力データ構造体</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OutputData</span>{</span>
	<span class="hljs-keyword">float</span> avarageScore;	<span class="hljs-comment">//平均点。</span>
	<span class="hljs-keyword">float</span> maxScore;		<span class="hljs-comment">//最高点。</span>
	<span class="hljs-keyword">float</span> minScore;		<span class="hljs-comment">//最小点。</span>
};

<span class="hljs-comment">//入力データにアクセスるための変数。</span>
StructuredBuffer&lt;<span class="hljs-keyword">int</span>&gt; g_scores : <span class="hljs-keyword">register</span>(t0);
<span class="hljs-comment">//出力先にアクセスするための変数。</span>
RWStructuredBuffer&lt;OutputData&gt; g_outputData : <span class="hljs-keyword">register</span>(u0);

<span class="hljs-comment">//これがエントリーポイント</span>
[numthreads(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)] <span class="hljs-comment">//これは今は気にしなくてよい。</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSMain</span><span class="hljs-params">( uint3 DTid : SV_DispatchThreadID )</span>
</span>{
	g_outputData[<span class="hljs-number">0</span>].maxScore = <span class="hljs-number">0</span>;
	g_outputData[<span class="hljs-number">0</span>].minScore = <span class="hljs-number">100</span>;

	<span class="hljs-keyword">int</span> totalScore = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_STUDENT; i++ ){
		totalScore += g_scores[i];
		g_outputData[<span class="hljs-number">0</span>].maxScore = max( g_outputData[<span class="hljs-number">0</span>].maxScore, g_scores[i]);
		g_outputData[<span class="hljs-number">0</span>].minScore = min( g_outputData[<span class="hljs-number">0</span>].minScore, g_scores[i]);
	}
	g_outputData[<span class="hljs-number">0</span>].avarageScore = totalScore / NUM_STUDENT;
}
</div></code></pre>
<h2 id="157-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E5%90%88%E8%A8%88%E7%82%B9%E3%82%92%E5%87%BA%E5%8A%9B%E3%81%99%E3%82%8B">15.7 【ハンズオン】合計点を出力する</h2>
<p> では、Sample_15_01を改造して、合計点を出力できるようにしてみましょう。まず、コンピュートシェーダーを改造しましょう。</br></p>
<h3 id="1571-step-1-%E5%87%BA%E5%8A%9B%E6%A7%8B%E9%80%A0%E4%BD%93%E3%81%AB%E3%83%A1%E3%83%B3%E3%83%90%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8Bhlsl">15.7.1 step-1 出力構造体にメンバを追加する(HLSL)</h3>
<p> sample.fxの「step-1 出力構造体にメンバを追加する」と書かれている箇所にリスト15.8のプログラムを追加してください。</br>
[リスト 15.8 sample.fx]</p>
<pre class="hljs"><code><div>//step-1 出力構造体にメンバを追加する
int totalScore;		//合計点。
</div></code></pre>
<h3 id="1572-step-2-%E5%90%88%E8%A8%88%E7%82%B9%E3%82%92%E5%87%BA%E5%8A%9B%E3%81%99%E3%82%8Bhlsl">15.7.2 step-2 合計点を出力する(HLSL)</h3>
<p> メンバを追加できたら、実際に出力するプログラムをウ生かします。「step-2 合計点を出力する」と書かれている箇所にリスト15.9のプログラムを追加してください。</br>
[リスト 15.9 sample.fx]</p>
<pre class="hljs"><code><div>//step-2 合計点を出力する
g_outputData[0].totalScore = totalScore;
</div></code></pre>
<h3 id="1573-step-3-%E5%87%BA%E5%8A%9B%E6%A7%8B%E9%80%A0%E4%BD%93%E3%81%AB%E3%83%A1%E3%83%B3%E3%83%90%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8Bc">15.7.3 step-3 出力構造体にメンバを追加する(C++)</h3>
<p> 続いて、コンピュートシェーダーで計算されたデータを受け取るために、C++側に定義されている出力構造体にもメンバを追加しましょう。main.cppの「step-3 出力構造体にメンバを追加する」と書かれている箇所にリスト15.10のプログラムを追加してください。</br>
[リスト 15.10]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 出力構造体にメンバを追加する</span>
<span class="hljs-keyword">int</span> totalScore;		<span class="hljs-comment">//合計点。</span>
</div></code></pre>
<h3 id="1574-step-4-%E5%90%88%E8%A8%88%E7%82%B9%E3%82%92%E8%A1%A8%E7%A4%BA%E3%81%99%E3%82%8Bc">15.7.4 step-4 合計点を表示する(C++)</h3>
<p> では最後のハンズオンです。main.cppの「step-4 合計点を表示する」と書かれている箇所にリスト15.11のプログラムを追加して、メッセージボックスに合計点の表示を追加してみましょう。
[リスト 15.11]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 合計点を表示する</span>
<span class="hljs-built_in">sprintf</span>(
	text, 
	<span class="hljs-string">"１人目 = %d\n"</span> \
	<span class="hljs-string">"２人目 = %d\n"</span> \
	<span class="hljs-string">"３人目 = %d\n"</span> \
	<span class="hljs-string">"平均点 = %0.2f\n"</span> \
	<span class="hljs-string">"最高得点=%0.2f\n"</span> \
	<span class="hljs-string">"最低得点=%0.2f\n"</span> \
	<span class="hljs-string">"合計点=%d\n"</span>, <span class="hljs-comment">//これを追加。</span>
	inputData[<span class="hljs-number">0</span>], 
	inputData[<span class="hljs-number">1</span>], 
	inputData[<span class="hljs-number">2</span>],
	outputData-&gt;avarageScore, 
	outputData-&gt;maxScore, 
	outputData-&gt;minScore,
	outputData-&gt;totalScore <span class="hljs-comment">//これも追加。</span>
);
</div></code></pre>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h2 id="158%E8%AA%B2%E9%A1%8C%E6%A8%99%E6%BA%96%E5%81%8F%E5%B7%AE%E3%82%92%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B">15.8【課題】標準偏差を計算する</h2>
<p> Sample_15_01を改造して、図15.3のように標準偏差を表示できるようにしなさい。</br>
<strong>図15.3</strong></br></p>
<!-- どこかのサイトから拾ってきた画像です。差し替えをお願いします。 -->
<p><img src="fig/15_3.png"></img></br></p>
<p>標準偏差の計算はGPUで行いなさい。標準偏差は下記の数式で求めることができます。</br></p>
<p><img src="fig/標準偏差の公式.jpg" width=300></img></br></p>
<p>答え:Sample_15_01/Assets/shader/main_15_8.fx、Sample_15_01/main_15_8.cpp</br></p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h2 id="159-%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%88%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%AE%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86">15.9 コンピュートシェーダーの並列処理</h2>
<p> この節では、画像のモノクロ化のサンプルプログラムを通して、コンピュートシェーダーの並列処理について学んでいきます。</p>
<h3 id="1591-%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89">15.9.1 スレッド</h3>
<p> すべてのプログラムはスレッドによって実行されています。驚くかもしれませんが、実はこれまで、あなたが記述したmain関数はメインスレッドから呼ばれていたのです。スレッドは複数作成することができて、作成されたスレッドは並列に動作します。例えば、あるゲームの１フレームの処理が図15.4のようになっていると考えてみましょう。</br>
<strong>図15.4</strong></br>
<img src="fig/15_4.png"></img></br>
 このゲームではメインスレッドに記述されているゲームループから順次処理を呼び出していて、1フレームの処理が完了するまでに24ミリ秒かかっています。残念ながらこのゲームは60fpsを達成できていないため、ゲームプレイの滑らかさは多少損なわれています。図15.5はスレッドを二つ立てて、ゲームの処理、物理シミュレーション、描画処理を並列に実行している様子です。</br></p>
<p><strong>図15.5</strong></br>
<img src="fig/15_5.png"></img></br>
 物理シミュレーションと描画処理を並列に実行するようにしたことで、１フレームの処理時間が14ミリ秒まで短縮できました！これで60fpsが達成できました！(現実はデータの排他など非常に難解なことを考える必要が出てくるため、マルチスレッドにするということはここまで簡単な話ではないので注意してください。)コンピュートシェーダーもスレッドから実行されており、ディスパッチされると、スレッドが生成されます。生成されるスレッドの数はコンピュートシェーダーのコードで指定することができます。</br></p>
<pre class="hljs"><code><div>[numthreads(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)] <span class="hljs-comment">//これがスレッドの数！！！                                                                                </span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CSMain</span><span class="hljs-params">( uint3 DTid : SV_DispatchThreadID)</span>
</span>{
　　　・
　　　・
　　　・
}
</div></code></pre>
<p> numthreads(x,y,z)という文が一つのスレッドグループで生成されるスレッド数を指定しています(スレッドグループについては後述します)。この場合生成されるスレッド数は2×2×1の4スレッド生成されます。numthreads(4, 1, 1)と同じ意味になるのですが、例えば入力データを二次元配列のように扱いたい場合、このように指定したほうが扱いやすくなります。</br></p>
<h3 id="1592-%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%97">15.9.2 スレッドグループ</h3>
<p> スレッドグループとはスレッドをひとまとめにしたものです。スレッドグループの数はコンピュートシェーダーをディスパッチするときに指定することができます。</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//3×3のスレッドグループが作られる！</span>
renderContext.Dispatch(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);
</div></code></pre>
<p> Dispatch関数の引数がスレッドグループの数です。この場合スレッドグループの数は3×3×1の9グループとなります。では15.9.1の4スレッド生成するコンピュートシェーダーを3×3×1の9グループでディスパッチするとどのようになるか見てみいきましょう。まずディスパッチされると(0,0,0)のグループの4スレッドが起動してCSMainが実行されます。</br>
<strong>図15.6</strong></br>
<img src="fig/15_6.png"></img></br>
(0,0,0)のスレッドがすべて終了すると(0,1,0)のグループが実行されます。</br></p>
<p><strong>図15.7</strong></br>
<img src="fig/15_7.png"></img></br>
続いて(0,2,0)、(1,0,0)と実行されて最後に(2,2,0)を実行するとコンピュートシェーダーは終了します。</br></p>
<h3 id="1593-svdispatchthreadid%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%82%AF%E3%82%B9">15.9.3 SV_DispatchThreadIDセマンティクス</h3>
<p> コンピュートシェーダ―では、メイン関数の引数にSV_DispatchThreadIDセマンティクスを指定することができます。このセマンティクスを指定するとメイン関数を呼び出しているスレッドのIDを引っ張ってくるができます。このIDは3次元ベクトルになります。例えば、スレッドＡのIDは(3,4,3)、スレッドＢのIDは(10, 2, 1)といったものです。例えば、２×２×１のスレッドで実行されるコンピュートシェーダ―を４×３×１のスレッドグループでディスパッチすると、スレッドIDは(0,0,0)～(8,6,1)になります。</p>
<h3 id="1594-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E3%83%A2%E3%83%8E%E3%82%AF%E3%83%AD%E7%94%BB%E5%83%8F%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B">15.9.4 【ハンズオン】モノクロ画像を生成する</h3>
<p> ではSample_15_02を改造して、ロードしたビットマップフォーマットの画像をモノクロに変換するプログラムを作成してみましょう。ビットマップフォーマットは端的に説明すると、下記のコードのような光の三原色のデータの配列です。</p>
<pre class="hljs"><code><div><span class="hljs-comment">//1ピクセルのデータ構造体。</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SRgb</span>{</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> r;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> g;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> b;
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> a;
};
<span class="hljs-comment">//画像データ。ピクセルの集合体。</span>
SRgb image[<span class="hljs-number">512</span>×<span class="hljs-number">512</span>];
</div></code></pre>
<h4 id="step-1-%E7%94%BB%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%A1%E3%83%A2%E3%83%AA%E4%B8%8A%E3%81%AB%E3%83%AD%E3%83%BC%E3%83%89%E3%81%99%E3%82%8B">step-1 画像データをメインメモリ上にロードする。</h4>
<p> では、ハンズオンを行っていきます。今回はAssets/image/original.bmpをモノクロ化します。まずは画像データをメインメモリ上にロードします。リスト15.12を入力してください。なお、このサンプルプログラムにはビットマップ画像をロードできるBitmapクラスを用意しています。このクラスは簡易的なクラスであるため、全てのビットマップ画像を扱えるわけではないので注意してください。</br>
[リスト15.2 main.cpp 22行目～]</p>
<pre class="hljs"><code><div>Bitmap imagebmp;
imagebmp.Load(<span class="hljs-string">"Assets/image/original.bmp"</span>);
</div></code></pre>
<p> </p>
<h4 id="step-2-%E7%94%BB%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E3%82%B0%E3%83%A9%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AB%E9%80%81%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E3%83%89%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B">step-2  画像データをグラフィックメモリに送るためにストラクチャードバッファを作成する。</h4>
<p> step-1でロードした画像データはメインメモリに乗っています。今回はコンピュートシェーダ―でモノクロ化を行うため、グラフィックメモリに転送する必要があります。リスト15.3のプログラムを入力して、ストラクチャードバッファを作成しましょう。</br>
[リスト15.3 main.cpp 26行目～]</p>
<pre class="hljs"><code><div>StructuredBuffer inputImageBmpSB;
inputImageBmpSB.Init(
	imagebmp.GetPixelSizeInBytes(), <span class="hljs-comment">//第一引数は1画素のサイズ。</span>
	imagebmp.GetNumPixel(),			<span class="hljs-comment">//ピクセルの数を取得。</span>
	imagebmp.GetImageAddress()		<span class="hljs-comment">//画像データの先頭アドレス。</span>
);
</div></code></pre>
<h4 id="step-3-%E3%83%A2%E3%83%8E%E3%82%AF%E3%83%AD%E5%8C%96%E3%81%97%E3%81%9F%E7%94%BB%E5%83%8F%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AErw%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%83%81%E3%83%A3%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%82%92%E4%BD%9C%E6%88%90">step-3 モノクロ化した画像を受け取るためのRWストラクチャバッファを作成。</h4>
<p> では、続いてモノクロ化した画像を受け取るためのRWストラクチャバッファを作成します。リスト15.4のプログラムを入力してください。</br>
[リスト15.4 main.cpp 31行目～]</p>
<pre class="hljs"><code><div>RWStructuredBuffer outputImageBmpRWSB;
outputImageBmpRWSB.Init(
	imagebmp.GetPixelSizeInBytes(), <span class="hljs-comment">//第一引数は1画素のサイズ。</span>
	imagebmp.GetNumPixel(),			<span class="hljs-comment">//ピクセルの数を取得。</span>
	imagebmp.GetImageAddress()		<span class="hljs-comment">//画像データの先頭アドレス。</span>
);
</div></code></pre>
<h4 id="step-4-%E5%85%A5%E5%8A%9B%E3%83%87%E3%83%BC%E3%82%BF%E3%81%A8%E5%87%BA%E5%8A%9B%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF%E3%83%92%E3%83%BC%E3%83%97%E3%81%AB%E7%99%BB%E9%8C%B2%E3%81%99%E3%82%8B">step-4 入力データと出力データをディスクリプタヒープに登録する。</h4>
<p> 入力データと出力データを受け取るためのバッファを作成出来たら、バッファをディスクリプタヒープに登録します。リスト15.5のプログラムを入力してください。</br>
[リスト15.5 main.cpp 42行目～]</p>
<pre class="hljs"><code><div>DescriptorHeap ds;
ds.RegistShaderResource(<span class="hljs-number">0</span>, inputImageBmpSB);
ds.RegistUnorderAccessResource(<span class="hljs-number">0</span>, outputImageBmpRWSB);
ds.Commit();
</div></code></pre>
<h4 id="step-5-%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81%E3%82%B3%E3%83%BC%E3%83%AB%E3%82%92%E5%AE%9F%E8%A1%8C%E3%81%99%E3%82%8B">step-5 ディスパッチコールを実行する。</h4>
<p> step-4までで準備が完了したので、ディスパッチコールを実行します。リスト15.6のプログラムを入力してください。</br>
[リスト15.6 main.cpp 70行目～]</p>
<pre class="hljs"><code><div>renderContext.SetComputeRootSignature(rs);
renderContext.SetPipelineState(pipelineState);
renderContext.SetComputeDescriptorHeap(ds);
<span class="hljs-comment">//ピクセル数は512×512 = 262,144ピクセル。</span>
<span class="hljs-comment">//4つのスレッドを生成するコンピュートシェーダ―なので、</span>
<span class="hljs-comment">//262,144 ÷ 4 = 65,536個のスレッドグループを作成する。</span>
renderContext.Dispatch(<span class="hljs-number">65536</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
</div></code></pre>
<h4 id="step-6-%E3%83%A2%E3%83%8E%E3%82%AF%E3%83%AD%E3%81%AB%E3%81%97%E3%81%9F%E7%94%BB%E5%83%8F%E3%82%92%E4%BF%9D%E5%AD%98">step-6 モノクロにした画像を保存。</h4>
<p> では、これでC++側は最後になります。コンピュートシェーダ―でのモノクロ化の結果を確認するために画像データを保存しましょう。Bitmapクラスには画像をセーブする機能があります。この機能を使ってAssets/imageフォルダの中にmonochrome.bmpという名前で保存します。リスト15.7のプログラムを入力してください。</br>
[リスト15.7 main.cpp 70行目～]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-6 モノクロにした画像を保存。</span>
imagebmp.Copy(outputImageBmpRWSB.GetResourceOnCPU());
imagebmp.Save(<span class="hljs-string">"Assets/image/monochrome.bmp"</span>);
</div></code></pre>
<h4 id="step-7-t0u0%E3%81%AB%E8%A8%AD%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%A4%89%E6%95%B0%E3%82%92%E5%AE%9A%E7%BE%A9">step-7 t0、u0に設定されているバッファにアクセスするための変数を定義。</h4>
<p> 続いてシェーダー側のプログラムです。まずは、t0、u0レジスタに設定されているストラクチャードバッファにアクセスるための変数を定義します。Assets/shader/sample.fxを開いて、リスト15.8のプログラムを入力してください。</br>
[リスト15.8 sample.fx 7行目～]</p>
<pre class="hljs"><code><div>//step-7 t0、u0に設定されているバッファにアクセスするための変数を定義。
StructuredBuffer&lt;uint&gt; inputImage : register( t0 );
RWStructuredBuffer&lt;uint&gt; outputBuffer : register(u0);
</div></code></pre>
<h4 id="step-8-%E5%85%A5%E5%8A%9B%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8B%E3%82%89%E7%94%BB%E7%B4%A0%E3%82%92%E5%BC%95%E3%81%A3%E5%BC%B5%E3%81%A3%E3%81%A6%E3%81%8D%E3%81%A6%E3%83%A2%E3%83%8E%E3%82%AF%E3%83%AD%E5%8C%96">step-8 入力データから画素を引っ張ってきて、モノクロ化。</h4>
<p> では、これで最後です。コンピュートシェーダ―のメイン関数を実装します。リスト15.9のプログラムを入力してください。</br>
[リスト15.9 sample.fx 36行目～]</p>
<pre class="hljs"><code><div>//step-8 入力データから画素を引っ張ってきてモノクロ化する。

//スレッドＩＤをりよして画像データから画素を引っ張ってくる。
uint iColor = inputImage[DTid.x];
//0～255の画像データを0.0～1.0に正規化する。
float4 color = UnpackedRGBA32ToFloat4(iColor);

float Y = 0.29900 * color.r + 0.58700 * color.g + 0.11400 * color.b;
color.r = Y;
color.g = Y;
color.b = Y;
color.a = 1.0f;

//float4をRGBA32ビットのフォーマットに変して出力
outputBuffer[DTid.x] = PackedFloat4ToRGBA32( color );
</div></code></pre>
<p> 全て入力出来たらプログラムを実行してみてください。完成していたら、Assets/imageフォルダの中にmonochrome.bmpが出来上がっています。</p>
<h3 id="1595-svdispatchthreadid%E3%82%BB%E3%83%9E%E3%83%B3%E3%83%86%E3%82%A3%E3%82%AF%E3%82%B9%E3%81%AE%E5%88%A9%E7%94%A8">15.9.5 SV_DispatchThreadIDセマンティクスの利用</h3>
<p> さて、先ほどのハンズオンではスレッドグループが65536個、１つのスレッドグループで実行されるスレッドの数が4個でした。ですので、生成されるスレッド数は65536 × 4 = 262,144個‬になっていました。この数は、今回モノクロ化した画像のピクセル数と同じです(512 × 512 = 262,144)。今回のハンズオンでは、モノクロカする画像のピクセル数と同じになるようにディスパッチされていて、１つのスレッドが１ピクセルをモノクロ化していました。各スレッドが度のピクセルをモノクロ化するかを決めるために、SV_DispatchThreadIDセマンティクスが使われていました。SV_DispatchThreadIDセマンティクスが指定された変数にはスレッドの番号が入っています。今回は0～262,143の番号が渡されます。ちょうどピクセルの画素を配列として扱った場合のインデックスと一致しています。これを利用して、各スレッドに１ピクセルずつモノクロ加工させていたわけです。</p>
<h3 id="1596-%E8%AA%B2%E9%A1%8C%E8%A7%A3%E5%83%8F%E5%BA%A6%E3%81%AE%E9%81%95%E3%81%86original2bmp%E3%82%92%E3%83%A2%E3%83%8E%E3%82%AF%E3%83%AD%E5%8C%96%E3%81%97%E3%81%AA%E3%81%95%E3%81%84">15.9.6 【課題】解像度の違うoriginal2.bmpをモノクロ化しなさい。</h3>
<p> Sample_15_02を改造して、original2.bmpをモノクロ化して、monochrome2.bmpという名前で保存しなさい。表15.1のようにoriginal2.bmpはoriginal.bmpとでは解像度が違います。そのため、生成するスレッドの数を変更する必要があります。</br>
<strong>表15.1</strong></br></p>
<table>
<thead>
<tr>
<th>ファイル名</th>
<th>解像度</th>
</tr>
</thead>
<tbody>
<tr>
<td>original.bmp</td>
<td>512 × 512</td>
</tr>
<tr>
<td>original2.bmp</td>
<td>1024 × 768</td>
</tr>
</tbody>
</table>
<p>答え:Sample_15_02/Assets/shader/main_15.9.6.cpp</p>
<h3 id="1597-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3originalbmp%E3%81%AB%E3%82%AC%E3%82%A6%E3%82%B7%E3%82%A2%E3%83%B3%E3%83%96%E3%83%A9%E3%83%BC%E3%82%92%E3%81%8B%E3%81%91%E3%81%A6%E3%83%9C%E3%82%B1%E7%94%BB%E5%83%8F%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B">15.9.7 【ハンズオン】original.bmpにガウシアンブラーをかけてボケ画像を生成する。</h3>
<p> 続いて、Sample_15_03を改造して、ロードした画像にガウシアンブラーをかけてボケ画像を生成するプログラムを作成してみましょう。実装するボケ画像生成のアルゴリズムはポストエフェクトの章で勉強したアルゴリズムと同じで、カウス関数で計算した重みテーブルを使って、Xブラー、Yブラーを行って縮小テクスチャを作っていきます。</br></p>
<h4 id="step-1-%E7%94%BB%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E3%83%A1%E3%82%A4%E3%83%B3%E3%83%A1%E3%83%A2%E3%83%AA%E4%B8%8A%E3%81%AB%E3%83%AD%E3%83%BC%E3%83%89%E3%81%99%E3%82%8B">step-1 画像データをメインメモリ上にロードする。</h4>
<p> まずはBitmapクラスを使って、画像データをロードします。リスト15.10のプログラムを入力してください。</br>
[リスト15.10 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 画像データをメインメモリ上にロードする。</span>
Bitmap imagebmp;
imagebmp.Load(<span class="hljs-string">"Assets/image/original.bmp"</span>);
</div></code></pre>
<h4 id="step-2-%E3%83%96%E3%83%AC%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E4%BF%82%E6%95%B0%E3%82%92%E9%80%81%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%AE%9A%E6%95%B0%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%82%92%E4%BD%9C%E6%88%90">step-2 ブレンディング係数を送るための定数バッファを作成。</h4>
<p> ピクセルの重みテーブルを送るための定数バッファを作成します。リスト15.11のプログラムを入力して下さい。</br>
[リスト15.11 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-2 ブレンディング係数を送るための定数バッファを作成する。</span>
ConstantBuffer weightsCB;
weightsCB.Init(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>) * <span class="hljs-number">8</span>, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<h4 id="step-3-%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E6%83%85%E5%A0%B1%E3%82%92%E9%80%81%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%AE%9A%E6%95%B0%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B">step-3 テクスチャ情報を送るための定数バッファを作成する。</h4>
<p> 縮小バッファを利用したガウシアンブラーでは、オリジナルのテクスチャ、Xブラーをかけた画像の出力用のテクスチャ、Yブラーをかけた画像の出力用のテクスチャの情報が必要になります。これらをグラフィックメモリに送るために定数バッファを追加します。リスト15.12のプログラムを入力して下さい。</br>
[リスト15.12 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 テクスチャ情報を送るための定数バッファを作成する。</span>
TexInfo texInfo;
texInfo.originalTexSize[<span class="hljs-number">0</span>] = imagebmp.GetWidth();
texInfo.originalTexSize[<span class="hljs-number">1</span>] = imagebmp.GetHeight();
texInfo.xBlurTexSize[<span class="hljs-number">0</span>] = texInfo.originalTexSize[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span>;
texInfo.xBlurTexSize[<span class="hljs-number">1</span>] = texInfo.originalTexSize[<span class="hljs-number">1</span>];
texInfo.yBlurTexSize[<span class="hljs-number">0</span>] = texInfo.originalTexSize[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span>;
texInfo.yBlurTexSize[<span class="hljs-number">1</span>] = texInfo.originalTexSize[<span class="hljs-number">1</span>] / <span class="hljs-number">2</span>;
ConstantBuffer texInfoCB;
texInfoCB.Init(<span class="hljs-keyword">sizeof</span>(texInfo), &amp;texInfo);
</div></code></pre>
<h4 id="step-4-%E5%90%84%E7%A8%AE%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%83%81%E3%83%A3%E3%83%BC%E3%83%89%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B">step-4 各種ストラクチャードバッファを作成する。</h4>
<p> 今回使用するアルゴリズムでは、オリジナルの画像をGPUに渡すための入力用のバッファと、コンピュートシェーダ―が３回ディスパッチされて、横方向に半分の解像度のテクスチャ(Xブラーの出力結果)、縦横半分の解像度のテクスチャ(Yブラーの出力結果)、オリジナルの画像と同じ解像度のテクスチャ(最終合成の結果)の３つ出力用のバッファが必要となります。では、リスト15.13を入力して、各種ストラクチャードバッファを作成できるようにしてください。</br>
[リスト15.13 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 各種ストラクチャードバッファを作成する。</span>
StructuredBuffer inputImageBmpSB;
inputImageBmpSB.Init(
	imagebmp.GetPixelSizeInBytes(), <span class="hljs-comment">//第一引数は1画素のサイズ。</span>
	imagebmp.GetNumPixel(),			<span class="hljs-comment">//ピクセルの数を取得。</span>
	imagebmp.GetImageAddress()		<span class="hljs-comment">//画像データの先頭アドレス。</span>
);

<span class="hljs-comment">//Xブラーをかけた画像を出力するためのRWストラクチャバッファを作成。</span>
RWStructuredBuffer outputXBlurImageRWSB;
outputXBlurImageRWSB.Init(
	imagebmp.GetPixelSizeInBytes(), <span class="hljs-comment">//第一引数は1画素のサイズ。</span>
	imagebmp.GetNumPixel() / <span class="hljs-number">2</span>,		<span class="hljs-comment">//横方向に1/2の解像度へダウンサンプリングを行うのでピクセル数を半分にする。</span>
	<span class="hljs-literal">nullptr</span>
);

<span class="hljs-comment">//Yブラーをかけた画像を出力するためのRWストラクチャバッファを作成。</span>
RWStructuredBuffer outputYBlurImageRWSB;
outputYBlurImageRWSB.Init(
	imagebmp.GetPixelSizeInBytes(), <span class="hljs-comment">//第一引数は1画素のサイズ。</span>
	imagebmp.GetNumPixel() / <span class="hljs-number">4</span>,		<span class="hljs-comment">//縦、横方向に1/2の解像度へダウンサンプリングを行うのでピクセル数を1/4にする。</span>
	<span class="hljs-literal">nullptr</span>
);
<span class="hljs-comment">//最終結果を出力するためのRWストラクチャバッファを作成。</span>
RWStructuredBuffer finalImageRWSB;
finalImageRWSB.Init(
	imagebmp.GetPixelSizeInBytes(), <span class="hljs-comment">//第一引数は1画素のサイズ。</span>
	imagebmp.GetNumPixel(),	
	<span class="hljs-literal">nullptr</span>
);
</div></code></pre>
<h4 id="step-5-%E5%90%84%E7%A8%AE%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF%E3%83%92%E3%83%BC%E3%83%97%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B">step-5 各種ディスクリプタヒープを作成する。</h4>
<p> 続いて各種ディスクリプタヒープの作成です。今回はコンピュートシェーダを３回ディスパッチしますが、そのために入力用のバッファと出力用のバッファが異なります。そこで、各ディスパッチ用のディスクリプタ―ヒープを作成する必要があります。リスト15.14のプログラムを入力してください。</br>
[リスト15.14 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-5 各種ディスクリプタヒープを作成する。</span>
<span class="hljs-comment">//Xブラー用のディスクリプタヒープを作成。</span>
DescriptorHeap xBlurDS;
xBlurDS.RegistShaderResource(<span class="hljs-number">0</span>, inputImageBmpSB);
xBlurDS.RegistConstantBuffer(<span class="hljs-number">0</span>, weightsCB);
xBlurDS.RegistConstantBuffer(<span class="hljs-number">1</span>, texInfoCB);
xBlurDS.RegistUnorderAccessResource(<span class="hljs-number">0</span>, outputXBlurImageRWSB);
xBlurDS.Commit();

<span class="hljs-comment">//Yブラー用のディスクリプタヒープを作成。</span>
DescriptorHeap yBlurDS;
yBlurDS.RegistShaderResource(<span class="hljs-number">0</span>, outputXBlurImageRWSB);
yBlurDS.RegistConstantBuffer(<span class="hljs-number">0</span>, weightsCB);
yBlurDS.RegistConstantBuffer(<span class="hljs-number">1</span>, texInfoCB);
yBlurDS.RegistUnorderAccessResource(<span class="hljs-number">0</span>, outputYBlurImageRWSB);
yBlurDS.Commit();

<span class="hljs-comment">//最終結果出力用のディスクリプタヒープを作成。</span>
DescriptorHeap finalDS;
finalDS.RegistShaderResource(<span class="hljs-number">0</span>, outputYBlurImageRWSB);
finalDS.RegistConstantBuffer(<span class="hljs-number">0</span>, weightsCB);
finalDS.RegistConstantBuffer(<span class="hljs-number">1</span>, texInfoCB);
finalDS.RegistUnorderAccessResource(<span class="hljs-number">0</span>, finalImageRWSB);
finalDS.Commit();
</div></code></pre>
<h4 id="step-6-%E5%90%84%E7%A8%AE%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%86%E3%83%BC%E3%83%88%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B">step-6 各種パイプラインステートを作成する。</h4>
<p> 続いてパイプラインステートの作成です。パイプラインステートもディスパッチのたびにシェーダーが変更されるため、ディスパッチの数分だけ作成する必要があります。リスト15.15のプログラムを入力してください。</br>
[リスト15.15 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-6 各種パイプラインステートを作成する。</span>

<span class="hljs-comment">//Xブラー用のパイプラインステートを作成。</span>
<span class="hljs-comment">//Xブラー用のコンピュートシェーダをロードする。</span>
Shader xblurCS;
xblurCS.LoadCS(<span class="hljs-string">L"Assets/shader/sample.fx"</span>, <span class="hljs-string">"XBlur"</span>);
<span class="hljs-comment">//パイプラインステートを作成する。</span>
PipelineState xBlurPipelineState;
InitPipelineState(rs, xBlurPipelineState, xblurCS);

<span class="hljs-comment">//Yブラー用のパイプラインステートを作成。</span>
<span class="hljs-comment">//Yブラー用のコンピュートシェーダのロード</span>
Shader yblurCS;
yblurCS.LoadCS(<span class="hljs-string">L"Assets/shader/sample.fx"</span>, <span class="hljs-string">"YBlur"</span>);
<span class="hljs-comment">//パイプラインステートを作成。</span>
PipelineState yBlurPipelineState;
InitPipelineState(rs, yBlurPipelineState, yblurCS);

<span class="hljs-comment">//最終出力用のパイプラインステートを作成。</span>
<span class="hljs-comment">//最終出力用のコンピュートシェーダーのロード。</span>
Shader finalCS;
finalCS.LoadCS(<span class="hljs-string">L"Assets/shader/sample.fx"</span>, <span class="hljs-string">"Final"</span>);
<span class="hljs-comment">//パイプラインステートを作成。</span>
PipelineState finalPipelineState;
InitPipelineState(rs, finalPipelineState, finalCS);
</div></code></pre>
<h4 id="step-7-%E5%90%84%E7%A8%AE%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%88%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E2%80%95%E3%82%92%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81">step-7 各種コンピュートシェーダ―をディスパッチ</h4>
<p> これで、cpp側は最後になります。準備が整ったので、各種コンピュートシェーダーをディスパッチしていきましょう。リスト15.16のプログラムを入力してください。</br></p>
<p>[リスト15.16 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-7 各種コンピュートシェーダ―をディスパッチ</span>
<span class="hljs-comment">//Xブラーをディスパッチ。</span>
renderContext.SetPipelineState(xBlurPipelineState);
renderContext.SetComputeDescriptorHeap(xBlurDS);
renderContext.Dispatch(texInfo.xBlurTexSize[<span class="hljs-number">0</span>] / <span class="hljs-number">4</span>, texInfo.xBlurTexSize[<span class="hljs-number">1</span>] / <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);

<span class="hljs-comment">//Yブラーをディスパッチ。</span>
renderContext.SetPipelineState(yBlurPipelineState);
renderContext.SetComputeDescriptorHeap(yBlurDS);
renderContext.Dispatch(texInfo.yBlurTexSize[<span class="hljs-number">0</span>] / <span class="hljs-number">4</span>, texInfo.yBlurTexSize[<span class="hljs-number">1</span>] / <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);

<span class="hljs-comment">//最終合成をディスパッチ。</span>
renderContext.SetPipelineState(finalPipelineState);
renderContext.SetComputeDescriptorHeap(finalDS);
renderContext.Dispatch(texInfo.originalTexSize[<span class="hljs-number">0</span>] / <span class="hljs-number">4</span>, texInfo.originalTexSize[<span class="hljs-number">1</span>] / <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);
</div></code></pre>
<h4 id="step-8-%E5%90%84%E7%A8%AE%E5%AE%9A%E6%95%B0%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%A4%89%E6%95%B0%E3%82%92%E5%AE%9A%E7%BE%A9">step-8 各種定数バッファにアクセスするための変数を定義。</h4>
<p> ここからはシェーダー側のプログラムになります。下まずは定数バッファにアクセスするための変数を定義します。Assets/shader/sample.fxを開いてリスト15.17のプログラムを入力して下さい。</br>
[リスト15.17 sample.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-8 各種定数バッファにアクセスするための変数を定義。</span>
<span class="hljs-comment">//定数バッファ</span>
cbuffer cb_0 : <span class="hljs-keyword">register</span>(b0) {
	float4 weights[<span class="hljs-number">2</span>];
	
};
<span class="hljs-comment">//テクスチャ情報用の定数バッファ。</span>
cbuffer texInfoCB : <span class="hljs-keyword">register</span>(b1){
	int2 texSize;			<span class="hljs-comment">//オリジナルテクスチャのサイズ</span>
	int2 xBlurTexSize;		<span class="hljs-comment">//Xブラーの出力先のテクスチャのサイズ。</span>
	int2 yBlurTexSize;		<span class="hljs-comment">//Yブラーの出力先のテクスチャのサイズ。</span>
};

</div></code></pre>
<h4 id="step-9-%E5%85%A5%E5%87%BA%E5%8A%9B%E7%94%BB%E5%83%8F%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%A4%89%E6%95%B0%E3%82%92%E5%AE%9A%E7%BE%A9">step-9 入出力画像にアクセスするための変数を定義。</h4>
<p> 続いて、入出力用の画像にアクセスするための変数を定義します。リスト15.18のプログラムを入力してください。</br>
[リスト 15.18 sample.fx]</p>
<pre class="hljs"><code><div>StructuredBuffer&lt;uint&gt; inputImage : <span class="hljs-keyword">register</span>(t0);
RWStructuredBuffer&lt;uint&gt; outputImage : <span class="hljs-keyword">register</span>(u0);
</div></code></pre>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h4 id="step-10-x%E3%83%96%E3%83%A9%E3%83%BC%E3%82%92%E5%AE%9F%E8%A3%85">step-10 Xブラーを実装</h4>
<p> いよいよコンピュートシェーダー本体の実装です。まずはXブラーの実装。Xブラーは基準テクセルから左右に８テクセルの合計１６テクセルをブレンディングしていきます。リスト15.19のプログラムを入力してください。</br>
[リスト 15.19 sample.fx]</p>
<pre class="hljs"><code><div>[numthreads(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">XBlur</span><span class="hljs-params">( uint3 DTid : SV_DispatchThreadID)</span>
</span>{
	uint2 basepos = uint2( DTid.x * <span class="hljs-number">2</span>, DTid.y);
	
	float4 color = GetPixelColor( basepos.x, basepos.y, texSize ) * weights[<span class="hljs-number">0</span>].x;
	color += GetPixelColor( basepos.x + <span class="hljs-number">1</span>, basepos.y, texSize ) * weights[<span class="hljs-number">0</span>].y;
	color += GetPixelColor( basepos.x + <span class="hljs-number">2</span>, basepos.y, texSize ) * weights[<span class="hljs-number">0</span>].z;
	color += GetPixelColor( basepos.x + <span class="hljs-number">3</span>, basepos.y, texSize ) * weights[<span class="hljs-number">0</span>].w;
	color += GetPixelColor( basepos.x + <span class="hljs-number">4</span>, basepos.y, texSize ) * weights[<span class="hljs-number">1</span>].x;
	color += GetPixelColor( basepos.x + <span class="hljs-number">5</span>, basepos.y, texSize ) * weights[<span class="hljs-number">1</span>].y;
	color += GetPixelColor( basepos.x + <span class="hljs-number">6</span>, basepos.y, texSize ) * weights[<span class="hljs-number">1</span>].z;
	color += GetPixelColor( basepos.x + <span class="hljs-number">7</span>, basepos.y, texSize ) * weights[<span class="hljs-number">1</span>].w;

	color += GetPixelColor( basepos.x - <span class="hljs-number">1</span>, basepos.y, texSize ) * weights[<span class="hljs-number">0</span>].y;
	color += GetPixelColor( basepos.x - <span class="hljs-number">2</span>, basepos.y, texSize ) * weights[<span class="hljs-number">0</span>].z;
	color += GetPixelColor( basepos.x - <span class="hljs-number">3</span>, basepos.y, texSize ) * weights[<span class="hljs-number">0</span>].w;
	color += GetPixelColor( basepos.x - <span class="hljs-number">4</span>, basepos.y, texSize ) * weights[<span class="hljs-number">1</span>].x;
	color += GetPixelColor( basepos.x - <span class="hljs-number">5</span>, basepos.y, texSize ) * weights[<span class="hljs-number">1</span>].y;
	color += GetPixelColor( basepos.x - <span class="hljs-number">6</span>, basepos.y, texSize ) * weights[<span class="hljs-number">1</span>].z;
	color += GetPixelColor( basepos.x - <span class="hljs-number">7</span>, basepos.y, texSize ) * weights[<span class="hljs-number">1</span>].w;

	uint pixelIndex = GetPixelIndexFromXYCoord( DTid.x, DTid.y, xBlurTexSize.x);
	outputImage[pixelIndex] = PackedFloat4ToRGBA32(color);
}
</div></code></pre>
<h4 id="step-11-y%E3%83%96%E3%83%A9%E3%83%BC%E3%82%92%E5%AE%9F%E8%A3%85">step-11 Yブラーを実装</h4>
<p> 続いてYブラーです。YブラーはXブラーをかけた画像に対して行っています。基準テクセルから上下に８テクセルの合計１６テクセルをブレンディングしていきます。リスト15.20のプログラムを入力してください。</br>
[リスト 15.20 sample.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-11 Yブラーを実装。</span>
[numthreads(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">YBlur</span><span class="hljs-params">(uint3 DTid : SV_DispatchThreadID)</span>
</span>{
	uint2 basepos = uint2( DTid.x, DTid.y * <span class="hljs-number">2</span>);

	float4 color = GetPixelColor( basepos.x, basepos.y, xBlurTexSize ) * weights[<span class="hljs-number">0</span>].x;
	color += GetPixelColor( basepos.x, basepos.y + <span class="hljs-number">1</span>, xBlurTexSize ) * weights[<span class="hljs-number">0</span>].y;
	color += GetPixelColor( basepos.x, basepos.y + <span class="hljs-number">2</span>, xBlurTexSize ) * weights[<span class="hljs-number">0</span>].z;
	color += GetPixelColor( basepos.x, basepos.y + <span class="hljs-number">3</span>, xBlurTexSize ) * weights[<span class="hljs-number">0</span>].w;
	color += GetPixelColor( basepos.x, basepos.y + <span class="hljs-number">4</span>, xBlurTexSize ) * weights[<span class="hljs-number">1</span>].x;
	color += GetPixelColor( basepos.x, basepos.y + <span class="hljs-number">5</span>, xBlurTexSize ) * weights[<span class="hljs-number">1</span>].y;
	color += GetPixelColor( basepos.x, basepos.y + <span class="hljs-number">6</span>, xBlurTexSize ) * weights[<span class="hljs-number">1</span>].z;
	color += GetPixelColor( basepos.x, basepos.y + <span class="hljs-number">7</span>, xBlurTexSize ) * weights[<span class="hljs-number">1</span>].w;

	color += GetPixelColor( basepos.x, basepos.y - <span class="hljs-number">1</span>, xBlurTexSize ) * weights[<span class="hljs-number">0</span>].y;
	color += GetPixelColor( basepos.x, basepos.y - <span class="hljs-number">2</span>, xBlurTexSize ) * weights[<span class="hljs-number">0</span>].z;
	color += GetPixelColor( basepos.x, basepos.y - <span class="hljs-number">3</span>, xBlurTexSize ) * weights[<span class="hljs-number">0</span>].w;
	color += GetPixelColor( basepos.x, basepos.y - <span class="hljs-number">4</span>, xBlurTexSize ) * weights[<span class="hljs-number">1</span>].x;
	color += GetPixelColor( basepos.x, basepos.y - <span class="hljs-number">5</span>, xBlurTexSize ) * weights[<span class="hljs-number">1</span>].y;
	color += GetPixelColor( basepos.x, basepos.y - <span class="hljs-number">6</span>, xBlurTexSize ) * weights[<span class="hljs-number">1</span>].z;
	color += GetPixelColor( basepos.x, basepos.y - <span class="hljs-number">7</span>, xBlurTexSize ) * weights[<span class="hljs-number">1</span>].w;

	uint pixelIndex = GetPixelIndexFromXYCoord( DTid.x, DTid.y, yBlurTexSize.x);
	outputImage[pixelIndex] = PackedFloat4ToRGBA32(color);
}

</div></code></pre>
<h4 id="step-12-%E6%9C%80%E7%B5%82%E5%87%BA%E5%8A%9B%E3%82%92%E5%AE%9F%E8%A3%85">step-12 最終出力を実装</h4>
<p> いよいよ最後です。最後はYブラーをかけた画像にバイリニアフィルタをかけて、元画像の解像度にアップサンプリングしています。リスト15.21のプログラムを入力してください。</br>
[リスト 15.21 sample.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-12 最終出力を実装</span>
[numthreads(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Final</span><span class="hljs-params">(uint3 DTid : SV_DispatchThreadID)</span>
</span>{
	<span class="hljs-comment">//バイリニアフィルタをかける。</span>
	uint2 basepos = uint2( DTid.x / <span class="hljs-number">2</span>, DTid. y /<span class="hljs-number">2</span> );
	float4 color = GetPixelColor( basepos.x, basepos.y, yBlurTexSize );
	color += GetPixelColor( basepos.x, basepos.y + <span class="hljs-number">1</span>, yBlurTexSize );
	color += GetPixelColor( basepos.x + <span class="hljs-number">1</span>, basepos.y, yBlurTexSize );
	color += GetPixelColor( basepos.x + <span class="hljs-number">1</span>, basepos.y + <span class="hljs-number">1</span>, yBlurTexSize );

	<span class="hljs-comment">//加重平均を取る。</span>
	color /= <span class="hljs-number">4.0f</span>;
	uint pixelIndex = GetPixelIndexFromXYCoord( DTid.x, DTid.y, texSize.x);
	outputImage[pixelIndex] = PackedFloat4ToRGBA32(color);
}
</div></code></pre>
<h4 id="step-13-%E5%AE%9F%E8%A1%8C">step-13 実行</h4>
<p>ここまで実装できたら実行して見てください。Assets/imageフォルダの中にblur.bmpという図15.8のような画像が出来上がっていたら完成です。</br>
<strong>図15.8</strong></br>
<img src="fig/15.8.bmp" width="400"></img></br></p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h1 id="chapter-16-tile-based-renderingtbr">Chapter 16 Tile based rendering(TBR)</h1>
<lead>
このチャプターでは、大量の動的光源を高速に扱うためのTile based rendering(以下TBR)についてみてきましょう。今回のTBRの実装にはコンピュートシェーダーを使用します。
<l/ead>
<!-- この内容は後でライティング発展に移動させる. -->
<h2 id="161-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88">16.1　ポイントライト</h2>
<p> 光源が多くなると処理が重くなるというのは、昔からの問題なのですが、その中でももっとも話題に上がるのはポイントライトだったと思います。ポイントライトとは位置、カラー、減衰率を持っているライトです。図16.1のような豆電球を想像すると分かりやすいと思います。</br>
<strong>図16.1</strong></br></p>
<!-- ネットから拾ってきた図です。差し替えをお願いします。 -->
<p><img src="fig/15.9.jpg" width="200"></img></br></p>
<p> プログラム的には下記のようなデータとして扱われます。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PointLight</span>{</span>
	Vector3 position;	<span class="hljs-comment">//位置</span>
	Vector3	color;		<span class="hljs-comment">//ライトのカラー</span>
	Vector4 attn;		<span class="hljs-comment">//減衰用のパラメータ	</span>
};
</div></code></pre>
<p> positionはポイントライトの座標、colorはライトのカラーで光の三原色として扱われます。attnは光の減衰のためのパラーメータです。ポイントライトはサーフェイスとの距離に応じて、光の影響が弱くなるので、減衰のためのパラメータも必要になります。多くの場合でポイントライトが影響を与える範囲などが入っています。【以前の章を入れる】で勉強したディレクションライトは位置情報はなく、ある特定の方向のみを持つライトのディレクションライトです。ですた、ポイントライトはディレクションライトとは異なり、位置情報を持っています。また、光を特定の方向のみではなく全方位に放射しています。</p>
<h3 id="1612-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%81%A7%E3%83%A9%E3%83%B3%E3%83%90%E3%83%BC%E3%83%88%E6%8B%A1%E6%95%A3%E5%8F%8D%E5%B0%84">16.1.2 ポイントライトでランバート拡散反射</h3>
<p> 【以前の章】で材質が荒いマテリアルでおきる光の反射である拡散反射を学びました。そこでは拡散反射を計算するための簡易的なライティングモデルのランバート拡散反射を勉強しました。ランバート拡散反射の強さは入射する光の方向と、面の法線で求めることができます。ディレクションライトではライトの方向と面の法線とで内積を計算することで拡散反射の強さを計算していました。(図16.2)</br>
<strong>図16.2</strong></br>
<img src="fig/15.10.png" width="300"></img></br>
 ポイントライトでランバート拡散反射を計算する場合も、考え方はディレクションライトの場合と同じです。光の影響を計算したい面に入射してくる光の方向と、面の法線の内積を求めることで、反射の強さを計算します。面の法線はディレクションライトの場合と同じなので、考える必要はありません。考える必要があるのは入射してくる光の方向です。光の方向は次の計算で求めることができます。</br>
$$ 光が入射するサーフェイスの座標　－　ポイントライトの座標 $$</p>
<p><strong>図16.3</strong></br>
<img src="fig/15.11.png" width="300"></img></br>
 入射してくる光の方向を計算することができたら、次は光の方向と逆向きのベクトルと面の法線とで内積を取って、反射する光の強さを計算します。</br>
$$ 光の強さ = dot( -光の方向, 面の法線 ) $$
これはディレクションライトの章で勉強したランバート拡散反射と同じです。ただし、ポイントライトはここからサーフェイスとライトの距離に応じて強さが変化していきます。では、指定した距離を超えたらライトの強さが0になる計算式を見てみましょう。今回はライトとの距離が50を超えたら、影響率が0になるとします。</br>
$$ ライトの影響率 = 1 - ライトまでの距離 ÷ 50(指定された距離) $$
 この計算式の結果を表でまとめてみましょう。</br></p>
<table>
<thead>
<tr>
<th>ライトまでの距離</th>
<th>計算式</th>
<th>影響率</th>
<th>コメント</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1 - 0 ÷ 50</td>
<td>1</td>
<td>影響率が1.0なので、ライトの影響を完全に受ける</td>
</tr>
<tr>
<td>10</td>
<td>1 - 10 ÷ 50</td>
<td>0.8</td>
<td>影響率が0.8なので、ライトの影響を80%受ける</td>
</tr>
<tr>
<td>25</td>
<td>1 - 25 ÷ 50</td>
<td>0.5</td>
<td>影響率が0.5なので、ライトの影響を50%受ける</td>
</tr>
<tr>
<td>50</td>
<td>1 - 50 ÷ 50</td>
<td>0.0</td>
<td>影響率が0.0なので、ライトの影響は全く受けない</td>
</tr>
</tbody>
</table>
<p> この計算式で求めた影響率をライトの強さに乗算することで、サーフェイスに入射したポイントライトの強さを求めることができます。では、ここまでのまとめとしてポイントライトの強さを求める疑似コードを示します。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PointLight</span>{</span>
	float3 pos;
	float3 color;
	<span class="hljs-keyword">float</span> range;
};
PointLight pointLig : <span class="hljs-keyword">register</span>( b0 );

<span class="hljs-comment">//ピクセルシェーダー。</span>
<span class="hljs-comment">//psIn.worldPosはサーフェイスのワールド座標。</span>
<span class="hljs-comment">//psIn.normalはサーフェイスの法線。</span>
<span class="hljs-function">float4 <span class="hljs-title">PSMain</span><span class="hljs-params">( PSIn psIn )</span>
</span>{
	　　・
	　　・
	　　・
	<span class="hljs-comment">//１. 光源からサーフェイスに入射するベクトルを求める。</span>
	<span class="hljs-keyword">float</span> ligDir = normalize( psIn.pos - pointLig.pos );
	<span class="hljs-comment">//２. 光源からサーフェイスまでの距離を求める。</span>
	<span class="hljs-keyword">float</span> distance = length( psIn.pos - pointLig.pos );
	<span class="hljs-comment">//３. 内積を使って反射の強さを計算する。(ランバート拡散反射)</span>
	<span class="hljs-keyword">float</span> t = max( <span class="hljs-number">0.0f</span>, dot( -ligDir , psIn.normal ) );
	<span class="hljs-comment">//４. 影響率を計算する。影響率は0.0～1.0の範囲で、</span>
	<span class="hljs-comment">//　  指定した距離(pointsLights[i].range)を超えたら、影響率は0.0になる。</span>
	<span class="hljs-keyword">float</span> affect = <span class="hljs-number">1.0f</span> - min( <span class="hljs-number">1.0f</span>, distance / pointLig.range );
　　<span class="hljs-comment">//５. 最終的にサーフェイスが受けるライトの影響を計算する。</span>
	float3 lig = pointLig.color * t * affect;
	    ・
		・
		・
}
</div></code></pre>
<h3 id="1613-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%82%92%E5%AE%9F%E8%A3%85">16.1.3 【ハンズオン】ポイントライトを実装</h3>
<p> では、Sample_15_04を利用してポイントライトを実装していきましょう。</p>
<h4 id="step-1-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E6%A7%8B%E9%80%A0%E4%BD%93%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">step-1 ポイントライト構造体を定義する。</h4>
<p> まず、ポイントライト構造体を定義します。main.cppにリスト16.1のプログラムを入力してください。</bf>
[リスト16.1 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 ポイントライト構造体を定義する。</span>
<span class="hljs-comment">//ポイントライト構造体。</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SPointLight</span> {</span>
	Vector3 position;	<span class="hljs-comment">//座標。</span>
	<span class="hljs-keyword">float</span> pad0;			<span class="hljs-comment">//パディング</span>
	Vector3 color;		<span class="hljs-comment">//ライトのカラー</span>
	<span class="hljs-keyword">float</span> range;		<span class="hljs-comment">//ライトの影響を与える範囲。</span>
};
</div></code></pre>
<h4 id="step-2-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E6%95%B0%E3%82%92%E8%A1%A8%E3%81%99%E5%AE%9A%E6%95%B0%E3%82%92%E5%AE%9A%E7%BE%A9">step-2 ポイントライトの数を表す定数を定義。</h4>
<p> 続いて、ポイントライトの数を定義します。main.cppにリスト16.2のプログラムを入力して下さい。</br>
[リスト16.2 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-2 ポイントライトの数を表す定数を定義。</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NUM_POINT_LIGHT = <span class="hljs-number">16</span>;
</div></code></pre>
<h4 id="step-3-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%82%92%E3%83%A9%E3%83%B3%E3%83%80%E3%83%A0%E3%81%AA%E4%BD%8D%E7%BD%AE%E3%81%A8%E3%82%AB%E3%83%A9%E3%83%BC%E3%81%A7%E5%88%9D%E6%9C%9F%E5%8C%96%E3%81%99%E3%82%8B">step-3 ポイントライトをランダムな位置とカラーで初期化する。</h4>
<p> 次は、ポイントライトを初期化します。今回は16個のポイントライトを使用するので、配列を利用しています。リスト16.3のプログラムを入力して下さい。</br>
[リスト16.3 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 ポイントライトをランダムな位置とカラーで初期化する。</span>
SPointLight pointLights[NUM_POINT_LIGHT];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pt : pointLights) {
	pt.position.x = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(random() % <span class="hljs-number">1000</span>) - <span class="hljs-number">500.0f</span>;
	pt.position.y = <span class="hljs-number">20.0f</span>; <span class="hljs-comment">//高さは20固定。</span>
	pt.position.z = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(random() % <span class="hljs-number">1000</span>) - <span class="hljs-number">500.0f</span>;
	pt.range = <span class="hljs-number">50.0f</span>;		<span class="hljs-comment">//影響範囲も50で固定しておく。</span>
	pt.color.x = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(random() % <span class="hljs-number">255</span>) / <span class="hljs-number">255.0f</span>;
	pt.color.y = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(random() % <span class="hljs-number">255</span>) / <span class="hljs-number">255.0f</span>;
	pt.color.z = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">float</span>&gt;(random() % <span class="hljs-number">255</span>) / <span class="hljs-number">255.0f</span>;
}
</div></code></pre>
<h4 id="step-4-%E8%A1%A8%E7%A4%BA%E3%81%99%E3%82%8B%E3%83%A2%E3%83%87%E3%83%AB%E3%82%92%E5%88%9D%E6%9C%9F%E5%8C%96%E3%81%99%E3%82%8B">step-4 表示するモデルを初期化する。</h4>
<p> ポイントライトの準部ができたら、次は表示するモデルを初期化します。今回は女の子のキャラクターと洞窟を表示します。モデルを初期化するときに拡張データとして、step-3で作成したポイントライトの配列を渡しています。こうすることで、Modelクラスの内部で定数バッファが確保されて、ディスクリプタヒープに登録されます。リスト16.4のプログラムを入力してください。</br>
[リスト16.4 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 表示するモデルを初期化する。</span>
<span class="hljs-comment">//女の子のモデルを初期化。</span>
ModelInitData ladyModelInitData;
<span class="hljs-comment">//ユーザー拡張データとしてポイントライトのリストを渡す。</span>
ladyModelInitData.m_expandConstantBuffer = pointLights;
ladyModelInitData.m_expandConstantBufferSize = <span class="hljs-keyword">sizeof</span>(pointLights);
ladyModelInitData.m_tkmFilePath = <span class="hljs-string">"Assets/modelData/unityChan.tkm"</span>;
ladyModelInitData.m_fxFilePath = <span class="hljs-string">"Assets/shader/model.fx"</span>;
Model ladyModel;
ladyModel.Init(ladyModelInitData);

<span class="hljs-comment">//背景のモデルを初期化。</span>
ModelInitData bgModelInitData;
<span class="hljs-comment">//ユーザー拡張データとしてポイントライトのリストを渡す。</span>
bgModelInitData.m_expandConstantBuffer = pointLights;
bgModelInitData.m_expandConstantBufferSize = <span class="hljs-keyword">sizeof</span>(pointLights);
bgModelInitData.m_tkmFilePath = <span class="hljs-string">"Assets/modelData/bg.tkm"</span>;
bgModelInitData.m_fxFilePath = <span class="hljs-string">"Assets/shader/model.fx"</span>;
Model bgModel;
bgModel.Init(bgModelInitData);
</div></code></pre>
<h4 id="step-5-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%82%92%E6%AF%8E%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E5%9B%9E%E3%81%99">step-5 ポイントライトを毎フレーム回す。</h4>
<p> 今回は動的光源(動く光源)であることを強調するために、ポイントライトを毎フレーム動かしてみようと思います。リスト16.5のプログラムを入力してみて下さい。</br>
[リスト16.5 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-5 ポイントライトを毎フレーム回す。</span>
Quaternion qRot;
qRot.SetRotationDegY(<span class="hljs-number">1.0f</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pt : pointLights) {
	qRot.Apply(pt.position);
}
</div></code></pre>
<h4 id="step-6-%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AE%E3%83%89%E3%83%AD%E3%83%BC%E3%82%B3%E3%83%BC%E3%83%AB%E3%82%92%E5%AE%9F%E8%A1%8C">step-6 モデルのドローコールを実行。</h4>
<p> では、cpp側はこれで最後です。モデルのドローコールを実行しましょう。リスト16.6のプログラムを入力してください。</br>
[リスト16.6 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-6 モデルのドローコールを実行。</span>
ladyModel.Draw(renderContext);
bgModel.Draw(renderContext);
</div></code></pre>
<h4 id="step-7-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E6%A7%8B%E9%80%A0%E4%BD%93%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">step-7 ポイントライト構造体を定義する。</h4>
<p> cpp側が完成したので、次はシェーダー側です。シェーダー側にもポイントライト構造体を定義しましょう。Assets/shader/model.fxを開いてリスト16.7のプログラムを入力してください。</br>
[リスト16.7 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-7 ポイントライト構造体を定義する。</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SPointLight</span> {</span>
	float3 position;	<span class="hljs-comment">//座標。</span>
	float3 color;		<span class="hljs-comment">//ポイントライトのカラー。</span>
	<span class="hljs-keyword">float</span>  range;		<span class="hljs-comment">//影響を与える範囲。</span>
};
</div></code></pre>
<h4 id="step-8-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E6%95%B0%E3%82%92%E8%A1%A8%E3%81%99%E5%AE%9A%E6%95%B0%E3%82%92%E5%AE%9A%E7%BE%A9">step-8 ポイントライトの数を表す定数を定義。</h4>
<p> 続いて、シェーダー側にもポイントライトの数を表す定数を定義しましょう。model.fxにリスト16.8のプログラムを入力してください。</br>
[リスト16.8 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-8 ポイントライトの数を表す定数を定義。</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NUM_POINT_LIGHT = <span class="hljs-number">16</span>;
</div></code></pre>
<h4 id="step-9-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E5%AE%9A%E6%95%B0%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%A4%89%E6%95%B0%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">step-9 ポイントライトの定数バッファにアクセスするための変数を定義する。</h4>
<p> 続いて、ポイントライトの定数バッファにアクセスるための変数を定義しましょう。この定数バッファはModelクラスの初期化時に拡張データとして指定したものです。model.fxにリスト16.9のプログラムを入力してください。</br></p>
<p>[リスト16.9 model.fx]</p>
<pre class="hljs"><code><div>cbuffer PointLightCb : <span class="hljs-keyword">register</span>(b1){
	SPointLight pointsLights[NUM_POINT_LIGHT];
}
</div></code></pre>
<h4 id="step-10-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%81%8B%E3%82%89%E5%85%89%E3%81%AB%E3%82%88%E3%82%8B%E3%83%A9%E3%83%B3%E3%83%90%E3%83%BC%E3%83%88%E6%8B%A1%E6%95%A3%E5%8F%8D%E5%B0%84%E3%82%92%E8%A8%88%E7%AE%97">step-10 ポイントライトから光によるランバート拡散反射を計算。</h4>
<p> いよいよ最後にピクセルシェーダーにランバート拡散反射を計算するプログラムを入力しましょう。ここで入力するプログラムは[16.1.2 ポイントライトでランバート拡散反射]で示した疑似コートとよく似たコードになっています。では、model.fxにリスト１16.10のプログラムを入力してください。</br>
[リスト16.10 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_POINT_LIGHT; i++){
	<span class="hljs-comment">//１．光源からサーファイスに入射するベクトルを計算。</span>
	float3 ligDir = normalize( psIn.worldPos - pointsLights[i].position);
	<span class="hljs-comment">//２．光源からサーフェイスまでの距離を計算。</span>
	<span class="hljs-keyword">float</span> distance = length( psIn.worldPos - pointsLights[i].position );
	<span class="hljs-comment">//３．光の入射ベクトルとサーフェイスの法線で内積を取って反射の強さを計算する。</span>
	<span class="hljs-keyword">float</span> t = max( <span class="hljs-number">0.0f</span>, dot( -ligDir , psIn.normal ) );
	<span class="hljs-comment">//４．影響率を計算する。影響率は0.0～1.0の範囲で、</span>
	<span class="hljs-comment">//    指定した距離(pointsLights[i].range)を超えたら、影響率は0.0になる。</span>
	<span class="hljs-keyword">float</span> affect = <span class="hljs-number">1.0f</span> - min( <span class="hljs-number">1.0f</span>, distance / pointsLights[i].range );
	lig += pointsLights[i].color * t * affect;
} 
</div></code></pre>
<h4 id="step-11-%E5%AE%9F%E8%A1%8C">step-11 実行</h4>
<p> ここまで入力出来たら最後に実行をしてみてください。うまくいっていると図16.4のように洞窟内でポイントライトが回っているプログラムが実行できます。</br>
<strong>図16.4</strong></br>
<img src="fig/15_12.png" width="400"></img></br></p>
<h2 id="162-tile-based-deffered-rendering-tbdr">16.2 Tile based deffered rendering( TBDR )</h2>
<p> では、TBR技術の１つのTBDRについて見ていきましょう。TBDRはChapter12で勉強したディファードレンダリングの改良版です。DirectX9世代のGPUでは動的光源が増えると処理がドンドン重くなっていくという問題がありました。フォワード系に比べるとディファード系は多少マシですが、それでも限界があります。これを解決するために考えられたのが、DefferdRenderingの進化版となる、TBDRです。</p>
<h3 id="1621-%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E6%A6%82%E8%A6%81">16.2.1 アルゴリズム概要</h3>
<p> TBDRのアルゴリズムを簡単に説明すると、「スクリーンをタイル状に分割して、そのタイルに影響を与える光源のリストを作成する。そのあとで、そのタイル含まれるピクセルに影響を与える光源だけでライティングを計算する。」というものです。ポイントライトの数を増やすと処理が重くなるのは、**「全てのピクセルで全てのポイントライトとライトの影響を計算する必要がある」**という点です。16.1.3のハンズオンでピクセルシェーダーに次のようなコードを記述したと思います。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_POINT_LIGHT; i++){
	<span class="hljs-comment">//１．光源からサーファイスに入射するベクトルを計算。</span>
	float3 ligDir = normalize( psIn.worldPos - pointsLights[i].position);
	<span class="hljs-comment">//２．光源からサーフェイスまでの距離を計算。</span>
	<span class="hljs-keyword">float</span> distance = length( psIn.worldPos - pointsLights[i].position );
	<span class="hljs-comment">//３．光の入射ベクトルとサーフェイスの法線で内積を取って反射の強さを計算する。</span>
	<span class="hljs-keyword">float</span> t = max( <span class="hljs-number">0.0f</span>, dot( -ligDir , psIn.normal ) );
	<span class="hljs-comment">//４．影響率を計算する。影響率は0.0～1.0の範囲で、</span>
	<span class="hljs-comment">//    指定した距離(pointsLights[i].range)を超えたら、影響率は0.0になる。</span>
	<span class="hljs-keyword">float</span> affect = <span class="hljs-number">1.0f</span> - min( <span class="hljs-number">1.0f</span>, distance / pointsLights[i].range );
	lig += pointsLights[i].color * t * affect;
} 
</div></code></pre>
<p> このループがポイントライトの計算なのですが、この計算がすべてのピクセルで実行されます。仮に1920×1080の解像度の場合は、ピクセルの数は1920×1080=約200万になります。このとき、このゲームにポイントライトが1000個置かれていた場合、ポイントライトの計算は、ピクセル数(200万) × ポイントライトの数(1000)で約20億回計算されることとなります。これはGPUといえども厳しい数字です。そこでTBRでは、画面を図16.5のようにタイル状に分割して、各タイルごとに影響を受けるポイントライトのリストを作成することで計算量を大幅に減らす工夫がなされています。</br>
<strong>図16.5</strong></br>
<img src="fig/16.5.png" width="600"></img></br></p>
<h3 id="1622-%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E8%A9%B3%E7%B4%B0">16.2.2 アルゴリズム詳細</h3>
<p> では、アルゴリズムの詳細を見ていきましょう。TBDRのアルゴリズムは下記のような流れになります。</p>
<ol>
<li>モデル描画パスでG-Bufferを作成する。</li>
<li>スクリーンをタイル状に分割して、各タイルごとに影響を与える可能性のある光源のリストを作成する。</li>
<li>2で調べた光源のリストとG-Bufferを使用してポストエフェクト的にライティングを行っていく。</br></li>
</ol>
<p> 1と2はChapter12で勉強したディファードレンダリングと変わりありません。重要なのは2番の「スクリーンをタイル状に分割して、各タイルごとに影響を与える可能性のある光源のリストを作成する」です。２番の処理はライトカリングと呼ばれます。ライト化リングではポイントライトとタイルのあたり判定を行い、衝突している場合は影響を与えるライトの番号を調べます。</br></p>
<p><strong>図16.6</strong></br>
<img src="fig/16.6.png" width="600"></img></br></p>
<h3 id="1623-%E8%A8%88%E7%AE%97%E9%87%8F%E3%82%92%E8%AA%BF%E3%81%B9%E3%81%A6%E3%81%BF%E3%82%8B">16.2.3 計算量を調べてみる</h3>
<p> では、ライトカリングを行うことで、本当に計算量が少なくなるのか考えてみましょう。結論を先に述べておくと、図16.6のようなケースであればライトカリングを行うことで、計算量は95%削減できます。これは素晴らしい最適化です。図16.6であれば、ピクセル数が200万あるので、ポイントライトが10個設置されている場合、何も工夫をしなければ計算量は2000万回ほどになります。では、ライトカリングを行うとどうなるでしょうか。？図16.6では、画面を18×10=180個のタイルに分割しています。ここで注目してほしいのが、ほとんどのタイルがポイントライトの影響を受けていない or １つ程度のポイントライトの影響を受けているとなっています。数えてみると影響を受けているタイルは約60タイル程度です。1タイルに含まれているピクセル数は約１万ピクセルですので、ポイントライトとの計算が必要なピクセル数は約60万ピクセルとなります。そして、これらのピクセルが影響を受けるライトの数は1～2個です。つまり、図16.6のケースであれば、ライトカリングを行った場合、計算量は60万ピクセル × 1.5(1と２の中間にしています)の約90回程度となります。ライトカリングのためのタイルとポイントライトの衝突判定の計算量は1800回ですので、無視できるだけの計算量です。何も工夫をしない場合は計算量が2000万回だったのに対して、ライトカリングを行った場合は、わずか90万回になっています。これがTBDRが高速になる理由です。
 計算量のオーダーの差を表16.1にまとめていますので参照してください。</br></p>
<p><strong>表16.1</strong></br></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>ピクセル</th>
<th>ポイントライト</th>
<th>タイル</th>
<th>式</th>
<th>計算量</th>
</tr>
</thead>
<tbody>
<tr>
<td>工夫なし</td>
<td>200万</td>
<td>10</td>
<td>なし</td>
<td>200万 + 10</td>
<td>2000万回</td>
</tr>
<tr>
<td>TBDR</td>
<td>200万</td>
<td>10</td>
<td>180</td>
<td>10 × 180 +  60万 × 1.5</td>
<td>約90万回</td>
</tr>
</tbody>
</table>
<h3 id="1624-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%82%92%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%A7%E5%AE%9F%E8%A3%85">16.2.4 【ハンズオン】ポイントライトをディファードレンダリングで実装</h3>
<p> 16.1.3のハンズオンで実装したポイントライトはフォワードレンダリングで実装しました。ですが、TBDRはディファードレンダリングの進化系です。ですので、まずはポイントライトをディファードレンダリングで実装していきましょう。Sample_16_02を立ち上げてください。</p>
<h4 id="step-1-%E5%B0%84%E5%BD%B1%E7%A9%BA%E9%96%93%E3%81%A7%E3%81%AEz%E5%80%A4%E3%82%92%E5%87%BA%E5%8A%9B%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AEg-buffer%E3%82%92%E4%BD%9C%E6%88%90">step-1 射影空間でのZ値を出力するためのG-Bufferを作成。</h4>
<p> ポイントライトを実装するためにはピクセルのワールド座標のデータをG-Bufferに出力する必要があります。しかし、今回のハンズオンではワールド座標を出力するためのG-Bufferは追加しません。代わりに射影空間でのZ値を出力するG-Bufferを追加します。理由としては、ワールド座標は射影空間のZ値から計算することができることと、TBDRの実装で射影空間でのZ値を利用するからです。また、射影空間でのZ値は、被写界深度、SSAO、SSRなど様々なポストエフェクトで利用されるため、ワールド座標のG-Bufferを用意せずに、Z値のG-Bufferで代用している実装がポピュラーであるように思います。では、main.cppにリスト16.11のプログラムを入力してください。</br>
[リスト16.11 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 射影空間でのZ値を出力するためのG-Bufferを作成。</span>
RenderTarget depthRT;
depthRT.Create(
	FRAME_BUFFER_W,
	FRAME_BUFFER_H,
	<span class="hljs-number">1</span>,
	<span class="hljs-number">1</span>,
	DXGI_FORMAT_R32_FLOAT,
	DXGI_FORMAT_UNKNOWN
);
</div></code></pre>
<h4 id="step-2-rendergbuffer%E3%81%AE%E3%83%91%E3%82%B9%E3%81%AE%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%82%BF%E3%83%BC%E3%82%B2%E3%83%83%E3%83%88%E3%81%ABdepthrt%E3%82%92%E8%BF%BD%E5%8A%A0">step-2 RenderGBufferのパスのレンダリングターゲットにdepthRTを追加。</h4>
<p> では、続いてstep-1で作成したdepthRTをG-Buffer作成時のレンダリングターゲットとして追加します。リスト16.12のプログラムを入力してください。</br>
[リスト16.12 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-2 RenderGBufferのパスのレンダリングターゲットにdepthRTを追加</span>
&amp;depthRT		<span class="hljs-comment">//2番目のレンダリングターゲット</span>

</div></code></pre>
<h4 id="step-3-%E3%83%87%E3%82%A3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%89%E3%83%A9%E3%82%A4%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%82%92%E8%BF%BD%E5%8A%A0">step-3 ディファードライティングで使用するテクスチャを追加。</h4>
<p> cpp側の最後のハンズオンとして、depthRTのテクスチャをディファードライティング時に使用するテクスチャとして追加しましょう。リスト16.13のプログラムを入力してください。</br>
[リスト16.13 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 ディファードライティングで使用するテクスチャを追加。</span>
spriteInitData.m_textures[<span class="hljs-number">2</span>] = &amp;depthRT.GetRenderTargetTexture();
</div></code></pre>
<h4 id="step-4-rendergbuffer%E3%83%91%E3%82%B9%E3%81%AE%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%AE%E5%87%BA%E5%8A%9B%E3%81%AB%E6%B7%B1%E5%BA%A6%E5%80%A4%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B">step-4 RenderGBufferパスのピクセルシェーダーの出力に深度値を追加する。</h4>
<p> 続いてG-Buffer作成のシェーダーを改造します。まずは、ピクセルシェーダーの出力構造体を改造して、２番目のレンダリングターゲットに深度値を出力できるようにします。Assets/shader/renderGBuffer.fxを開いてリスト16.14のプログラムを入力してください。</br>
[リスト16.14 renderGBuffer.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 RenderGBufferパスのピクセルシェーダーの出力に深度値を追加する。</span>
<span class="hljs-keyword">float</span> depth		: SV_Target2;	<span class="hljs-comment">//深度値。</span>
</div></code></pre>
<h4 id="step-5-%E5%B0%84%E5%BD%B1%E7%A9%BA%E9%96%93%E3%81%A7%E3%81%AEz%E5%80%A4%E3%82%92%E5%87%BA%E5%8A%9B%E3%81%99%E3%82%8B">step-5 射影空間でのZ値を出力する。</h4>
<p> では、RenderGBufferの最後のハンズオンです。ピクセルシェーダーを変更して、射影空間でのZ値を出力できるようにしましょう。SV_Positionセマンティクスの座標はピクセルシェーダーに渡された時点て射影空間に変換されているので、そのZ値をそのまま出力するだけです。リスト16.15のプログラムを入力してください。</br>
[リスト16.15 renderGBuffer.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-5 射影空間でのZ値を出力する。</span>
psOut.depth = psIn.pos.z;
</div></code></pre>
<h4 id="step-6-%E6%B7%B1%E5%BA%A6%E3%83%86%E3%82%AF%E3%82%B9%E3%83%81%E3%83%A3%E3%81%AE%E8%BF%BD%E5%8A%A0">step-6 深度テクスチャの追加。</h4>
<p> 続いて、ディファードライティングのピクセルシェーダーを改造します。まずはt2レジスタに設定されている深度テクスチャにアクセスするための変数を追加します。Assets/shader/defferedLighting.fxを開いてリスト16.16のプログラムを入力してください。</br>
[リスト16.16 defferedLighting.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-6 深度テクスチャの追加。</span>
Texture2D&lt;<span class="hljs-keyword">float</span>&gt; depthTexture : <span class="hljs-keyword">register</span>(t2);	<span class="hljs-comment">//射影空間に正規化された深度値。</span>
</div></code></pre>
<h4 id="step-7-%E5%B0%84%E5%BD%B1%E7%A9%BA%E9%96%93%E3%81%AE%E6%B7%B1%E5%BA%A6%E5%80%A4%E3%81%8B%E3%82%89%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E5%BA%A7%E6%A8%99%E3%82%92%E5%BE%A9%E5%85%83%E3%81%99%E3%82%8B">step-7 射影空間の深度値からワールド座標を復元する。</h4>
<p> 続いて、ピクセルシェーダー本体の改造を行います。まずは、ピクセルの射影空間での深度値をテクスチャから引っ張ってきて、ワールド座標を復元します。ワールド座標への復元の説明は数学的な話になりすぎるため、本書では詳細な説明は省かせていただきますが、ワールド空間から射影空間に変換する行列の逆行列を乗算することで、ワールド座標に復元しています。復元するプログラムの詳細が知りたい方は、defferedLighting.fxに記述されているCalcWorldPosFromUVZ関数の中身を調べてください。では、リスト16.17のプログラムを入力してください。</br>
[リスト16.17 defferedLighting.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-7 射影空間の深度値からワールド座標を復元する。</span>
<span class="hljs-keyword">float</span> z = depthTexture.Sample( Sampler, In.uv );
float3 worldPos = CalcWorldPosFromUVZ( In.uv, z, mViewProjInv);		
</div></code></pre>
<h4 id="step-8-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%82%92%E8%A8%88%E7%AE%97">step-8 ポイントライトを計算。</h4>
<p> では、最後のハンズオンです。G-Bufferの情報を元にポイントライトの計算を行います。リスト16.18のプログラムを入力してください。</br>
[リスト16.18 defferedLighting.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> ligNo = <span class="hljs-number">0</span>; ligNo &lt; NUM_POINT_LIGHT; ligNo++ ){
	<span class="hljs-comment">//拡散反射を計算</span>
	<span class="hljs-comment">//光源からサーファイスに入射するベクトルを計算。</span>
	float3 ligDir = normalize( worldPos - pointLight[ligNo].position);
	<span class="hljs-comment">//光源からサーフェイスまでの距離を計算。</span>
	<span class="hljs-keyword">float</span> distance = length( worldPos - pointLight[ligNo].position );
	<span class="hljs-comment">//影響率を計算する。影響率は0.0～1.0の範囲で、</span>
	<span class="hljs-comment">//    指定した距離(pointsLights[i].range)を超えたら、影響率は0.0になる。</span>
	<span class="hljs-keyword">float</span> affect = <span class="hljs-number">1.0f</span> - min( <span class="hljs-number">1.0f</span>, distance / pointLight[ligNo].range );
	<span class="hljs-comment">//拡散反射光を加算。</span>
	lig += CalcLambertReflection(
		ligDir, 
		pointLight[ligNo].color,
		normal ) * affect;

	<span class="hljs-comment">//スペキュラ反射を加算。</span>
	lig += CalcSpecularReflection(
		ligDir,
		pointLight[ligNo].color,
		normal,
		toEye
	) * affect;
}
</div></code></pre>
<h4 id="step-9-%E5%AE%9F%E8%A1%8C">step-9 実行</h4>
<p> ここまで入力出来���ら���後に実行をしてみてください。うまくいっていると図16.7のように洞窟内で1000個のポイントライトが回っているプログラムが実行できます。</br></p>
<p><strong>図16.7</strong></br>
<img src="fig/16.7.png" width="600"></img></br></p>
<h3 id="1625-%E3%83%A9%E3%82%A4%E3%83%88%E3%82%AB%E3%83%AA%E3%83%B3%E3%82%B0">16.2.5 ライトカリング</h3>
<p> 16.2.4はシンプルなディファードレンダリングでの実装だったので、1000個ものポイントライトを設置すると処理落ちが発生していました。では、いよいよTBRのキモのライトカリングについて見ていきましょう。ライトカリングでは、カメラの視錐台を図16.8のようにタイルの数で分割します。</br>
<strong>図16.8</strong></br>
<img src="fig/16.8.png" width="600"></img></br>
 タイルの数分だけ作られた小さな視錐台とポイントライトの距離を計算して、その距離が影響を受ける範囲であれば、そのポイントライトは、タイル内のピクセルに影響を与えると判断します。視錐台とポイントライトの距離の計算は平面の方程式を利用して求めることができます。本書は数学の本ではないので詳細は割愛しますが、視錐台を構成する6つの平面と、ポイントライトの座標を使って、平面の方程式を解くだけで距離を求めることができます。難しそうに感じるかもしれませんが、平面の法線とポイントライトの座標とで内積を計算しているだけです。6つの平面のうちどれか一つでも、影響を受ける範囲に入っていれば影響リストに積まれます。ライトカリングでディスパッチされる、１スレッドグループのスレッド数はタイルに含まれるピクセルの数です。このスレッドで分担して、ポイントライトと視錐台の衝突判定を行います。例えば、タイルに含まれるピクセルの数が100、ポイントライトの数が1000であれば、１つのスレッドは10個のポイントライトと視錐台の衝突判定を計算することになります。</br>
 ライトカリングで、ポイントライトの影響リストが作成出来たら、後はディファードレンダリングで影響リストを参照して、必要な分だけのポイントライトの計算を行います。ディファードライティングのピクセルシェーダーでは、各ピクセルがどのタイルに属しているか計算して、そのタイルの影響リストを使って、ライティングの計算を行っていきます。</p>
<h3 id="1626-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3tbdr%E3%82%92%E5%AE%9F%E8%A3%85">16.2.6 【ハンズオン】TBDRを実装</h3>
<p> では、いよいよTBDRを実装していきましょう。</p>
<h4 id="step-1-%E3%83%A9%E3%82%A4%E3%83%88%E3%82%AB%E3%83%AA%E3%83%B3%E3%82%B0%E7%94%A8%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%88%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%82%92%E3%83%AD%E3%83%BC%E3%83%89">step-1 ライトカリング用のコンピュートシェーダーをロード。</h4>
<p> まずは、ライトカリング用のシェーダーをロードします。Sample_16_03を立ち上げて、main.cppの109行目にリスト16.19のプログラムを入力してください。</br>s
[リスト16.19 main.cpp]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 ライトカリング用のコンピュートシェーダーをロード。</span>
Shader csLightCulling;
csLightCulling.LoadCS(<span class="hljs-string">L"Assets/shader/lightCulling.fx"</span>, <span class="hljs-string">"CSMain"</span>);
</div></code></pre>
<h4 id="step-2-%E3%83%A9%E3%82%A4%E3%83%88%E3%82%AB%E3%83%AA%E3%83%B3%E3%82%B0%E7%94%A8%E3%81%AE%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%86%E3%83%BC%E3%83%88%E3%82%92%E5%88%9D%E6%9C%9F%E5%8C%96">step-2 ライトカリング用のパイプラインステートを初期化。</h4>
<p> 続いて、パイプラインステートを作成します。リスト16.20のプログラムを入力してください。</br>
[リスト16.20 main.cpp]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-2 ライトカリング用のパイプラインステートを初期化。</span>
PipelineState lightCullingPipelineState;
InitPipelineState(rootSignature, lightCullingPipelineState, csLightCulling);
</div></code></pre>
<h4 id="step-3-%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%94%E3%81%A8%E3%81%AE%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E7%95%AA%E5%8F%B7%E3%81%AE%E3%83%AA%E3%82%B9%E3%83%88%E5%BD%B1%E9%9F%BF%E3%83%AA%E3%82%B9%E3%83%88%E3%82%92%E5%87%BA%E5%8A%9B%E3%81%99%E3%82%8Buav%E3%82%92%E5%88%9D%E6%9C%9F%E5%8C%96">step-3 タイルごとのポイントライトの番号のリスト(影響リスト)を出力するUAVを初期化。</h4>
<p> 続いて、タイルに影響を与えるポイントライトの番号を出力するためのUAVを作成します。リスト16.21のプログラムを入力してください。</br>
[リスト16.21 main.cpp]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 タイルごとのポイントライトの番号のリスト(影響リスト)を出力するUAVを初期化。</span>
RWStructuredBuffer pointLightNoListInTileUAV;
<span class="hljs-comment">//第一引数は1要素のサイズ。</span>
<span class="hljs-comment">//1要素はポイントライトの番号なので４バイト。</span>
<span class="hljs-comment">//第二引数はバッファ全体のサイズ。</span>
<span class="hljs-comment">//1つのタイルにすべてのポイントライトが含まれる可能性があるので、</span>
<span class="hljs-comment">//1つのタイルで番号を記憶できることが可能なサイズを確保する。</span>
pointLightNoListInTileUAV.Init(
	<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>),
	MAX_POINT_LIGHT * NUM_TILE,
	<span class="hljs-literal">nullptr</span>
);
</div></code></pre>
<p>影響リストは単なるポイントライトの番号の配列です。１つのタイルに全てのライトが含まれている可能性があるため、全てを記憶することが可能なサイズの配列を確保しています。</br></p>
<h4 id="step-4-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E6%83%85%E5%A0%B1%E3%82%92%E9%80%81%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%AE%9A%E6%95%B0%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%82%92%E4%BD%9C%E6%88%90">step-4 ポイントライトの情報を送るための定数バッファを作成。</h4>
<p> ライトカリングでもポイントライトの情報が必要になるため、ライトのデータの転送先の定数バッファを作成さいます。リスト16.22のプログラムを入力してください。</br></p>
<p>[リスト16.22 main.cpp]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 ポイントライトの情報を送るための定数バッファを作成。</span>
<span class="hljs-comment">//ライトカリングのカメラ用の定数バッファを作成。</span>
LightCullingCameraData lightCullingCameraData;
lightCullingCameraData.mProj = g_camera3D-&gt;GetProjectionMatrix();
lightCullingCameraData.mProjInv.Inverse(g_camera3D-&gt;GetProjectionMatrix());
lightCullingCameraData.mCameraRot = g_camera3D-&gt;GetCameraRotation();
lightCullingCameraData.screenParam.x = g_camera3D-&gt;GetNear();
lightCullingCameraData.screenParam.y = g_camera3D-&gt;GetFar();
lightCullingCameraData.screenParam.z = FRAME_BUFFER_W;
lightCullingCameraData.screenParam.w = FRAME_BUFFER_H;
ConstantBuffer cameraParamCB;
cameraParamCB.Init(<span class="hljs-keyword">sizeof</span>(lightCullingCameraData), &amp;lightCullingCameraData);

<span class="hljs-comment">//ライトカリングのライト用の定数バッファを作成。</span>
ConstantBuffer lightCB;
lightCB.Init(<span class="hljs-keyword">sizeof</span>(light), &amp;light);
</div></code></pre>
<h4 id="ste-5-%E3%83%A9%E3%82%A4%E3%83%88%E3%82%AB%E3%83%AA%E3%83%B3%E3%82%B0%E7%94%A8%E3%81%AE%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF%E3%83%92%E3%83%BC%E3%83%97%E3%82%92%E4%BD%9C%E6%88%90">ste-5 ライトカリング用のディスクリプタヒープを作成。</h4>
<p> 使用するリソースをまとめたディスクリプタヒープを作成します。ライトカリングでは、ピクセルの深度情報を送る必要があります。これは、ピクセルのワールド座標を計算する必要があるためです。リスト16.23のプログラムを入力してください。</br></p>
<p>[リスト16.23 main.cpp]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//ste-5 ライトカリング用のディスクリプタヒープを作成。</span>
DescriptorHeap lightCullingDescriptroHeap;
lightCullingDescriptroHeap.RegistShaderResource(
	<span class="hljs-number">0</span>, 
	depthRT.GetRenderTargetTexture()
);
lightCullingDescriptroHeap.RegistUnorderAccessResource(
	<span class="hljs-number">0</span>, 
	pointLightNoListInTileUAV
);
lightCullingDescriptroHeap.RegistConstantBuffer(
	<span class="hljs-number">0</span>, 
	cameraParamCB
);
lightCullingDescriptroHeap.RegistConstantBuffer(
	<span class="hljs-number">1</span>, 
	lightCB
);
lightCullingDescriptroHeap.Commit();

<span class="hljs-comment">//ポストエフェクト的にディファードライティングを行うためのスプライトを初期化。</span>
Sprite defferdLightingSpr;
InitDefferedLightingSprite(
	defferdLightingSpr, 
	gbuffers, 
	ARRAYSIZE(gbuffers), 
	light,
	pointLightNoListInTileUAV
);
</div></code></pre>
<h4 id="step-6-%E3%83%A9%E3%82%A4%E3%83%88%E3%82%AB%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%88%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%82%92%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81">step-6 ライトカリングのコンピュートシェーダーをディスパッチ。</h4>
<p> step-6でcpp側のプログラムは終了です。では、最後にコンピュートシェーダーをディスパッチしましょう。ディスパッチするスレッドグループの数はタイルの数です。リスト16.24のプログラムを入力して下さい。</br>
[リスト16.24 main.cpp]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-6 ライトカリングのコンピュートシェーダーをディスパッチ。</span>
renderContext.SetComputeRootSignature(rootSignature);
lightCB.CopyToVRAM(light);
renderContext.SetComputeDescriptorHeap(lightCullingDescriptroHeap);
renderContext.SetPipelineState(lightCullingPipelineState);
<span class="hljs-comment">//グループの数はタイルの数。</span>
renderContext.Dispatch(
	FRAME_BUFFER_W / TILE_WIDTH,
	FRAME_BUFFER_H / TILE_HEIGHT,
	<span class="hljs-number">1</span>
);
</div></code></pre>
<h4 id="step-7-%E3%82%BF%E3%82%A4%E3%83%AB%E5%86%85%E3%81%A7%E3%81%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%82%92%E6%B1%82%E3%82%81%E3%82%8B">step-7 タイル内でのインデックスを求める。</h4>
<p> 続いて、ライトカリングシェーダーを改造していきましょう。ライトカリングシェーダーはタイルに含まれているピクセルの数分だけスレッドが生成されます。ここでは、グループ内でのスレッド番号を求めています。Assets/shader/lightCulling.fxを開いて118行目からリスト16.25のプログラムを入力してください。
[リスト16.25 lightCulling.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-7 タイル内でのインデックスを求める</span>
<span class="hljs-comment">//groupThreadIdはグループ内でのスレッド番号。</span>
<span class="hljs-comment">//これを使って、グループ内でのスレッド番号を計算する。</span>
uint groupIndex = groupThreadId.y * TILE_WIDTH + groupThreadId.x;
</div></code></pre>
<h4 id="step-8-%E5%85%B1%E6%9C%89%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%92%E5%88%9D%E6%9C%9F%E5%8C%96%E3%81%99%E3%82%8B">step-8 共有メモリを初期化する。</h4>
<p> 共有メモリとは、スレッド間で共有されるメモリのことです。ここはマルチスレッドプログラムの知識がないと難しい話になってくるのですが、複数人で仕事をするうえでの共有されるデータといったイメージです。例えば、stTileNumLightsはタイルに含まれるライトの数なのですが、この数は全てのスレッドが協力して調査するため、共有メモリとなっています。では、リスト16.26のプログラムを入力してください。</br>
[リスト16.26 lightCulling.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-8 共有メモリを初期化する。</span>
<span class="hljs-keyword">if</span>(groupIndex == <span class="hljs-number">0</span>)
{
	sTileNumLights = <span class="hljs-number">0</span>;
	sMinZ = <span class="hljs-number">0x7F7FFFFF</span>;		<span class="hljs-comment">// floatの最大値</span>
	sMaxZ = <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="step-9-%E3%81%93%E3%81%AE%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%8C%E6%8B%85%E5%BD%93%E3%81%99%E3%82%8B%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%81%AE%E3%82%AB%E3%83%A1%E3%83%A9%E7%A9%BA%E9%96%93%E3%81%A7%E3%81%AE%E5%BA%A7%E6%A8%99%E3%82%92%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B">step-9 このスレッドが担当するピクセルのカメラ空間での座標を計算する。</h4>
<p> ライトカリングで一番最初に行う処理は、タイルのカメラ空間での最大深度値と最小深度値を調査することです。ですので、このスレッドが担当するピクセルのカメラ空間での座標を求める必要があります。リスト16.27のプログラムを入力してください。</br>
[リスト16.27 lightCulling.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-9 このスレッドが担当するピクセルのカメラ空間での座標を計算する。</span>
uint2 frameUV = dispatchThreadId.xy;
<span class="hljs-comment">//ビュー空間での座標を計算する。</span>
float3 posInView = ComputePositionInCamera(frameUV);
</div></code></pre>
<h4 id="step-10-%E5%85%A8%E3%81%A6%E3%81%AE%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%8C%E3%81%93%E3%81%93%E3%81%AB%E5%88%B0%E9%81%94%E3%81%99%E3%82%8B%E3%81%BE%E3%81%A7%E5%90%8C%E6%9C%9F%E3%82%92%E5%8F%96%E3%82%8B">step-10 全てのスレッドがここに到達するまで同期を取る。</h4>
<p> スレッドは並列に動作しています。なので、スレッドAはライトカリングの処理を10行目まで進めているけど、スレッドBは3行目までしか進んでいないということが起こります。しかし、場合によっては11行目以降のプログラムは、みんな揃ってスタートする必要があるという場合があります。今回のケースでは、step-11以降のプログラムでは、sMinZとsMaxZという共有メモリが確実に初期化されている必要があるため、一旦全てのスレッドの同期を取る必要があります。HLSLにはGroupMemoryBarrierWithGroupSyncというスレッドの同期をとるための関数があります。リスト16.28のプログラムを入力してください。</br>
[リスト16.28 lightCulling.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-10 全てのスレッドがここに到達するまで同期を取る</span>
GroupMemoryBarrierWithGroupSync();
</div></code></pre>
<h4 id="step-11-%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%AE%E6%9C%80%E5%A4%A7%E3%83%BB%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%E3%82%92%E6%B1%82%E3%82%81%E3%82%8B">step-11 タイルの最大・最小深度を求める。</h4>
<p> スレッドの動機が取れたので、タイルの最小・最大深度を調査してsMinZとsMaxZに記憶します。ここで、sMinZとsMaxZが共有メモリであることに注意が必要です。これもマルチスレッドに絡んだ問題になってしまうため、本書の範疇から外れるため割愛しますが、sMinZとsMaxZの値を単純なプログラムで操作すると問題が起きます。共有されているメモリであるため、メモリの内容をスレッドAが書き換えている最中に、スレッドBが書き換えるということが可能になってしまいます。そういったことが起きた時に、メモリの内容はこちらが意図したものとは異なる状態になってしまいます。そこで、共有メモリの操作にはアトミック性が保証された命令を使う必要があります。アトミック性が保証されているとは、なにかのスレッドがメモリを操作しているときに、他のスレッドはメモリを操作することができないことを保証しているものです。HLSLにはC言語のmin、maxマクロと同じ処理をアトミックに実行できる、InterlockedMin関数とInterlockedMax関数があります。ここではこの二つの関数を利用して、タイルの最大・最小深度を求めていきます。リスト16.29のプログラムを入力してください。
[リスト16.29 lightCulling.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-11 タイルの最大・最小深度を求める</span>
<span class="hljs-comment">// この処理は並列するスレッド全てで排他的に処理される</span>
InterlockedMin( sMinZ, asuint(posInView.z) );
InterlockedMax( sMaxZ, asuint(posInView.z) );
<span class="hljs-comment">// ここで同期を取ることでタイルの最大・最小深度を正しいものにする</span>
GroupMemoryBarrierWithGroupSync();

</div></code></pre>
<h4 id="step-12-%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%AE%E8%A6%96%E9%8C%98%E5%8F%B0%E3%82%92%E6%A7%8B%E6%88%90%E3%81%99%E3%82%8B%EF%BC%96%E3%81%A4%E3%81%AE%E5%B9%B3%E9%9D%A2%E3%82%92%E6%B1%82%E3%82%81%E3%82%8B">step-12 タイルの視錘台を構成する６つの平面を求める。</h4>
<p> ポイントライトとタイルのあたり判定は、タイルの視錘台を構成する６つの平面を利用して行います。step-12ではこの６つの平面を表すデータを構築します。リスト16.30のプログラムを入力して下さい。</br>
[リスト16.30 lightCulling.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-12 タイルの視錘台を構成する６つの平面を求める。</span>
float4 frustumPlanes[<span class="hljs-number">6</span>];
<span class="hljs-comment">//この関数の中で、錘台を構成する６つ平面を計算している。</span>
GetTileFrustumPlane( frustumPlanes, groupId );

</div></code></pre>
<h4 id="step-13-%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%A8%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E8%A1%9D%E7%AA%81%E5%88%A4%E5%AE%9A%E3%82%92%E8%A1%8C%E3%81%86">step-13 タイルとポイントライトの衝突判定を行う。</h4>
<p> では、step-12で作成した平面の情報を使って、ポイントライトとタイルのあたり判定を実装しましょう。リスト16.31のプログラムを入力してください。</br>
[リスト16.31 lightCulling.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-13 タイルとポイントライトの衝突判定を行う。</span>
<span class="hljs-keyword">for</span> (
	uint lightIndex = groupIndex; 	<span class="hljs-comment">//初期化式</span>
	lightIndex &lt; numPointLight; 	<span class="hljs-comment">//条件式</span>
	lightIndex += TILE_SIZE			<span class="hljs-comment">//反復式</span>
)
{
	PointLight light = pointLight[lightIndex];

	<span class="hljs-comment">// タイルとの判定</span>
	<span class="hljs-keyword">bool</span> inFrustum = <span class="hljs-literal">true</span>;
	<span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i)
	{
		<span class="hljs-comment">//ライトの座標と平面の法線とで内積を使って、ライトと平面との距離(正負あり)を計算している。</span>
		float4 lp = float4(light.positionInView, <span class="hljs-number">1.0f</span>);
		<span class="hljs-keyword">float</span> d = dot( frustumPlanes[i], lp );
		<span class="hljs-comment">//ライトと平面の距離を使って、衝突判定を行っている。</span>
		inFrustum = inFrustum &amp;&amp; (d &gt;= -light.range);
	}

	<span class="hljs-comment">// タイルと衝突している場合</span>
	<span class="hljs-keyword">if</span> (inFrustum)
	{
		<span class="hljs-comment">//衝突したポイントライトの番号を影響リストに積んでいく。</span>
		uint listIndex;
		InterlockedAdd( sTileNumLights, <span class="hljs-number">1</span>, listIndex );
		sTileLightIndices[listIndex] = lightIndex;
	}
}
<span class="hljs-comment">// ここで同期を取ると、sTileLightIndicesにタイルと衝突しているライトのインデックスが積まれている</span>
GroupMemoryBarrierWithGroupSync();
</div></code></pre>
<p> 衝突判定は実行しているスレッドで分担して処理を行っています、for文のlightIndexの初期化式と反復式を見てみてください。初期値はグループ内のスレッド番号から始まっていて、反復式ではタイルサイズ(これはスレッドの数と同じになる)を加算しています。こうすることで、スレッド番号０番のスレッドは、０番のポイントライト、２５６番のポイントライト、５１２番のポイントライトを調べていくようになります。スレッド番号１番のスレッドは、１番のポイントライト、２５７番のポイントライト、５１３番のポイントライトと調べていきます。いかがでしょうか、見事にスレッドで分担してライトを処理できています。</br>
 ループの最後にスレッドの同期をとっていることに注意してください。step-14で衝突しているライトを影響リストに詰んでいくため、全てのスレッドの衝突判定が完了している必要があります。ですので、このタイミングでスレッドの同期をとっています。</br></p>
<h4 id="step-14-%E3%83%A9%E3%82%A4%E3%83%88%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9%E3%82%92%E5%87%BA%E5%8A%9B%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%81%AB%E5%87%BA%E5%8A%9B">step-14 ライトインデックスを出力バッファに出力。</h4>
<p> 衝突しているライトの調査が終わったら、影響リストにライトの番号を記憶していきます。リストリスト16.32のプログラムを入力してください。</br></p>
<p>[リスト16.32 lightCulling.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-14 ライトインデックスを出力バッファに出力</span>
uint numCellX = (screenParam.z + TILE_WIDTH - <span class="hljs-number">1</span>) / TILE_WIDTH;
uint tileIndex = <span class="hljs-built_in">floor</span>( frameUV.x / TILE_WIDTH ) + <span class="hljs-built_in">floor</span>( frameUV.y / TILE_WIDTH ) * numCellX;
uint lightStart = numPointLight * tileIndex;
<span class="hljs-keyword">for</span> (uint lightIndex = groupIndex; lightIndex &lt; sTileNumLights; lightIndex += TILE_SIZE)
{
	rwLightIndices[lightStart + lightIndex] = sTileLightIndices[lightIndex];
}
</div></code></pre>
<p> 影響リストを作成する処理も各スレッドで分担しています。for文の初期化式と反復式を見てみてください。step-13と同じような式になっています。</br></p>
<h4 id="step-15-%E6%9C%80%E5%BE%8C%E3%81%AB%E7%95%AA%E5%85%B5%E3%82%92%E8%A8%AD%E5%AE%9A%E3%81%99%E3%82%8B">step-15 最後に番兵を設定する。</h4>
<p> 最後に影響リストの最後に番兵を設定します。step-16以降のディフェードライティングでは、番兵(0xFFFFFFFF)という値が出てくるまで、影響リストを捜査してライトの番号を取得していき、ポイントライトの計算を行うようになります。リスト16.33のプログラムを入力してください。</br>
[リスト16.33 lightCulling.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-15 最後に番兵を設定する。</span>
<span class="hljs-keyword">if</span> ((groupIndex == <span class="hljs-number">0</span>) &amp;&amp; (sTileNumLights &lt; numPointLight))
{
	<span class="hljs-comment">//-1で番兵。</span>
	rwLightIndices[lightStart + sTileNumLights] = <span class="hljs-number">0xffffffff</span>;
}
</div></code></pre>
<h4 id="step-16-%E3%81%93%E3%81%AE%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%81%8C%E5%90%AB%E3%81%BE%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%AE%E7%95%AA%E5%8F%B7%E3%82%92%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B">step-16 このピクセルが含まれているタイルの番号を計算する。</h4>
<p> 続いて、ディファードライティングのシェーダーを改造していきます。Assets/shader/defferedLighting.fxを開いて118行絵にリスト16.34のプログラムを入力してください。</br>
[リスト16.34 defferedLighting.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-16 このピクセルが含まれているタイルの番号を計算する。</span>
<span class="hljs-comment">//スクリーンをタイルで分割したときのセルのX座標を求める。</span>
uint numCellX = (screenParam.z + TILE_WIDTH - <span class="hljs-number">1</span>) / TILE_WIDTH;
<span class="hljs-comment">//タイルインデックスを計算する。</span>
uint tileIndex = <span class="hljs-built_in">floor</span>(In.pos.x / TILE_WIDTH) + <span class="hljs-built_in">floor</span>(In.pos.y / TILE_WIDTH) * numCellX;
</div></code></pre>
<p> ここでは、処理するピクセルがどのタイルに含まれているかを計算しています。</p>
<h4 id="step-17-%E3%81%93%E3%81%AE%E3%83%94%E3%82%AF%E3%82%BB%E3%83%AB%E3%81%8C%E5%90%AB%E3%81%BE%E3%82%8C%E3%82%8B%E3%82%BF%E3%82%A4%E3%83%AB%E3%81%AE%E5%BD%B1%E9%9F%BF%E3%83%AA%E3%82%B9%E3%83%88%E3%81%AE%E9%96%8B%E5%A7%8B%E4%BD%8D%E7%BD%AE%E3%81%A8%E7%B5%82%E4%BA%86%E4%BD%8D%E7%BD%AE%E3%82%92%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B">step-17 このピクセルが含まれるタイルの影響リストの開始位置と終了位置を計算する。</h4>
<p> step-16で計算した、タイル番号を使って、このタイルに影響を与えるライトの番号が記憶されている配列の開始位置と終了位置を計算します。リスト16.35のプログラムを入力してください。</br>
[リスト16.35 defferedLighting.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-17 このピクセルが含まれるタイルの影響リストの開始位置と終了位置を計算する。</span>
uint lightStart = tileIndex * numPointLight;
uint lightEnd = lightStart + numPointLight;
</div></code></pre>
<h4 id="step-18-%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%82%92%E8%A8%88%E7%AE%97">step-18 ポイントライトを計算。</h4>
<p> 影響リストの開始位置と終了位置が求まったら、後はポイントライトの番号を引っ張ってきて、番兵があらわれるまでライティングの計算を行います。リスト16.36のプログラムを入力して下さい。</br></p>
<p>[リスト16.36 defferedLighting.fx]</br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-18 ポイントライトを計算。</span>
<span class="hljs-keyword">for</span> (uint lightListIndex = lightStart; lightListIndex &lt; lightEnd; lightListIndex++) {
	uint ligNo = pointLightListInTile[lightListIndex];
	<span class="hljs-keyword">if</span> (ligNo == <span class="hljs-number">0xffffffff</span>) {
		<span class="hljs-comment">//このタイルに含まれるポイントライトはもうない。</span>
		<span class="hljs-keyword">break</span>;
	}

	<span class="hljs-comment">//拡散反射を計算</span>
	<span class="hljs-comment">//１．光源からサーファイスに入射するベクトルを計算。</span>
	float3 ligDir = normalize( worldPos - pointLight[ligNo].position);
	<span class="hljs-comment">//２．光源からサーフェイスまでの距離を計算。</span>
	<span class="hljs-keyword">float</span> distance = length( worldPos - pointLight[ligNo].position );
	<span class="hljs-comment">//３．影響率を計算する。影響率は0.0～1.0の範囲で、</span>
	<span class="hljs-comment">//    指定した距離(pointsLights[i].range)を超えたら、影響率は0.0になる。</span>
	<span class="hljs-keyword">float</span> affect = <span class="hljs-number">1.0f</span> - min( <span class="hljs-number">1.0f</span>, distance / pointLight[ligNo].range );
	<span class="hljs-comment">//４．拡散反射光を加算。</span>
	lig += CalcLambertReflection(
		ligDir, 
		pointLight[ligNo].color,
		normal ) * affect;

	<span class="hljs-comment">//スペキュラ反射を加算。</span>
	lig += CalcSpecularReflection(
		ligDir,
		pointLight[ligNo].color,
		normal,
		toEye
	) * affect;
}
</div></code></pre>
<h2 id="163-tile-based-forward-rendering-tbfr">16.3 Tile based forward rendering( TBFR )</h2>
<p> ではTBR系の勉強の最後に、TBFR(Tile based forward rendering)について見ていきましょう。TBDRのようなDeferred系のレンダリング手法は下記のようなデメリットがあります。</br></p>
<ol>
<li>半透明描画に弱い。</li>
<li>多彩なマテリアルの表現に弱い。</br>
多彩なマテリアルに対応するためには、マテリアルの情報を書き込むためのG-Bufferが必要になる。</li>
<li>G-Bufferの肥大化によるメモリ使用量の増加。</br></li>
</ol>
<p> このように、Deferred系は柔軟性が低く、特にノンフォトリアルな絵を作りたい場合は不向きな面があります。そこでforward系を改良してはどうか？という考えが生まれます。そこから生まれてきたのがTBFR(別名forward+)といわれるレンダリング手法です。</br></p>
<h2 id="1631-%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0">16.3.1 アルゴリズム</h2>
<p> TBFRもアルゴリズムの概要はTBDRと同様です。スクリーンをタイル状に分割して、コンピュートシェーダーでタイルに衝突しているライトのリストを作成します。そしてそのリストを使用して、ピクセルに当たる可能性のあるライトに対してだけライティングを計算するというものです。</br>
</br>ではアルゴリズムの詳細を見ていきましょう。TBFRはZPrepassという描画パスが必要になります。これはDeferred系でG-Bufferと同じようなものですが、深度値のみ出力する場合にZPrepassという言葉が使われます。TBFRでもライトカリングを行うためには、各タイルの視推台を作成するときに深度値が必要になります。そのため、ライトカリングを行う前に、ZPrepassというパスで深度テクスチャを作成します。TBFRの処理の流れは下記になります。</br></p>
<ol>
<li>ZPrepassで深度テクスチャを作成する。</li>
<li>コンピュートシェーダーでタイルごとのライトカリング。</li>
<li>２で作成されたライトのリストを使用してモデルを描画。(モデル描画パス)</li>
</ol>
<p>では各ステップを詳細に見ていきましょう。</br></p>
<ol>
<li>
<p>ZPrepassで深度テクスチャを作成する。</br>
Deferred系のG-Bufferの作成をイメージしてください。それの深度値を作成するだけのものがZPrepassです。</p>
</li>
<li>
<p>コンピュートシェーダーでタイルごとのライトカリング。</br>
スクリーンをタイル状に分割して、タイルと接触しているライトのリストを作成します。こちらもTBDRと同じです。ただし、TBDRではライトのリストを作成した後で、そのままコンピュートシェーダーでディファードライティングを行っていましたが、TBFRではここではライティング計算は行いません。ライトのリストを作成するだけです。</br></p>
</li>
<li>
<p>２で作成されたライトのリストを使用してモデルを描画。(モデル描画パス)</br>
モデルの描画パスです。TBFRはforward系のレンダリングですので、モデル描画パスでライティングの計算を行います。このライティングの計算の時に2で作成したライトのリストを使用します。</p>
</li>
</ol>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h2 id="1632-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3tbfr%E3%82%92%E5%AE%9F%E8%A3%85">16.3.2 【ハンズオン】TBFRを実装</h2>
<h3 id="step-1-zprepass%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%92%E4%BD%9C%E6%88%90">step-1 zprepassクラスを作成。</h3>
<p> まずZPrepassを実行するクラスを作成します。ZPrepassはG-Bufferの考え方とほとんど同じです。深度テクスチャのみを作成する処理だと考えて下さい。では、Sample_16_04を立ち上げて、main.cppの140行目にリスト16.37のプログラムを入力して下さい。</br>
[リスト16.37 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 zprepassクラスを作成。</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZPrepass</span> {</span>
<span class="hljs-keyword">private</span>:
	RenderTarget m_depthRT;	<span class="hljs-comment">//深度値を書き込むレンダリングターゲット。</span>
	Model m_ladyModel;		<span class="hljs-comment">//女の子のモデル。</span>
	Model m_bgModel;		<span class="hljs-comment">//背景モデル。</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function">RenderTarget&amp; <span class="hljs-title">GetDepthRenderTarget</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> m_depthRT;
	}
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-comment">//深度値を書き込むレンダリングターゲットを作成。</span>
		m_depthRT.Create(
			FRAME_BUFFER_W,
			FRAME_BUFFER_H,
			<span class="hljs-number">1</span>,
			<span class="hljs-number">1</span>,
			DXGI_FORMAT_R32_FLOAT,
			DXGI_FORMAT_D32_FLOAT
		);

		<span class="hljs-comment">//モデルを初期化。</span>
		ModelInitData ladyModelInitData;
		ladyModelInitData.m_tkmFilePath = <span class="hljs-string">"Assets/modelData/unityChan.tkm"</span>;
		<span class="hljs-comment">//シェーダーをZPrepass用にする。</span>
		ladyModelInitData.m_fxFilePath = <span class="hljs-string">"Assets/shader/zprepass.fx"</span>;
		m_ladyModel.Init(ladyModelInitData);

		<span class="hljs-comment">//背景のモデルを初期化。</span>
		ModelInitData bgModelInitData;
		<span class="hljs-comment">//ユーザー拡張データとしてポイントライトのリストを渡す。</span>
		bgModelInitData.m_tkmFilePath = <span class="hljs-string">"Assets/modelData/bg.tkm"</span>;
		<span class="hljs-comment">//シェーダーをZPrepass用にする。</span>
		bgModelInitData.m_fxFilePath = <span class="hljs-string">"Assets/shader/zprepass.fx"</span>;
		m_bgModel.Init(bgModelInitData);
	}
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">(RenderContext&amp; renderContext)</span>
	</span>{
		<span class="hljs-comment">//レンダリングターゲットを切り替えてドロー。</span>
		RenderTarget* rts[] = {
			&amp;m_depthRT
		};
		renderContext.WaitUntilToPossibleSetRenderTargets(<span class="hljs-number">1</span>, rts);
		<span class="hljs-comment">//レンダリングターゲットを設定。</span>
		renderContext.SetRenderTargets(<span class="hljs-number">1</span>, rts);
		<span class="hljs-comment">//レンダリングターゲットをクリア。</span>
		renderContext.ClearRenderTargetViews(<span class="hljs-number">1</span>, rts);

		m_ladyModel.Draw(renderContext);
		m_bgModel.Draw(renderContext);

		<span class="hljs-comment">//レンダリングターゲットへの書き込み待ち。</span>
		renderContext.WaitUntilFinishDrawingToRenderTargets(<span class="hljs-number">1</span>, rts);

		<span class="hljs-comment">//レンダリング先をフレームバッファに戻す。</span>
		g_graphicsEngine-&gt;ChangeRenderTargetToFrameBuffer(renderContext);
	}
};
</div></code></pre>
<h3 id="step-2-zprepass%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AE%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%81%A6%E5%88%9D%E6%9C%9F%E5%8C%96%E3%81%99%E3%82%8B">step-2 ZPrepassクラスのオブジェクトを作成して初期化する。</h3>
<p> ZPrepassクラスが作成できたので、クラスのオブジェクトを定義して初期化を行いましょう。リスト16.38のプログラムを入力してください。</br>
[リスト16.38 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-2 ZPrepassクラスのオブジェクトを作成して初期化する。</span>
ZPrepass zprepass;
zprepass.Init();
</div></code></pre>
<h3 id="step-3-zprepass%E2%87%92%E3%83%A9%E3%82%A4%E3%83%88%E3%82%AB%E3%83%AA%E3%83%B3%E3%82%B0%E2%87%92%E3%83%95%E3%82%A9%E3%83%AF%E3%83%BC%E3%83%89%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E5%AE%9F%E8%A1%8C">step-3 ZPrepass⇒ライトカリング⇒フォワードレンダリングの実行</h3>
<p> 続いてレンダリングです。TBFRでは、ZPrepass⇒ライトカリング⇒フォワードレンダリングの順番でレンダリングを行います。処理の流れをイメージしながら、リスト16.39のプログラムを入力してください。</br>
[リスト16.39 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 ZPrepass⇒ライトカリング⇒フォワードレンダリングの実行</span>
<span class="hljs-comment">//ZPrepass実行。</span>
zprepass.Draw(renderContext);

<span class="hljs-comment">//ライトカリングをディスパッチ。</span>
lightCulling.Dispatch(renderContext);

<span class="hljs-comment">//フォワードレンダリング。</span>
ladyModel.Draw(renderContext);
bgModel.Draw(renderContext);
</div></code></pre>
<h3 id="step-4-zprepass%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">step-4 ZPrepassシェーダーを実装する。</h3>
<p> step-4ではZPrepassシェーダーをすべて実装していきます。ZPrepassシェーダーは非常にシンプルなシェーダーです。頂点シェーダーでは単純な座標変換を行っているだけです。ピクセルシェーダーはピクセルのZ値を出力しているだけです。Assets/shader/zprepass.fxを開いてリスト16.40のプログラムを入力してください。</br>
[リスト16.40 zprepass.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//モデル用の定数バッファ</span>
cbuffer ModelCb : <span class="hljs-keyword">register</span>(b0){
	float4x4 mWorld;
	float4x4 mView;
	float4x4 mProj;
};

<span class="hljs-comment">//頂点シェーダーへの入力。</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SVSIn</span>{</span>
	float4 pos 		: POSITION;
};
<span class="hljs-comment">//ピクセルシェーダーへの入力。</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SPSIn</span>{</span>
	float4 pos 			: SV_POSITION;
};

<span class="hljs-comment">/// &lt;summary&gt;</span>
<span class="hljs-comment">/// モデル用の頂点シェーダーのエントリーポイント。</span>
<span class="hljs-comment">/// &lt;/summary&gt;</span>
<span class="hljs-function">SPSIn <span class="hljs-title">VSMain</span><span class="hljs-params">(SVSIn vsIn, uniform <span class="hljs-keyword">bool</span> hasSkin)</span>
</span>{
	SPSIn psIn;

	psIn.pos = mul(mWorld, vsIn.pos);	<span class="hljs-comment">//モデルの頂点をワールド座標系に変換。</span>
	psIn.pos = mul(mView, psIn.pos);	<span class="hljs-comment">//ワールド座標系からカメラ座標系に変換。</span>
	psIn.pos = mul(mProj, psIn.pos);	<span class="hljs-comment">//カメラ座標系からスクリーン座標系に変換。</span>
	<span class="hljs-keyword">return</span> psIn;
}

<span class="hljs-comment">/// &lt;summary&gt;</span>
<span class="hljs-comment">/// ピクセルシェーダーのエントリーポイント</span>
<span class="hljs-comment">/// &lt;/summary&gt;</span>
<span class="hljs-function">float4 <span class="hljs-title">PSMain</span><span class="hljs-params">( SPSIn psIn )</span> : SV_Target0
</span>{
	<span class="hljs-keyword">return</span> float4(psIn.pos.z, psIn.pos.z, psIn.pos.z, <span class="hljs-number">1.0f</span>);
}
</div></code></pre>
<h3 id="step-5-%E3%83%A9%E3%82%A4%E3%83%88%E3%82%AB%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%A7%E4%BD%9C%E6%88%90%E3%81%97%E3%81%9F%E3%83%A9%E3%82%A4%E3%83%88%E3%81%AE%E3%83%AA%E3%82%B9%E3%83%88%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%83%A9%E3%82%A4%E3%83%88%E3%82%92%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B">step-5 ライトカリングで作成したライトのリストを使って、ポイントライトを計算する。</h3>
<p> では、これで最後です。最後はフォワードレンダリングのシェーダーを改造します。やっていることはディファードライティングの時と全く同じです。ライトカリングで作成したポイントライトのリストを使って、ポイントライトの計算を行っています。では、Assets/shader/model.fxを開いて、リスト16.41のプログラムを入力してください。</br>
[リスト16.41 model.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-5 ライトカリングで作成したライトのリストを使って、ポイントライトを計算する。</span>
<span class="hljs-comment">//タイルの幅と高さ。</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> TILE_WIDTH = <span class="hljs-number">16</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> TILE_HEIGHT = <span class="hljs-number">16</span>;

<span class="hljs-comment">//スクリーンの左上を(0,0)、右下を(1,1)とする座標系に変換する。</span>
<span class="hljs-comment">//ビューポート座標系に変換する。</span>
float2 viewportPos = psIn.pos.xy;
<span class="hljs-comment">//スクリーンをタイルで分割したときのセルのX座標を求める。</span>
uint numCellX = (screenParam.z + TILE_WIDTH - <span class="hljs-number">1</span>) / TILE_WIDTH;
<span class="hljs-comment">//タイルインデックスを計算する。</span>
uint tileIndex = <span class="hljs-built_in">floor</span>(viewportPos.x / TILE_WIDTH) + <span class="hljs-built_in">floor</span>(viewportPos.y / TILE_WIDTH) * numCellX;

<span class="hljs-comment">//このピクセルが含まれるタイルのライトインデックスリストの開始位置を計算する。</span>
uint lightStart = tileIndex * numPointLight;
<span class="hljs-comment">//このピクセルが含まれるタイルのライトインデックスリストの終了位置を計算する。</span>
uint lightEnd = lightStart + numPointLight;

float3 lig = <span class="hljs-number">0.0f</span>;
float3 toEye = normalize(eyePos - psIn.worldPos.xyz);
<span class="hljs-keyword">for</span> (uint lightListIndex = lightStart; lightListIndex &lt; lightEnd; lightListIndex++) {
	uint ligNo = pointLightListInTile[lightListIndex];
	<span class="hljs-keyword">if</span> (ligNo == <span class="hljs-number">0xffffffff</span>) {
		<span class="hljs-comment">//このタイルに含まれるポイントライトはもうない。</span>
		<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-comment">//拡散反射を計算</span>
	<span class="hljs-comment">//１．光源からサーファイスに入射するベクトルを計算。</span>
	float3 ligDir = normalize( psIn.worldPos - pointLight[ligNo].position);
	<span class="hljs-comment">//２．光源からサーフェイスまでの距離を計算。</span>
	<span class="hljs-keyword">float</span> distance = length( psIn.worldPos - pointLight[ligNo].position );
	<span class="hljs-comment">//３．影響率を計算する。影響率は0.0～1.0の範囲で、</span>
	<span class="hljs-comment">//    指定した距離(pointsLights[i].range)を超えたら、影響率は0.0になる。</span>
	<span class="hljs-keyword">float</span> affect = <span class="hljs-number">1.0f</span> - min( <span class="hljs-number">1.0f</span>, distance / pointLight[ligNo].range );
	<span class="hljs-comment">//４．拡散反射光を加算。</span>
	lig += CalcLambertReflection(
		ligDir, 
		pointLight[ligNo].color,
		psIn.normal ) * affect;

	<span class="hljs-comment">//スペキュラ反射を加算。</span>
	lig += CalcSpecularReflection(
		ligDir,
		pointLight[ligNo].color,
		psIn.normal,
		toEye
	) * affect;
}
<span class="hljs-keyword">return</span> lig;
</div></code></pre>
<h3 id="step-6-%E5%AE%9F%E8%A1%8C">step-6 実行</h3>
<p> ここまでのプログラムが入力出来たら、プログラムを実行してみてください。フォワードレンダリングでも大量のポイントライトを設置しても、高いパフォーマンスを発揮できていることが確認できます。</p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h1 id="chapter-16-%E3%83%86%E3%83%83%E3%82%BB%E3%83%AC%E3%83%BC%E3%82%BF%E3%83%BC">Chapter 16 テッセレーター</h1>
<h1 id="chapter-17-%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%B3%E3%82%B0">Chapter 17 レイトレーシング</h1>
<laead>
&emsp;このチャプターでは、Playstation5などの次世代のリアルタイムCGプログラミングで重要な要素となるレイトレーシングについて見ていきます。
</lead>
<h2 id="171-%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%B3%E3%82%B0%E5%AF%BE%E5%BF%9C%E3%81%AEgpu%E3%81%AE%E7%99%BB%E5%A0%B4">17.1 レイトレーシング対応のGPUの登場</h2>
<p> レイトレーシング法とは光の伝搬をシミュレーションすることによって、とてもリアルなコンピュータグラフィックスを表現する一般的な手法の１つです。レイトレーシング法は新しい手法なわけではなく、映画などのCGの世界では昔から使われてきていた手法です。一方ゲームの世界で使われてきていた手法というのはラスタライザ法です。ラスタライザ法というのは、ポリゴンなどの3Dデータをラスタ形式に変換して画像化する手法です。これは、3Dモデルの頂点座標を頂点シェーダーでスクリーン空間に変換して、ラスタライザが塗りつぶすピクセルを決定して、そのピクセルのカラーを決定するという、ここまで皆さんが勉強してきた手法です。これがラスタライザ法と呼ばれる手法です。</br>
 レイトレーシング法はラスタライザ法では簡単には実現できない影生成、アンビエントオクルージョン、屈折、グローバルイルミネーション、映り込みといった表現ををシンプルな考え方で実装することができます。では、なぜゲームの世界ではレイトレーシング法ではなく、ラスタライザ法が使われてきたのでしょうか。答えはレイトレーシング法は非常に処理負荷が高い手法だからです。映画の世界であれば、１枚の絵を作成するのに、膨大な時間を書けることができますが、ゲームの世界では16ミリ秒～33ミリ秒で1枚の絵を作成するという非常に厳しい制約のもとで動いています。そのため、レイトレーシングをリアルタイムで行うというのは現実的なものではありませんでした。
 しかし、2018年にGPUメーカーの雄のNVIDIAがリアルタイムレイトレーシングを行うための専用プロセッサを搭載した、RTXシリーズを発表しました。そしてほぼ同時期に、リアルタイムコンピュータグラフィックスを牽引してきた、MicrosoftのDirectXからリアルタムレイトレーシングを行うためのAPIセットのDirectX Raytracingは公開されました。これより、一気にリアルタムレイトレーシングの流れが加速し、すでに多くのゲームが発売されいます。2020年末発売予定のPlayStation5も当然のようにリアルタイムレイトレーシング対応のGPUを載せています。</br></p>
<h2 id="172-%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%B3%E3%82%B0%E6%B3%95%E3%81%A8%E3%83%A9%E3%82%B9%E3%82%BF%E3%83%A9%E3%82%A4%E3%82%B6%E6%B3%95%E3%81%AE%E9%81%95%E3%81%84">17.2 レイトレーシング法とラスタライザ法の違い</h2>
<p> レイトレーシング法とラスタライザ法は全く別の手法になるため、3Dの絵を画面に表示するまでの考え方が大きく異なっていきます。例えば、ラスタライザ法でポリゴンを画面に表示しようとすると、ドローコールというGPUに対する命令を行っていました。しかし、レイトレーシング法ではドローコールというものを行う必要はありません。代わりにカメラから光線を飛ばす命令を行うことになります。しかし、頂点バッファ、インデックスバッファ、座標変換、カメラ空間などといった、多くの基本的な考え方は同じです。ラスタライザ法で3Dの絵を表示する手法を本質的に理解できていれば、全く異質の手法であるわけではないことが分かってもらえると思います。では、レイトレーシング法の詳しい手法を見ていきましょう。</br></p>
<h3 id="1721-%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E6%B3%95%E3%81%AE%E6%A6%82%E8%A6%81">17.2.1 レイトレ法の概要</h3>
<p> まず、ライティング、影、屈折、反射などを一切考えずに、レイトレーシング法で3Dグラフィックスを表現する方法について考えていきましょう。レイトレーシング法では、図17.1のようにカメラからスクリーンに交差するように光線を飛ばしていきます。この光線の数はスクリーンの画素数と同じになります。</br></p>
<p><strong>図17.1</strong></br>
<img src="fig/図17.1webから拾ってきた画像です。差し替えをお願いします。.png" width="400"></img></br></p>
<p> レイを飛ばすと、レイと3Dオブジェクトの交差判定を行います。これは線分(レイ)と三角形(ポリゴン)の交差判定です。そして、交差した場合、そのサーフェイスのカラーを決定します。決定されたカラーがピクセルのカラーになります。これを全ピクセルに対して行うことで、3DCGを画面上に表示することができます。</br></p>
<p><strong>図17.2</strong></br>
<img src="fig/図17.2webから拾ってきた画像です。差し替えをお願いします。.png" width="400"></img></br></p>
<h3 id="1722-%E3%83%8F%E3%83%B3%E3%82%BA%E3%82%AA%E3%83%B3%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E8%B6%85%E5%85%A5%E9%96%80">17.2.2 【ハンズオン】レイトレ超入門</h3>
<p> では、早速実際にプログラムを書いてレイトレを行ってみましょう。今回のサンプルはDXRが動作する必要があるため、GeForce GTX 1060 6GB以上のGPUが必要となります。Sample_17_01を立ち上げてください。</br></p>
<h4 id="step-1-%E4%BA%BA%E5%9E%8B%E3%83%A2%E3%83%87%E3%83%AB%E3%82%92%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E3%81%AB%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B">step-1 人型モデルをレイトレワールドに追加する。</h4>
<p> レイトレを行うためには、レイと３Ｄモデルのポリゴンとの交差判定を行う必要があるため、３Ｄモデルのポリゴンが登録されたレイトレワールドというものを構築する必要があります。ゲームのシーンのようなものだと考えてください。(図17.3)</br>
<strong>図17.3</strong></br>
<img src="fig/レイトレワールド.png" width="400"></img></br>
 レイトレワールドに登録するのは３Ｄモデルのポリゴン情報なので、頂点バッファやインデックスバッファといった情報です。ですので、ここまで勉強してきたラスタライザベースのモデルクラスを利用することができます。では、main.cppにリスト17.1のプログラムを入力してください。</br></p>
<p>[リスト17.1 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-1 人型モデルをレイトレワールドに追加する。</span>
<span class="hljs-comment">//まずは普通にモデルをロードする。</span>
ModelInitData humanModelInitData;
humanModelInitData.m_tkmFilePath = <span class="hljs-string">"Assets/modelData/unityChan.tkm"</span>;
Model humanModel;
humanModel.Init(humanModelInitData);

<span class="hljs-comment">//人型モデルをレイトレワールドに追加。</span>
g_graphicsEngine-&gt;RegistModelToRaytracingWorld(humanModel);
</div></code></pre>
<p> Modelクラスを利用して、人型モデルのデータをロードしています。ロードができたら、GraphicsEngine::RegistModelToRaytracingWorld関数を利用して、モデルをレイトレワールドに登録しています。この関数の中でDirectXRaytracingでレイトレワールドを構築するためのジオメトリ情報を構築しています。(後述)</p>
<h4 id="step-2-%E7%99%BB%E9%8C%B2%E3%81%95%E3%82%8C%E3%81%9F%E3%83%A2%E3%83%87%E3%83%AB%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E3%82%92%E6%A7%8B%E7%AF%89">step-2 登録されたモデルを使ってレイトレワールドを構築。</h4>
<p> モデルをレイトレワールドに登録することができたら、最後にGraphicsEngine::BuildRaytracingWorld関数を呼び出して、レイトレワールド構築します。main.cppにリスト17.2のプログラムを入力してください。</br></p>
<p>[リスト17.2 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-2 登録されたモデルを使ってレイトレワールドを構築。</span>
g_graphicsEngine-&gt;BuildRaytracingWorld(renderContext);
</div></code></pre>
<p>この関数の中で、DirectXRaytracingでレイトレ―シングを行うための各種データ構造が全て構築されています。</p>
<h4 id="step-3-%E3%83%AC%E3%82%A4%E3%82%92%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81">step-3 レイをディスパッチ。</h4>
<p> では、cpp側の最後のハンズオンです。レイトレワールドを構築することができたら、後はレイをディスパッチするだけです。main.cppにリスト17.3のプログラムを入力してください。</br></p>
<p>[リスト17.3 main.cpp]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-3 レイをディスパッチ。</span>
g_graphicsEngine-&gt;DispatchRaytracing(renderContext);
</div></code></pre>
<h4 id="step-4-%E3%83%AC%E3%82%A4%E3%81%A8%E8%A1%9D%E7%AA%81%E3%81%97%E3%81%9F%E7%82%B9%E3%81%AE%E8%89%B2%E3%82%92%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B">step-4 レイと衝突した点の色を計算する。</h4>
<p> 続いてシェーダー側のコードです。DXRでは新たにいくつかのシェーダーが追加されています。今回のサンプルでは「レイと最も近いポリゴンとの衝突した時のシェーダー」のclosesthitシェーダーと、「レイがポリゴンが衝突しなかった時のシェーダー」missシェーダーを改造していきます。step-4ではclosesthitシェーダーを改造しましょう。Assets/shader/sample.fxを開いてリスト17.4のプログラムを入力してください。</br></p>
<p>[リスト17.4 sample.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-4 レイと衝突した点の色を計算する。</span>
float3 barycentrics;
barycentrics.x = <span class="hljs-number">1.0f</span> - attribs.barycentrics.x - attribs.barycentrics.y;
barycentrics.y = attribs.barycentrics.x;
barycentrics.z = attribs.barycentrics.y;

payload.color = barycentrics;
</div></code></pre>
<p> chs関数がclosesthitシェーダーのエントリーポイントとして登録されています。chs関数の引数として渡されているBuiltInTriangleIntersectionAttributes型のattrbs変数は衝突した三角形ポリゴンの情報を持っています。attribs.barycentricsには図17.4のように三角形ポリゴンのどこに衝突したかという情報(重心座標)が入っています。</br></p>
<p><strong>図17.4</strong></br>
<img src="fig/17.4.png" width="400"></img></br></p>
<p> この重心座標は、0.0～1.0の範囲の値となっており、この後のハンズオンで実装する衝突した点の法線、UV情報などを取得する際に利用することになります。今回は重心座標をカラーとして出力しています。</br></p>
<h4 id="step-5-%E3%83%AC%E3%82%A4%E3%81%8C%E3%83%9D%E3%83%AA%E3%82%B4%E3%83%B3%E3%81%8C%E8%A1%9D%E7%AA%81%E3%81%97%E3%81%AA%E3%81%8B%E3%81%A3%E3%81%9F%E6%99%82%E3%81%AE%E3%82%AB%E3%83%A9%E3%83%BC%E3%82%92%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B">step-5 レイがポリゴンが衝突しなかった時のカラーを計算する。</h4>
<p> 最後にmissシェーダーを改造しましょう。リスト17.5のプログラムを入力してください。</br>
[リスト17.5 sample.fx]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//step-5 レイがポリゴンが衝突しなかった時のカラーを計算する。</span>
payload.color = float3(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);
</div></code></pre>
<p> 今回は赤いカラーを返すだけのシェーダーにしています。このミスシェーダーでは、例えば屋外のシーンであれば、天球マップなどのテクスチャをフェッチすることで、空を描画することができます。</br></p>
<h4 id="step-6-%E5%AE%9F%E8%A1%8C">step-6 実行</h4>
<p> ここまで実装できたらプログラムを実行してみてください。実装できていたら図17.5のようなプログラムが実行できます。</br>
<strong>図17.5</strong></br>
<img src="fig/17.5.png" width="400"></img></br></p>
<h3 id="1722-%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E3%81%AE%E6%A7%8B%E7%AF%89">17.2.2 レイトレワールドの構築</h3>
<p> さて、ピクセルの数分だけレイを飛ばして交差判定を行うためには、ゲームの世界の3Dモデルのポリゴンの情報が情報が必要となります。ポリゴンの情報はラスタライザ法と同じく、頂点バッファとインデックスバッファといった情報で表現されます。レイトレーシングでは、レイをディスパッチする前に、3Dモデルのポリゴン情報を登録して、レイトレワールドを構築しておく必要があります。DXRではレイトレワールドの構築に、Top level acceleration structure(TLAS)とBottom acceleration structure(BLAS)を使います。</br>
 TLASはインスタンス情報を扱うデータで、インスタンスのワールド行列などを保持しています。BLASは3Dモデルのジオメトリ情報を保持しています。図17.3を参照してください。</br>
<strong>図17.3</strong></br>
<img src="fig/図17.3webから拾ってきた画像です。差し替えをお願いします。.png" width="400"></img></br>
 DXRではレイをディスパッチする前に、TLASとBLASを構築して、レイトレワールドを構築することで、レイとポリゴンの交差判定を行うことができます。</p>
<h2 id="173-dxr%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%B3%E3%82%B0">17.3 DXRを使ったレイトレーシング</h2>
<p> では、いよいよDXRを使用したサンプルプログラムを使って、レイトレーシングを行う方法を見ていきましょう。まず、先述したようにレイをディスパッチするためにはレイトレワールドを構築する必要があります。今回のサンプルでは、RaytracingEngine::BuildBottomLevelAS関数でBLAS、RaytracingEngine::BuildTopLevelAS関数でTLASを構築しています。BLASは3Dモデルのポリゴン情報となります。ポリゴン情報はラスタライザ法と同じく、頂点バッファとインデックスバッファを用いて表されます。TLASはインスタンスの情報で、インスタンスをワールド空間に変換するための情報等が保持されます。インスタンスをワールド空間に変換するのもラスタライザ法と同じく、行列を使用します。レイトレワールドが構築できたら、後はレイをディスパッチするだけです。レイのディスパッチはRaytracingEngine::Dispatch関数で行われています。レイがディスパッチされると、GPUでレイトレーシング用のレンダリングパイプラインが実行されます。</br></p>
<h3 id="1731-%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%B3%E3%82%B0%E7%94%A8%E3%81%AE%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3">17.3.1 レイトレーシング用のレンダリングパイプライン</h3>
<p> CPUからレイのディスパッチコールが実行されるとされるとGPUで次のようなレイトレーシング用のレンダリングパイプラインが実行されます。</br></p>
<ol>
<li>レイを生成するレイジェネレーションシェーダーを実行</li>
<li>1で生成されたレイを使ってレイトレワールドに登録されているポリゴンとの交差判定</li>
<li>ポリゴンと交差したら登録されているヒットシェーダーを実行</li>
<li>ポリゴンと交差しなければ登録されているミスシェーダーを実行</li>
</ol>
<p>では、各ステップを詳細に見ていきましょう。</p>
<h4 id="%E3%83%AC%E3%82%A4%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B%E3%83%AC%E3%82%A4%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%A8%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%81%9F%E3%83%AC%E3%82%A4%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E3%83%AF%E3%83%BC%E3%83%AB%E3%83%89%E3%81%AB%E7%99%BB%E9%8C%B2%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%83%9D%E3%83%AA%E3%82%B4%E3%83%B3%E3%81%A8%E3%81%AE%E4%BA%A4%E5%B7%AE%E5%88%A4%E5%AE%9A">レイを生成するレイジェネレーションシェーダーと、生成されたレイを使ってレイトレワールドに登録されているポリゴンとの交差判定</h4>
<p> レイを生成するためのシェーダーです。このシェーダーはピクセルの数分だけ実行され、一本のレイを生成します。レイを作ることができたら、HLSLのTraceRay関数を呼び出します。この関数の中では登録されているポリゴンとの交差判定が実行されます。</p>
<h4 id="%E3%83%9D%E3%83%AA%E3%82%B4%E3%83%B3%E3%81%A8%E4%BA%A4%E5%B7%AE%E3%81%97%E3%81%9F%E3%82%89%E7%99%BB%E9%8C%B2%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%83%92%E3%83%83%E3%83%88%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%82%92%E5%AE%9F%E8%A1%8C">ポリゴンと交差したら登録されているヒットシェーダーを実行</h4>
<p> レイジェネレーションシェーダーで生成されたレイが何かのポリゴンと交差した場合、登録されているヒットシェーダーが呼び出されます。このシェーダーにはヒットしたポリゴンの情報が渡されます。このシェーダーで、ヒットしたポリゴンのカラーを決定することで、ピクセルのカラーが決まります。ラスタライザ法のピクセルシェーダーによく似たシェーダーになります。</p>
<h4 id="%E3%83%9D%E3%83%AA%E3%82%B4%E3%83%B3%E3%81%A8%E4%BA%A4%E5%B7%AE%E3%81%97%E3%81%AA%E3%81%91%E3%82%8C%E3%81%B0%E7%99%BB%E9%8C%B2%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%83%9F%E3%82%B9%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%82%92%E5%AE%9F%E8%A1%8C">ポリゴンと交差しなければ登録されているミスシェーダーを実行</h4>
<p> レイジェネレーションシェーダーで生成されたレイがどのポリゴンとも交差しない場合、登録されているミスシェーダーが呼び出されます。このシェーダーでキューブマップなどに設定されている天球テクスチャ等を参照することで、空を表示することができます。</p>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>
<h2 id="174-dxr%E3%81%A7%E3%83%AC%E3%82%A4%E3%83%88%E3%83%AC%E3%82%92%E8%A1%8C%E3%81%86%E3%81%9F%E3%82%81%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%AA%E3%83%87%E3%83%BC%E3%82%BF">17.4 DXRでレイトレを行うために必要なデータ</h2>
<p> DXRでレイトレを行うためには下記のデータ構造を構築する必要があります。</br></p>
<ol>
<li>Bottom Level Acceleration Structure(BLAS)</li>
<li>Top Level Acceleraration Structure(TLAS)</li>
<li>Pipeline State Object</li>
<li>Shader Table</li>
</ol>
<p>では、これらのデータ構造について詳細に見ていきましょう。</br></p>
<h3 id="1741-bottom-level-acceleration-structureblas">17.4.1 Bottom Level Acceleration Structure(BLAS)</h3>
<p> BLASは前節でも勉強したように、レイトレワールドに登録するジオメトリ情報になります。この情報をグラフィックメモリ上に構築する必要があります。BLASを作成するためには、D3D12_RAYTRACING_GEOMETRY_DESCの配列を作成する必要があります。D3D12_RAYTRACING_GEOMETRY_DESCは頂点バッファやインデックスバッファなどの情報を設定することができます。リスト17.1はD3D12_RAYTRACING_GEOMETRY_DESCの配列を作成する疑似コードを示します。</br>
[リスト17.1 D3D12_RAYTRACING_GEOMETRY_DESCの配列を作成する疑似コード] </br></p>
<pre class="hljs"><code><div><span class="hljs-comment">//ジオメトリ情報の可変長配列を定義。</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt; D3D12_RAYTRACING_GEOMETRY_DESC &gt; geometoryDescs;

<span class="hljs-comment">//登録されているモデルデータからジオメトリ情報を引っ張ってくる。</span>
<span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> modelNo = <span class="hljs-number">0</span>; modelNo &lt; m_models.size(); modelNo++ ){
	<span class="hljs-comment">//ジオメトリはマテリアル単位で別れているので、マテリアルの数分だけループを回す。</span>
	<span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> materialNo = <span class="hljs-number">0</span>; materialNo &lt; m_models.materials; materialNo++ ){
		<span class="hljs-comment">//これがレイトレ用のジオメトリ情報の構造体。</span>
		D3D12_RAYTRACING_GEOMETRY_DESC desc;
		<span class="hljs-built_in">memset</span>( &amp;desc, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>( desc );
		<span class="hljs-comment">//このジオメトリはトライアングルリスト。</span>
		desc.Type = D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES;
		<span class="hljs-comment">//変換行列はなし。</span>
		desc.Triangles.Transform3x4 = <span class="hljs-number">0</span>;
		<span class="hljs-comment">//頂点バッファの先頭アドレスを設定。</span>
		desc.Triangles.VertexBuffer.StartAddress = vertexBufferView.BufferLocation;
		<span class="hljs-comment">//1頂点のサイズを設定。</span>
		desc.Triangles.VertexBuffer.StrideInBytes = vertexBufferView.StrideInBytes;
		<span class="hljs-comment">//頂点数を設定。頂点数は、頂点バッファのサイズ÷１頂点のサイズで求まる。</span>
		desc.Triangles.VertexCount = vertexBufferView.SizeInBytes / vertexBufferView.StrideInBytes;
		<span class="hljs-comment">//頂点フォーマットを設定する。</span>
		desc.Triangles.VertexFormat = DXGI_FORMAT_R32G32B32_FLOAT;
		<span class="hljs-comment">//インデックスバッファの先頭アドレスを設定。</span>
		desc.Triangles.IndexBuffer = indexBufferView.BufferLocation;
		<span class="hljs-comment">//インデックスの数を設定。</span>
		desc.Triangles.IndexCount = mesh.m_indexBufferArray[i]-&gt;GetCount();
		<span class="hljs-comment">//インデックスバッファのフォーマットを設定。</span>
		desc.Triangles.IndexFormat = indexBufferView.Format;
		<span class="hljs-comment">//ジオメトリ情報を可変長配列にプッシュ。</span>
		geometoryDescs.push_back(desc);
	}
}
</div></code></pre>
<p> D3D12_RAYTRACING_GEOMETRY_DESCの配列を作成することができたら、その情報を元にグラフィックメモリ上にBLASを作成します。リスト17.2はDirectXのAPIを利用して、BLASを作成する疑似コードです。</br>
[リスト17.2 BLASを作成する疑似コード]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//ジオメトリ情報からグラフィックメモリ上にBLASを構築する。</span>
<span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> geometoryNo = <span class="hljs-number">0</span>; geometoryNo &lt; geometoryDescs.size(); geometoryNo++ ){
	D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS inputs;
	<span class="hljs-built_in">memset</span>( &amp;inputs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>( inputs ) ) ;
	<span class="hljs-comment">//入力されるデータは配列。</span>
	inputs.DescsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY;
	<span class="hljs-comment">//配列の要素数を設定。</span>
	inputs.NumDescs = <span class="hljs-number">1</span>;
	<span class="hljs-comment">//ジオメトリ情報のアドレスを設定。</span>
	inputs.pGeometryDescs = &amp;instance.geometoryDesc;
	<span class="hljs-comment">//今から構築するデータはBLASだということを設定する。</span>
	inputs.Type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL;
	
	<span class="hljs-comment">//BLASを作成するための準備ビルドのための情報をD3Dデバイスから取得する。</span>
	D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO info;
	d3dDevice-&gt;GetRaytracingAccelerationStructurePrebuildInfo(&amp;inputs, &amp;info);
	
	<span class="hljs-comment">//BLASを作成するためのスクラッチバッファを作成する。</span>
	<span class="hljs-comment">//スクラッチバッファは作業用のバッファといった感じ。</span>
	AccelerationStructureBuffers asbuffer;
	asbuffer.pScratch = CreateBuffer(
		d3dDevice,
		info.ScratchDataSizeInBytes,
		D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS,
		D3D12_RESOURCE_STATE_COMMON,
		kDefaultHeapProps
	);
	<span class="hljs-comment">//BLASの完成品を構築するためのバッファを作成。</span>
	asbuffer.pResult = CreateBuffer(
		d3dDevice,
		info.ResultDataMaxSizeInBytes,
		D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS,
		D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE,
		kDefaultHeapProps
	);
	
	<span class="hljs-comment">//準備が整ったので、BLASをグラフィックメモリ上に作成する。</span>
	D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC asDesc = {};
	<span class="hljs-comment">//ジオメトリ情報を渡す。</span>
	asDesc.Inputs = inputs;
	<span class="hljs-comment">//スクラッチバッファのGPU上の仮想アドレスを設定。</span>
	asDesc.DestAccelerationStructureData = asbuffer.pResult-&gt;GetGPUVirtualAddress();
	<span class="hljs-comment">//BLASの完成品を記憶するためのバッファのGPU上の仮想アドレスを設定。</span>
	asDesc.ScratchAccelerationStructureData = asbuffer.pScratch-&gt;GetGPUVirtualAddress();
	
	<span class="hljs-comment">//グラフィックメモリ上に作成</span>
	d3dDevice.BuildRaytracingAccelerationStructure(&amp;asDesc, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);
	
}
</div></code></pre>
<lead>
章扉のリード文です。
</lead>
<h3 id="1742-top-level-acceleration-structuretlas">17.4.2 Top Level Acceleration Structure(TLAS)</h3>
<p> TLASはレイトレワールドに登録するインスタンスのワールド行列、使用するヒットシェーダーのIDなどの情報です。TLASもBLASと同様にグラフィックメモリ上に構築する必要があります。リスト17.3はTLASを構築するための事前準備を行う疑似コードです。</br>
[リスト17.3 リスト17.3はTLASを構築するための事前準備を行う疑似コード]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//TLASを作成するための情報を設定する。</span>
D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS inputs = {};
<span class="hljs-comment">//作成されるデータは配列。</span>
inputs.DescsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY;
<span class="hljs-comment">//TLASは更新可能データとして作成する。</span>
inputs.Flags = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE;
<span class="hljs-comment">//配列の要素数を設定。</span>
inputs.NumDescs = m_instances.size();
<span class="hljs-comment">//作成するのはTLASであることを設定する。</span>
inputs.Type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL;

<span class="hljs-comment">//TLASを作成するための事前ビルドの情報を取得。</span>
D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO info;
d3dDevice-&gt;GetRaytracingAccelerationStructurePrebuildInfo(&amp;inputs, &amp;info);

AccelerationStructureBuffers tlasBuffers;
<span class="hljs-comment">//構築のための計算用バッファを作成。</span>
tlasBuffers.pScratch = CreateBuffer(
	d3dDevice, 
	info.ScratchDataSizeInBytes, 
	D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS, 
	D3D12_RESOURCE_STATE_UNORDERED_ACCESS, kDefaultHeapProps);
<span class="hljs-comment">//完成したTLASが記憶されるバッファを作成。</span>
tlasBuffers.pResult = CreateBuffer(
	d3dDevice, 
	info.ResultDataMaxSizeInBytes, 
	D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS, 
	D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE, 
	kDefaultHeapProps);
<span class="hljs-comment">//インスタンスデータを記録するためのバッファを作成。</span>
tlasBuffers.pInstanceDesc = CreateBuffer(
	d3dDevice, 
	<span class="hljs-keyword">sizeof</span>(D3D12_RAYTRACING_INSTANCE_DESC) * numInstance,
	D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_GENERIC_READ, 
	kUploadHeapProps
);

</div></code></pre>
<p> 計算用バッファの作成などの準備が整ったら、DirectXのAPIを使用してTLASを構築します。リスト17.4のプログラムがTLASを構築している疑似コードです。</br></p>
<p>[リスト17.4 TLASを構築している疑似コード]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//グラフィックメモリにインスタンスデータを構築する。</span>
D3D12_RAYTRACING_INSTANCE_DESC* instanceDescs;
<span class="hljs-comment">//CPUからグラフィックメモリにアクセスできるようにマップする。</span>
tlasBuffers.pInstanceDesc-&gt;Map(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, (<span class="hljs-keyword">void</span>**)&amp;instanceDescs);
ZeroMemory(instanceDescs, <span class="hljs-keyword">sizeof</span>(D3D12_RAYTRACING_INSTANCE_DESC) * numInstance);

<span class="hljs-comment">//単位行列。</span>
Matrix matIdentity;
<span class="hljs-comment">//インスタンスのデータを設定していく。</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numInstance; i++) {
	<span class="hljs-comment">//インスタンスIDを設定。</span>

	instanceDescs[i].InstanceID = i;
	<span class="hljs-comment">//instanceDescs[i].InstanceContributionToHitGroupIndex = eHitGroup_PBRCameraRay;</span>
	<span class="hljs-comment">//このインスタンスのジオメトリにレイが衝突したときに使用されるヒットシェーダーグループのインデックスを指定する。</span>
	<span class="hljs-comment">//この説明は口述します。</span>
	instanceDescs[i].InstanceContributionToHitGroupIndex = (<span class="hljs-keyword">int</span>)<span class="hljs-number">2</span>;
	instanceDescs[i].Flags = D3D12_RAYTRACING_INSTANCE_FLAG_NONE;
	<span class="hljs-comment">//対応するBLASの情報を設定する。</span>
	instanceDescs[i].AccelerationStructure = m_bottomLevelASBuffers[i].pResult-&gt;GetGPUVirtualAddress();
	<span class="hljs-comment">//変換行列を設定。これがインスタンスのワールド行列。</span>
	<span class="hljs-built_in">memcpy</span>(instanceDescs[i].Transform, &amp;matIdentity, <span class="hljs-keyword">sizeof</span>(instanceDescs[i].Transform));
	<span class="hljs-comment">//マスクを設定する。</span>
	instanceDescs[i].InstanceMask = <span class="hljs-number">0xFF</span>;
}
<span class="hljs-comment">//インスタンスデータをアンマップ。</span>
tlasBuffers.pInstanceDesc-&gt;Unmap(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);

<span class="hljs-comment">//TLASを作成。</span>
D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC asDesc = {};
<span class="hljs-comment">//入力データを設定。</span>
asDesc.Inputs = inputs;
<span class="hljs-comment">//インスタンス情報のGPU上の仮想アドレスを設定。</span>
asDesc.Inputs.InstanceDescs = m_topLevelASBuffers.pInstanceDesc-&gt;GetGPUVirtualAddress();
<span class="hljs-comment">//TLAS構築時に使用される計算用バッファの仮想アドレスを設定。</span>
asDesc.ScratchAccelerationStructureData = m_topLevelASBuffers.pScratch-&gt;GetGPUVirtualAddress();
<span class="hljs-comment">//TLASの完成品が記憶させるGPU上の仮想アドレスを設定。</span>
asDesc.DestAccelerationStructureData = m_topLevelASBuffers.pResult-&gt;GetGPUVirtualAddress();

<span class="hljs-comment">//TLASを構築</span>
rc.BuildRaytracingAccelerationStructure(&amp;asDesc, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);
</div></code></pre>
<h4 id="blas%E3%81%A8tlas%E3%81%A7%E6%A7%8B%E7%AF%89%E3%81%95%E3%82%8C%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E3%81%A8%E3%81%AF">BLASとTLASで構築されるデータとは？</h4>
<p> DirectXのAPIを利用して構築されるBLASとTLASは、単純なワールド行列やジオメトリ情報の配列というわけではありません。ここで構築されているデータ構造はレイとジオメトリの交差判定を高速に処理するためのBVHなど空間分割のデータ構造です。これは、レイトレ特有のものではなく、物理エンジンなどでも活用されているものです。空間分割に関する詳しい話は本書の主題から離れていきますので、割愛しますが、そのようなデータ構造が構築されていることは知っておくと良いかもしれません。</p>
<h3 id="1743-pipeline-state-object">17.4.3 Pipeline State Object</h3>
<p> パイプラインステートオブジェクトはレイトレ用のレンダリングパイプラインを実行するための設定が記憶されているオブジェクトです。ラスタライザ用のレンダリングパイプラインであれば、下記のような設定が記憶されていました。</p>
<ol>
<li>アルファブレンディングステート</li>
<li>深度テストステート</li>
<li>ラスタライザステート</li>
<li>使用される頂点シェーダーのバイトコード</li>
<li>使用されるピクセルシェーダーのバイトコード</li>
</ol>
<p> これらの設定はラスタライザとレイトレでは大きく異なります(そもそもレイトレにアルファブレンディングや深度テストといったものは不要になります)。レイトレ用のパイプラインステートではサブオブジェクトを作成していくという流れになります。作成する必要があるサブオブジェクトは下記になります。</p>
<p>|サブオブジェクト名|概要|
|DXIL_LIBRARY|レイトレーシング用のシェーダーのバイトコード|
|ヒットグループ|レイが交差したときに呼び出されるシェーダーグループ|
|ローカルルートシグネチャ|各種シェーダーで利用されるルートシグネチャ|
|グローバルルートシグネチャ|全てのシェーダーで使用されるルートシグネチャ|
|Export Association|シェーダーとルートシグネチャを関連付けるオブジェクト|
|シェーダー設定|Payloadのサイズや、エントリー関数の引数の数|
|パイプライン設定|レイトレースの再帰処理の深さの設定などを行う|</p>
<p> これらのサブオブジェクトを必要な数だけ作成し、それらをまとめて、パイプラインステートオブジェクトを作成します。</p>
<h4 id="dxillibrary%E3%82%B5%E3%83%96%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88">DXIL_LIBRARYサブオブジェクト</h4>
<p> DXIL_LIBRARYはシェーダーコードをこれは単にレイトレーシング用のシェーダーをコンパイルしたバイトコードを設定するだけです。リスト17.5はレイトレのシェーダーをロードしている疑似コードです。</br>
[リスト17.5 レイトレのシェーダーをロードしている疑似コード]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//レイジェネレーション、ヒット、ミスシェーダーのエントリーポイントの情報を設定。</span>
D3D12_EXPORT_DESC libExport[<span class="hljs-number">3</span>];

libExport[<span class="hljs-number">0</span>].Name = <span class="hljs-string">L"rayGen"</span>;
libExport[<span class="hljs-number">0</span>].ExportToRename = <span class="hljs-literal">nullptr</span>;
libExport[<span class="hljs-number">0</span>].Flags = D3D12_EXPORT_FLAG_NONE;

libExport[<span class="hljs-number">1</span>].Name = <span class="hljs-string">L"chs"</span>;
libExport[<span class="hljs-number">1</span>].ExportToRename = <span class="hljs-literal">nullptr</span>;
libExport[<span class="hljs-number">1</span>].Flags = D3D12_EXPORT_FLAG_NONE;

libExport[<span class="hljs-number">2</span>].Name = <span class="hljs-string">L"miss"</span>;
libExport[<span class="hljs-number">2</span>].ExportToRename = <span class="hljs-literal">nullptr</span>;
libExport[<span class="hljs-number">2</span>].Flags = D3D12_EXPORT_FLAG_NONE;
	

<span class="hljs-comment">//レイトレシェーダーをロードする。</span>
Shader raytraceShader;
raytraceShader.LoadRaytracing(<span class="hljs-string">L"Assets/shader/sample.fx"</span>);

<span class="hljs-comment">//DXIL_LIBサブオブジェクトの設定を行う。</span>
D3D12_DXIL_LIBRARY_DESC dxLibdesc;

<span class="hljs-keyword">auto</span> pBlob = raytraceShader.GetCompiledDxcBlob();
<span class="hljs-comment">//シェーダーのバイトコードのアドレスを設定。</span>
dxLibdesc.DXILLibrary.pShaderBytecode = pBlob-&gt;GetBufferPointer();
<span class="hljs-comment">//シェーダーのバイトコードのサイズを設定。</span>
dxLibdesc.DXILLibrary.BytecodeLength = pBlob-&gt;GetBufferSize();
<span class="hljs-comment">//エントリーポイントとなる関数の数を設定。</span>
dxLibdesc.NumExports = <span class="hljs-number">3</span>;
<span class="hljs-comment">//エントリーポイントを表すデータのアドレスを設定。</span>
dxLibdesc.pExports = libExport;
<span class="hljs-comment">//サブオブジェクトのタイプとしてDXIL_LIBRARYを設定する。</span>
subobjects[<span class="hljs-number">0</span>].Type = D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY;
<span class="hljs-comment">//サブオブジェクトの設定を表すデータのアドレスを代入する。</span>
subobjects[<span class="hljs-number">0</span>].pDesc = &amp;dxLibdesc;
</div></code></pre>
<h4 id="%E3%83%92%E3%83%83%E3%83%88%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%97%E3%82%B5%E3%83%96%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88">ヒットグループサブオブジェクト</h4>
<p> ヒットグループはIntersectionシェーダー、closesthitシェーダー、anyhitシェーダーをひとまとめにしたシェーダーです。これらの関数は全てシェーダー側でTraceRay関数を呼び出したときに、レイとジオメトリがヒットしたときに実行されるシェーダーです。表17.1は各種シェーダーの概要です。</br></p>
<p>|シェーダー名|概要|
|closesthitシェーダー|レイとジオメトリが交差するとき、一番近いジオメトリの情報を引数として一度だけ呼ばれる|
|anyhitシェーダー|レイとジオメトリが交差するときに毎回呼ばれる|
|Intersectionシェーダー|レイとBLASの末端ノードのAABBとの交差が発声したときに呼ばれる|
 これらのシェーダーをまとめてヒットグループと呼びます。このチャプターでは、主にclosesthitシェーダーのみ扱っていきます。closesthitシェーダーは前述したようにサーフェイスのカラーを決定するピクセルシェーダーと同じような処理が記述されます。そのため、マテリアルによって、closesthitシェーダーは変更される可能性があります。そのため、ヒットグループは複数存在する可能性があります。リスト17.6のプログラムはヒットグループサブオブジェクトを生成している疑似コードです。</br></p>
<p>[リスト17.6 ヒットグループサブオブジェクトを生成している疑似コード]</p>
<pre class="hljs"><code><div><span class="hljs-comment">//物理ベースマテリアル用のヒットグループサブオブジェクトを作成。</span>
D3D12_HIT_GROUP_DESC pbrDesc = {};
<span class="hljs-comment">//anyhitシェーダーのエントリーポイントの名前（物理ベースマテリアル）</span>
pbrDesc.AnyHitShaderImport = <span class="hljs-string">L"PbrAny"</span>;
<span class="hljs-comment">//closesthitシェーダーのエントリーポイントの名前（物理ベースマテリアル）</span>
pbrDesc.ClosestHitShaderImport = <span class="hljs-string">L"PbrChs"</span>;
<span class="hljs-comment">//intersectionシェーダーのエントリーポイントの名前（物理ベースマテリアル用）</span>
pbrDesc.IntersectionShaderImport = <span class="hljs-string">L"PbrIs"</span>;
<span class="hljs-comment">//ヒットグループの名前。</span>
pbrDesc.HitGroupExport = <span class="hljs-string">L"pbrHitGroup"</span>;
<span class="hljs-comment">//サブオブジェクトのタイプを設定。</span>
subObject[<span class="hljs-number">1</span>].Type = D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP;
<span class="hljs-comment">//サブオブジェクトの情報データのアドレスを設定。</span>
subObject[<span class="hljs-number">1</span>].pDesc = &amp;pbrDesc;

<span class="hljs-comment">//セルルックマテリアル用のヒットグループサブオブジェクトを作成。</span>
D3D12_HIT_GROUP_DESC celDesc = {};
<span class="hljs-comment">//anyhitシェーダーのエントリーポイントの名前（セルルックマテリアル）</span>
celDesc.AnyHitShaderImport = <span class="hljs-string">L"celAny"</span>;
<span class="hljs-comment">//closesthitシェーダーのエントリーポイントの名前（セルルックマテリアル）</span>
celDesc.ClosestHitShaderImport = <span class="hljs-string">L"celChs"</span>;
<span class="hljs-comment">//intersectionシェーダーのエントリーポイントの名前（セルルックマテリアル）</span>
celDesc.IntersectionShaderImport = <span class="hljs-string">L"celIs"</span>;
<span class="hljs-comment">//ヒットグループの名前。</span>
celDesc.HitGroupExport = <span class="hljs-string">L"celHitGroup"</span>;
<span class="hljs-comment">//サブオブジェクトのタイプを設定。</span>
subObject[<span class="hljs-number">2</span>].Type = D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP;
<span class="hljs-comment">//サブオブジェクトの情報データのアドレスを設定。</span>
subObject[<span class="hljs-number">2</span>].pDesc = &amp;celDesc;

</div></code></pre>
<p> TLASでインスタンスデータを構築するときに、ヒットグループの番号を設定する箇所があったと思いますが、そこで設定している番号がこのヒットグループの番号になります。リスト17.6の疑似コードであれば、物理ベースマテリアル用のヒットグループは0番、セルルックマテリアル用のヒットグループは1番になります。</p>
<h2 id="01-%E7%AF%80%E3%82%BF%E3%82%A4%E3%83%88%E3%83%AB">0.1 節タイトル</h2>
<h3 id="011-%E4%B8%AD%E8%A6%8B%E5%87%BA%E3%81%97">0.1.1 中見出し</h3>
<p>本文はそのまま。<code>int</code>などコード文字。<strong>重要語句</strong>はボールドに。</p>
<p>[リスト0.☆ ソースコード]</p>
<pre class="hljs"><code><div>test

test
{
    // コメント
}
</div></code></pre>
<p>リストにするまでもないコード片は次のように。</p>
<pre class="hljs"><code><div></div></code></pre>
<h4 id="%E5%B0%8F%E8%A6%8B%E5%87%BA%E3%81%97">小見出し</h4>
<p>見出しレベルは小見出しまで。</p>
<ol>
<li>箇条書き：説明</li>
<li>箇条書き：説明</li>
<li>箇条書き：説明</li>
</ol>
<ul>
<li>箇条書き</li>
<li>箇条書き</li>
<li>箇条書き</li>
</ul>
<p><img src="fig/file_name.png" alt="図0.1 図版キャプション"></p>
<note>
囲み記事（NOTE）
</note>
<p>[コラムタイトル]
<column>
コラム
</column></p>

</body>
</html>
