# Chapter 1 レンダリングパイプライン入門
<lead>
このチャプターではCPUとGPUについて学び、画面に3Dモデルの絵が表示されるまでの流れを学びます。
</lead>

## 1.1 CPUとGPU
&emsp;CPUはゲームの進行を司る司令塔のようなものです。ゲームのキャラクターに「Aボタンが押されたらジャンプしなさい」や「Bボタンが押されたらダッシュしなさい」といった指示を出します。一方GPUはCPUからの指示で画面に絵を描く部下のようなものです。PlayStation(以下PS1)の登場で、3DCGを利用したゲームを家庭で楽しめるようになりました。3DCGを利用したゲームを実現するためには、高速な演算を可能とする必要があります。これを実現するために、PS1にはCPUとは別に高速なベクトル演算基、GPUを搭載していました。PS1以降の家庭用ゲーム機は3DCGのゲームを制作できるようにCPUとGPUを搭載するようになってきました。 
### 1.1.1 コア 
&emsp;CPUとGPUには計算を行う「コア」と呼ばれるものが搭載されています。さて、先ほどの説明の「GPUは高速な演算が可能」という説明と矛盾して聞こえると思いますが、CPUのコアは非常に高速な計算が可能です。一方、GPUのコアはそれほど計算は速くはありません。ですが、GPUはCPUに比べるとシンプルな設計になっているため、大量に用意することができます。一方CPUは複雑な処理を行う必要があるため、コアが高価になり、大量に用意することができません。intelのcore-i7というCPUのコア数が8個なのに対して、NVIDIAのRTX1080というGPUのコア数はは2560個です。</br>

&emsp;3DCGを利用したゲームでは、大量の演算が行われます。例えば、100万頂点の3Dモデルをディスプレイに表示するためには、全ての頂点をディスプレイ空間に変換するための演算が行われます。</br></br>
![図1.1 頂点変換](fig/1_1.png)</br></br>
&emsp;その他にもディスプレイのピクセルのカラーを決定するための計算も必要です。ディスプレイ(正確にはレンダリングターゲット)の解像度が縦1920、横1080の場合、ピクセルの数は1920×1080の約200万ピクセルになります。この全てのピクセルのカラーを計算する必要があるわけです。</br></br>
![図1.2 ピクセルカラーの決定](fig/1_2.png)</br>
&emsp;3Dモデルを画面に表示するためには、大量の単純計算が必要になります。例えば、これをC++言語で記述すると下記のようになります。</br>
```cpp
//100万個の頂点の座標変換を行う。
Vector4 convertedVertex[1000000];
for( int vertexNo = 0; vertexNo < 1000000; vertexNo++)
{
    convertedVertex[vertexNo] = worldMatrix * vertex[vertexNo];
    convertedVertex[vertexNo] = viewMatrix * convertedVertex[vertexNo];
    convertedVertex[vertexNo] = projMatrix * convertedVertex[vertexNo];
}
    
```
&emsp;プログラムの意味は分からなくても構いません。注目してほしいのは、100万個の頂点に対して計算を行っているということです。この計算をあなたが行うことを想像してみてください。とてつもない時間がかかることが容易に想像できます。ですが、もしもこの計算を100万人で分担したらどうなるでしょう？１人で計算をしたときよりも、驚くほど短時間で計算が完了します。これがCPUとGPUの関係になります。</br>
<img src="fig/GPUとCPUの関係.png" width="720"></br>
&emsp;CPUはとても計算も速く、複雑な仕事ができます。しかし、高性能であるゆえに高価であり、大量に用意することはできません。一方GPUは計算が遅く、単純な仕事しかできません。しかし、低性能であるがゆえ、安価であり、大量に用意することができます。そこで、単純だが、量が多い計算をGPUにお願いすることで、CPU１人で計算するよりも、圧倒的に高速に計算を完了させることができるようになります。そして、これに非常に適している処理が、3DCGのレンダリングだったのです。
<!-- 改ページ. -->
<div style="page-break-before:always"></div>

### 1.1.3 まとめ
1. **CPUは司令塔、GPUは絵を描くことに特化したアーティスト**</br>
CPUは複雑な処理をこなすことができる司令塔です。GPUは複雑な処理は苦手ですが、絵を描くという一芸に秀でたアーティストです。
2. **GPUは大量の単純計算を行うことが得意**</br>
GPUは単一コアの計算速度はCPUよりも劣るが、コアを大量に持っているため、単純な計算を並列に行うことが可能となっており、ケースによってはCPUよりも高速に演算を行うことができる。
3. **3DCGをレンダリングするためには、大量の演算を行う必要がある**</br>
3DCGを画面にレンダリングするためには、頂点座標の変換や、ピクセルカラーの決定という大量の演算を行う必要がある。

## 1.2 メインメモリとグラフィックメモリ
&emsp;前節で見てきた、CPUとGPUは人間で例えると脳みそに当たります。コンピューターに指示を出したり、計算を行ったりします。しかし、人間の脳みそと大きく異なる点があります。それは記憶することができないということです。このモノを覚えるという機能を持っているのが、メモリと呼ばれるものです。</br>
&emsp;CPUとGPUは別人なので、脳みそが別々です。人間が２人いるようなものだと考えてください。２人いるので、当然記憶も別物になります。メインメモリにはゲームのキャラクターの体力、攻撃力、守備力といったゲームを制御するためのデータが記憶されています。一方グラフィックメモリには3DCGをレンダリングするために必要なデータが記録されています。具体的には、3Dモデルの頂点データとなる頂点バッファ、模様を表すテクスチャなどです。</br>
<p align="center">
<img src="fig/メインメモリとグラフィックメモリに乗っているデータ.png" ></br>
</p>
&emsp;CPUとGPUは別人なので、脳みそは別物です。ですので、CPUからアクセスできるメモリはメインメモリ、GPUからアクセスできるメモリはグラフィックメモリとなります。基本的にCPUからグラフィックメモリにアクセスしたり、GPUからメインメモリにアクセスしたりすることは、シンプルなプログラミングで行うことはできません。

```cpp
//プレイヤーの体力を表示。
//このデータはメインメモリに記憶されているので、簡単にアクセスできる。
prntf("%d", playerHp); 

//しかし、下記のようにテクスチャはグラフィックメモリに記録されているので、
//このように、直接アクセスして、画素を変更するようなことは簡単には行えない。
/*texture[0].r = 232;
texture[0].g = 104;
texture[0].b = 110;*/
```
### 1.2.1 メモリ転送
&emsp;この後のチャプターで具体的にシェーダープログラミングを行っていくと分かってくるのですが、実はCPUとGPUとでメモリが分かれていることで困ることが出てきます。具体的には、GPUからメインメモリのデータに対してアクセスしたいケースがたくさん出てくるからです。しかし、GPUからアクセスできるのはグラフィックメモリだけです。ですので、CPUはGPUのDMA(Direct Memory Access)コントローラーなどを利用して、メインメモリの内容をグラフィックメモリにコピーします。例えば、3Dモデルの頂点データやテクスチャなどはメインメモリに一旦ロードされることがほとんどです。ですので、これらのデータをグラフィックメモリにコピーしてやる必要があります。下記のコードはDirectX12のAPIを利用して、メインメモリからグラフィックメモリにデータをコピーするコードです。

```cpp
ID3D12Device* d3dDevice = g_graphicsEngine.GetD3DDevice();
//DirectXTKのResourceUpdateBatchクラスを利用して、
//頂点バッファをグラフィックメモリにコピーする。
DirectX::ResourceUploadBatch re(d3dDevice.Get());
re.Begin();
//コピーするリソースの情報を設定。
D3D12_SUBRESOURCE_DATA subResourceData;
subResourceData.pData = srcVertices; //頂点バッファの先頭アドレス。  
subResourceData.RowPitch = m_vertexBufferView.SizeInBytes; //コピーするデータのサイズ。
subResourceData.SlicePitch = 1;
//コピーを実行。
re.Upload(
	m_vertexBuffer.Get(),
	0,
	&subResourceData,
	1);
re.End(ge12.GetCommandQueue().Get());
```

GPUからメインメモリのデータが必要な例では、そのほかにも、下記のようなプレイヤーの体力に応じて画面が赤くなるような表現があります。</br>
<p align="center">
<!-- webから引っ張ってきた画像です。使用してOKな画像に差し替えをお願いします。. -->
<img src="fig/ダメージ表現.jpg"></img></br>
</p>
このような表現を行うためには、GPUはメインメモリに記憶されている、プレイヤーの残り体力にアクセスしないと行うことはできません。しかし、GPUがアクセスできるのはグラフィックメモリだけです。ですので、DMAコントローラーなどを利用してメインメモリの内容をグラフィックメモリにコピーする仕組みが必要になるのです。

### 1.2.2 なぜメモリが分かれているの？
&emsp;さて、なぜCPUとGPUとでメモリが分かれているのでしょうか？もしもCPUとGPUでメモリが共通であれば、あんな複雑なプログラムを書く必要はなくなります。端的に理由を説明すると、「CPUとGPUとで最高性能を求めると、メモリ要件が異なってくるから」というものになります。メインメモリはゲーム以外の用途でも利用されます。そのため、汎用性の高く、複雑な要件が求められます。例えば、メモリに載らなくなったデータをハードディスクに退避させる仕組みや、ユーザーが自由にメモリを増設できる仕組みなどです。一方グラフィックメモリはグラフィックに関する用途でしか利用されません。そして、求められる要件も「とにかく高速にデータの転送を行えるようにしてほしい」というシンプルなものです。GPUは大量の演算を行います。その時に演算に必要なデータ、頂点データ、テクスチャ、インデックス情報などを大量にメモリからロードする必要があります。そのため、グラフィックメモリは拡張性や汎用性を無視してもいいが、高速にデータを転送することができる必要があるわけです。このように、CPUとGPUとで求められる要件が異なっているため、メモリが分かれています。</br></br>
<img src="fig/メインメモリとグラフィックメモリにが別の理由.png"></img></br>

下記は、私が使っているPCのメモリのスペック表です。メインメモリはDDR4、グラフィックメモリはGDDR5になっています。データを読み込む速度の指標となるメモリ帯域が、メインメモリは42.7GB/sであるのに対して、グラフィックメモリは192.2GB/sと約4.5倍の速度になっています。
<img src="fig/メモリ帯域表.png" ></br>

### 1.2.3 ユニファイドメモリアーキテクチャ
&emsp;ここまで、CPUとGPUとでメモリは分かれていているものだと説明してきました。しかし、分かれていることによりプログラムは複雑になり読みにくくなってしまいます。CPUとGPUのメモリを統合してしまえば、プログラムはシンプルになるのですが、1.2.2で説明したように、CPUとGPUとで最高性能を求めると、メモリに求める要件というものが異なってくるため、ハードウェア的に統合することは難しいのが現実です。そこで、ソフトウェア的に、プログラマーから見た場合はあたかもメモリが統一されているかのように振る舞うことができる、ユニファイドメモリアーキテクチャが登場しました。</br>
<p align="center">
<img src="fig/ユニファイドメモリアーキテクチャ.png"></img></br>
</p>
このアーキテクチャでは仮想メモリという偽物のメモリを用意しています。CPUとGPUはこの仮想メモリにアクセスします。そして、ハードウェアがアクセスしているメモリに応じて、適切な物理メモリ、本物のメモリにアクセスしています。この仕組みによって、プログラマーから見るとGPUもCPUも同じメモリにアクセスしているようにプログラムを記述することができます。つまり、ユニファイドメモリアーキテクチャであれば、1.2.1のメモリ転送の項目で記述した、頂点バッファのデータコピーは下記のようにシンプルに書けるようになるわけです。

```cpp
//頂点バッファの内容をグラフィックメモリにコピー。
memcpy(m_vertexBuffer, srcVertices, vertexBufferSize);
```
しかし、DirectX12では、基本的にメモリは分かれている前提でのプログラミングを行うようになっています。</br>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>

>Intel HD Graphicsなどのcpuに統合されているGPUでは、グラフィックメモリというものは用意されておらず、CPUが使用しているメインメモリの一部を使用するような形になります。そのため、統合プロサッサは真のユニファイドメモリアーキテクチャといえるのですが、メモリ帯域が足りない、メモリの容量も足りないと言った問題を抱えてしまうため、パフォーマンスの面ではどうしても単体のGPUに劣ってしまいます。
>

### 1.2.4 まとめ
1. **CPUとGPUとでメモリは物理的に分かれている**</br>
CPUとGPUとで最高性能を求めると、メモリ要件が異なってくるため、メモリが別々になっています。
2. **基本的にCPUはメインメモリ、GPUはグラフィックメモリにしかアクセスできない**</br>
これは、後々シェーダープログラミングを行っていくときに重要になってくるので、しっかりと押さえておいてください。
3. **メインメモリ→グラフィックメモリ、グラフィックメモリ→メインメモリにデータを転送する仕組みが必要**</br>
これも2と同様に、後々重要になってきます。

## 1.3 絵が表示されるまで
　ここまでCPUとGPU、メインメモリとグラフィックメモリについて学んできました。3DCGを画面に表示するためには、絵を描きなさい！と命令を出す司令塔のCPUと絵を描くことに特化したアーティストのGPUの二つのプロセッサが存在していることを学びました。では、もう少し具体的に、最終的に絵が出るまでどのような流れになっているのかを見ていきましょう。

### 1.3.1 ドローコール
&emsp;絵を描くためにはGPUに対して絵を描きなさい！と命令を出す必要があります。この命令はドローコールと呼ばれます。Unityなどでゲームを作ったことがある方なら聞いたことがあるのではないかと思います。「処理を早くするためにはドローコールを減らしなさい」と言われているのを聞いたことがあるのではないでしょうか。このドローコールの最適化に関しては、最適化のチャプターで詳しく説明します。</br>
&emsp;さて、少しGPUの気持ちになって考えてみてください。あなたは「絵を描きなさい！」と命令されました。さてどんな絵を描けばいいのでしょうか？かわいい女の子のキャラクターを描けばいいのでしょうか？もしくは、カッコいい男の子のキャラクター、ひょっとすると可愛らしいゆるキャラかもしれません。「絵を描きなさい！」という命令だけでは、どんな絵を描けばいいのか分かりませんよね？なので、ドローコールを行う前に、どんな絵を描くのか？といった情報もGPUに教えてやる必要があります。下記のコードは犬の3Dモデルを描くためにドローコールを行う疑似コードです。
```cpp
//犬のモデルの頂点バッファを設定する。
SetVertexBuffer( dogVertexBuffer );
//犬のモデルのテクスチャを設定する。
SetTexture( dogTexture ) ;
//ここまでに設定した内容でドローコールを実行。
Draw();
```
このコードはあくまでも疑似コードなので、実際のコードはここまでシンプルではありませんが、ドローコールに必要な情報を端的に表しています。3Dモデルの絵を描いてもらうためには、頂点座標、模様を表すテクスチャなどが必要になります。このドローコールが実行されるとGPUは絵を描きだすわけです。

### 1.3.2 レンダリングパイプライン
&emsp;CPUからドローコールが実行されると、そこからGPUは絵を描き始めるわけです。この時、GPUは決められた手順で絵を描いていきます。この絵を描くための手順がレンダリングパイプラインと呼ばれています。例えば、あなたが絵を描くときは下記のような手順を踏むのではないでしょうか。
1. キャンパスを用意する。
2. 鉛筆を用意する。
3. 鉛筆を使って下書きを行う。
4. 絵具を用意する。
5. 絵具を使って絵を仕上げる。

&emsp;これと同じように、GPUも画面に絵を表示するまでの決められた手順というものがあります。これがレンダリングパイプラインと呼ばれているものです。この手順は近年、非常に複雑になってきているのですが、ここでは手順を必要最小限にして説明にとどめておきます。さらに詳しい話は、Chpater8のレンダリングパイプライン発展で説明します。
<div style="page-break-before:always"></div>

1. 入力アセンブラ : グラフィックメモリから設定されている頂点バッファ、インデックスバッファなどをロードする 。
<p align="center">
<img src="fig/入力アセンブラ_0.png" width="400"></img></br>
</p>

2. 頂点シェーダー : 頂点データをスクリーン空間に変換する。</br>
<p align="center">
<img src="fig/座標変換.png" width="400"></img></br>
</p>

3. ラスタライザ : 絵を描くために塗りつぶす必要があるピクセルを決定する。</br>
<p align="center">
<img src="fig/ラスタライザ.png" width="300"></img></br>
</p>

4. ピクセルシェーダー : ピクセルのカラーを決定する。</br>
<p align="center">
<img src="fig/1_2.png" width="300"></img></br>
</p>

&emsp;これらがGPUが行う仕事、レンダリングパイプラインを簡単に説明したものです。まず、**入力アセンブラ**は絵を描くために必要な頂点バッファやインデックスバッファと呼ばれるデータを準備します。続いて、**頂点シェーダー**で頂点座標にワールド行列、ビュー行列、プロジェクション行列を乗算して、スクリーン空間に変換します。スクリーン空間に変換できたら、**ラスタライザ**で絵を表示するために塗りつぶす必要があるピクセルを決定します。最後に**ピクセルシェーダー**で陰影の計算などを行ってピクセルカラーを決定してピクセルを塗りつぶしていきます。
&emsp;これらの仕事はステージと呼ばれます。この中で、頂点シェーダーとピクセルシェーダーは、プラグラマが自由にプログラミングできるステージとなっており、非常に高い柔軟性を持っています。一方ラスタライザや入力アセンブラは、ある程度固定化されたステージで、プログラマが自由にプログラミングすることはできません。これらのステージについてまとめたものが表1.3.1です。
</br>

**表1.3.1**
|  ステージ名  |　説明　|　柔軟性  |
| ---- | ---- | ---- |
|  入力アセンブラ  |　データの準備　|  低い  |
|  頂点シェーダー  |  座標変換　|  高い  |
|  ラスタライザ  |  塗りつぶすピクセルの決定  |  低い  |
|  ピクセルシェーダー  |  ピクセルカラーの計算　|  高い  |
&emsp;このうち、頂点シェーダーとピクセルシェーダーは本書のメインテーマとなっており、Chapter2以降でさらに詳しく見ていくことにします。

<!-- 改ページ. -->
<div style="page-break-before:always"></div>


### 1.3.3 入力アセンブラ
&emsp;入力アセンブラはCPUからドローコールが実行されると、GPUが真っ先に実行する仕事です。入力アセンブラの仕事は、絵を描くためのデータを準備することです。準備するデータは頂点バッファ、インデックスバッファ、入力レイアウト、プリミティブタイプなどのデータです。ドローコールが実行されると、GPUはグラフィックメモリから必要なデータをレジスタという場所に運んできます。</br>

**[図?.? グラフィックメモリから必要なデータを運んでいる]**

<p align="center">
<img src="fig/入力アセンブラ_0.png" ></img></br>
</p>

**[図?.? 必要なデータをレジスタに運ぶ]**
<p align="center">
<img src="fig/入力アセンブラ_1.png"></img></br>
</p>

レジスタとは、非常に高速に読み書きができるメモリです。グラフィックメモリはメインメモリに比べて高速だという話をしましたが、レジスタはさらに高速です。ですので、絵を描くときには毎回グラフィックメモリにデータを参照しに行くのではなく、一旦レジスタにデータを運んできて、そこからデータを参照することで処理の高速化を実現しています。
<!-- 改ページ. -->
<div style="page-break-before:always"></div>

### 1.3.4 頂点シェーダー
&emsp;このステージでは、3Dモデルの頂点座標をスクリーン空間に変換します。
<p align="center">
<img src="fig/座標変換.png" width="400"></img></br>
</p>
&emsp;頂点シェーダーはプログラマブルなステージです。つまりプログラミングを行う必要があります。頂点シェーダーの主な仕事は3Dモデルの頂点をスクリーン空間に変換することなので、ほとんどの場合で、下記のような処理を実装します。

1. ローカル座標系の頂点をワールド座標系に変換する。
2. ワールド座標系の頂点をカメラ座標系に変換する。
3. カメラ座標系の頂点をスクリーン座標系に変換する。

処理の詳しい説明はChapter2の頂点シェーダー入門で説明しますので、ここでは簡単にだけ説明しますが、Blender、3dsMax、mayaなどといった3DCGソフトウェアで作成された3Dモデルをテレビ画面など表示するために、それらの頂点をスクリーン空間に変換する必要があります。このときに、ベクトル(座標)と行列の乗算が行われて、座標変換が行われています。ですので、先ほどの1～3ではベクトルと行列の乗算が行われていることになります。

1. ローカル座標系の頂点をワールド座標系に変換する。

    → **ワールド座標系の座標　＝　ローカル座標系の座標　×　ワールド行列**

2. ワールド座標系の頂点をカメラ座標系に変換する。   

    → **カメラ座標系の座標　＝　ワールド座標系の座標　×　カメラ行列**

3. カメラ座標系の頂点をスクリーン座標系に変換する。

    → **スクリーン座標系の座標　＝　カメラ座標系の座標　×　プロジェクション行列**

&emsp;さて、確かにスクリーン空間への座標変換が頂点シェーダーの仕事なのですが、この処理を行うだけであるならば、プログラマブルである必要はありません。プログラマブルであるということは、自由にプログラミングができるわけなので、極端に言えば、必ずしも座標変換する必要はないのです！これについてはChapter2以降で詳しく見ていきます。ここでは、頂点シェーダーというのは、頂点座標をスクリーン空間に変換しているのだと理解しておいてください。

<div style="page-break-before:always"></div>

### 1.3.5 ラスタライザ
&emsp;ラスタライザは頂点シェーダーで座標変換された3Dモデルを画面に表示するために、塗りつぶす必要があるピクセルを決定します。
<p align="center">
<img src="fig/ラスタライザ.png" width="300"></img></br>
</p>
&emsp;ラスタライザは頂点シェーダと違い、プログラマブルではなく、固定的なステージです。ただし、柔軟性が全くないわけではなく、いくつかの設定で処理を変更することができます。例えば下記のような設定があります。

#### 塗りつぶし設定
&emsp;この設定では、ピクセルの塗りつぶし方を変更することができます。DirectX12には2種類の塗りつぶしモードがあり、D3D12_FILL_MODE_WIREFRAMEとD3D12_FILL_MODE_SOLIDがあります。
D3D12_FILL_MODE_WIREFRAMEを設定した場合はワイヤーフレームモードで塗りつぶされます。
<img src="fig/wireframe.png" width="170"></img></br>

D3D12_FILL_MODE_SOLIDを設定した場合は、皆さんのイメージ通りの塗りつぶしが行われます。
<img src="fig/solid.png" width="170"></img></br>

#### カリング設定(塗りつぶしなし設定)
&emsp;この設定では、ポリゴンカリングを設定することができ、DirectX12では、D3D12_CULL_MODE_FRONT(ポリゴンの表側をカリング)、D3D12_CULL_MODE_BACK(ポリゴンの裏側をカリング)、D3D12_CULL_MODE_NONE(カリングなし)が設定できます。</br></br>
D3D12_CULL_MODE_FRONTを設定するとポリゴンの表側が塗りつぶされません。</br>
<img src="fig/cull_front.png" width="170"></img></br>

D3D12_CULL_MODE_BACKを設定するとポリゴンの裏側が塗りつぶしされません。</br>
<img src="fig/cull_back.png" width="170"></img></br>

D3D12_CULL_MODE_NONEを設定するとカリングなしになります。</br>
<img src="fig/cull_back.png" width="170"></img></br>
&emsp;D3D12_CULL_MODE_FRONTを指定すると、ポリゴンの表面が表示されなくなるので、異様な見た目になります。D3D12_CULL_MODE_BACKを指定すると、ポリゴンの裏面が表示されなくなるので、普段皆さんが見慣れている見た目になります。D3D12_CULL_MODE_NONEを指定すると、表面も裏面も表示されるので、今回のケースだとD3D12_CULL_MODE_BACKと同じ結果になります。
&emsp;ポリゴンのカリング設定を適切に行うと無駄な処理が行われなくなります。今回のケースですとポリゴンの裏面を描画する必要はないので、D3D12_CULL_MODE_BACKを指定してやればいいわけです。さて、ここで疑問がでてきます。ポリゴンの裏面を描画するケースや、両面描画するケースってあるの？って思いませんでしたか？この疑問については、【todo あとで関連するチャプターを記入する】で取り上げさせてもらいますので、楽しみにしていてください。

### 1.3.6 ピクセルシェーダー
&emsp;ピクセルシェーダーはライスタライザで決定されたピクセルのカラーを決定するステージです。
<p align="center">
<img src="fig/1_2.png" width="300"></img></br>
</p>
ピクセルシェーダーはプログラマブルなステージです。ピクセルシェーダーは、ありとあらゆるグラフィックスアルゴリズムの中核をなしていて、シェーダープログラミングの花形といえるステージです。もっとも典型的な利用のされ方は、ピクセルの陰影付けです。ピクセルに法線という、向きを表す情報と、ライトの情報を持たせて、陰影を計算していきます。みんなが大好きなセルシェーディングでもピクセルシェーダーが活躍します。詳しくはChapter3以降で見ていきますので、ここではこれくらいにしておきましょう。

### 1.3.7 まとめ
1. 絵を表示するためには、CPUからGPUに対して描画命令(ドローコール)を行う必要がある。
2. 画面に絵を表示するための決められた手順があり、レンダリングパイプラインと呼ばれている。
3. このチャプターでは、入力アセンブラ、頂点シェーダー、ラスタライザ、ピクセルシェーダーを学んだ。
4. 入力アセンブラ：絵を描くために必要なデータを準備する。
5. 頂点シェーダー : 頂点データをスクリーン空間に変換する。
6. ラスタライザ：塗りつぶすピクセルを決定する。
7. ピクセルシェーダー：ピクセルのカラーを決定する。

<!-- 改ページ. -->
<div style="page-break-before:always"></div>

# Chapter 2 シェーダー入門 その１
&emsp;Chapter1でレンダリングパイプラインについて学びました。このパイプラインには処理ごとにステージ分けされていて、柔軟性が低い、入力アセンブラやラスタライザなどのステージは固定機能ステージと呼ばれています。一方柔軟性が高い、頂点シェーダーやピクセルシェーダーなどのプログラマブルステージと呼ばれています。DirectXでプログラマブルステージが用意されたのはDirectX8以降で、それ以前のバージョンでは固定機能ステージしか用意されていませんでした。表1.3.1で各ステージの柔軟性を見ましたが、表2.1のようにすべてのステージで柔軟性が低いになっていると考えてください。DirectX7以前のバージョンとステージ名は違うのですが、対比させるためにあえて同じにしています。

**表 2.1**
|  ステージ名  |　説明　|　柔軟性  |
| ---- | ---- | ---- |
|  入力アセンブラ  |　データの準備　|  低い  |
|  頂点処理(現在の頂点シェーダーに相当)  |  座標変換　|  低い  |
|  ラスタライザ  |  塗りつぶすピクセルの決定  |  低い  |
|  ピクセル処理(現在のピクセルシェーダーに相当)  |  ピクセルカラーの計算　|  低い  |


&emsp;頂点変換とピクセルカラー決定の固定機能はDirectX9までは存在していましたが、DirectX10で削除され、それ以降は固定機能は用意されなくなっています。これはDirectX以外のグラフィックスAPIの、Valukan、OpenGLES、Sonyや任天堂などが提供する専用SDK(PS4、PS3、WiiUなどで使用できるDirectXのようなもの)でも同じで、頂点変換やピクセルカラー決定の固定機能はグラフィックプログラミングの世界では過去のものとなっています。

## 2.1 DirectX7以前のレンダリングパイプライン
&emsp;では、DirectX7以前のレンダリングパイプラインについて見ていきましょう。以前のレンダリングパイプラインでもCPUでドローコールが実行されることで、GPUは動き出します。図2.1のようにセットされた頂点バッファから頂点をフェッチ(取り出して)して、その頂点の座標をスクリーン座標系に変換して、塗りつぶすピクセルを決定して、そのピクセルの色を決定します。

**図2.1**
<img src="fig/固定機能レンダリングパイプライン.png"></img></br>

DirectX9までは3Dモデルの頂点をスクリーン空間に変換する頂点変換、ラスタライズ後に3Dモデルをスクリーン上で表示するためのピクセルカラーの決定といった処理をGPUがハードウェア的に用意してくれていました。しかし、DirectX10以降では、この機能はハードウェア側で用意されなくなり、プログラマーがプログラミングする必要が出てきました。そして、そのプログラムがシェーダーと呼ばれています。

## 2.2 シェーダー
&emsp;シェーダーの導入でレンダリングパイプラインの頂点処理とピクセル処理を自分でプログラミングして、自由に頂点処理やピクセル処理を実装することができるようになりました。つまり、自分で頂点座標をスクリーン座標系へ変換したり、ピクセルカラーを決定するプログラムを書くことになります。つまりDirectX10以降ではシェーダーを書かないと絵は表示できなくなりました。図2.2はシェーダー導入後のレンダリングパイプラインです。

**図2.2**
<img src="fig/DirectX10以降のレンダリングパイプライン.png"></img></br>

&emsp;この図のように、頂点処理とピクセル処理がシェーダーをロードして実行するという内容に変わっています。ではなぜ固定機能が削除されてシェーダーが登場したのでしょうか？せっかく用意されていたものがなくなって、同じものを作らないと絵を表示できなくなったなんて面倒だと思いませんか？では、シェーダーが生まれてきた背景を学んで行きましょう。

## 2.3 なぜシェーダーが生まれたのか
&emsp;固定機能しか存在していなかったDirectX7までは、マイクロソフトが用意したグラフィック表現しか行うことができませんでした。ピクセルカラーの決定で重要な要素としてライティングがあります。DirectX9までに用意されていた陰影計算モデルはディフューズライト、スペキュラライト、アンビエントライトくらいです。これらのライトの詳しい話は後々行うので、ここでは詳しく説明はしませんが、これらのライトで実現可能なグラフィック表現というと、せいぜい図2.3程度のものです。

**図2.3**</br>
<img src="fig/solid.png" width="200"></img></br>

&emsp;しかし、これらの機能だけでは、図2.4のようなアニメっぽい表現の実現は困難です。

**図2.4**</br>
<img src="fig/セルシェーダー.jpg" width="400"></img></br>
&emsp;このようなアニメ調の表現を実現するためには特殊なライティングアルゴリズムを実装する必要があります。しかし、シェーダーが生まれる前は新しいグラフィック表現を実現するためには、DirectXのバージョンアップを待つ必要がありました。また、ゲーム開発者という人たちは、他とは違うユニークな表現を行いたがるものです。その人たちの要望にすべて答えようとすると、DirectXのAPIはどんどん肥大化していくことになります。そこで、DirectXはバージョン8から開発者が行いたい表現をすぐに実現できるように、プログラマブルシェーダーを採用した設計に舵をとることとなります。

## 2.4 頂点シェーダー入門
&emsp;では、いよいよ実際にシェーダーを書いていってみましょう。まずはシンプルな三角形を表示するだけのプログラムを作ってみましょう。Sample_02_04/Sample_02_04.slnを立ち上げてください。VisualStudioのプロジェクトが立ち上がったら図2.6のボタンを押すかF5キーを押してプログラムを実行してください。すると図2.7のような灰色のウィンドウが立ち上がります。

**図2.6**</br>
<img src="fig/2_6.png" width="300"></img></br>

**図2.7**</br>
<img src="fig/2_7.png" width="300"></img></br>

### 2.4.1 ウィンドウズプログラムのメイン関数
&emsp;さて、頂点シェーダーの話に入る前に、Windowsアプリのプログラムについて見ていこうと思います。Windowsプログラミングはそれだけで書籍を一冊余裕で書けるくらいのボリュームがあるのですが、本書のメインはシェーダープログラムですので、ここはそこまでは掘り下げません。まず、VisualStudioのソリューションエクスプローラーからmain.cppを開いて下さい。

**図2.8**</br>
<img src="fig/2_4_1_1.png" width="300"></img></br>
もし、ソリューションエクスプローラーが表示されていない場合は、図2.4.2を参考にして、ソリューションエクスプローラーを表示してください。

**図2.9**</br>
<img src="fig/2_4_1_2.png" width="400"></img></br>

main.cppを開けたら、13行目からのwWinMain関数を見てください。

[リスト2.1 main.cpp(13行目～)]
```cpp
///////////////////////////////////////////////////////////////////
// ウィンドウプログラムのメイン関数。
///////////////////////////////////////////////////////////////////
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow)
{
    ・
    ・
    ・
    ・
}
```
C++、C#、Javaなどでコンソールアプリケーションを作成したときに、メイン関数というものを書いたことがあると思います。メイン関数はエントリーポイントと呼ばれる特殊な関数で、プログラムのスタート地点となる関数です。Windowsプログラムにもエントリーポイントがあって、今回のサンプルですとwWinMain関数がそれにあたります。

### 2.4.2 三角形を表示するための準備
&emsp;プログラムが起動すると、三角形を表示するための準備を行うプログラムがmain.cppの25行目(リスト 2.2)から記述されています。よく分からないプログラムだと思いますが、あまり気にしなくて構いません。簡単にだけ説明します。

1. **ルートシグネチャの作成**</br>
ここでは気にしなくて構いません。
2. **シェーダーをロード**</br>
頂点シェーダーとピクセルシェーダのロードを行っています。
3. **パイプラインステートの作成**</br>
パイプラインステートとはレンダリングパイプラインの各ステージの設定です。Chapter1で学んだラスタライザステージのカリング設定や塗りつぶし設定、そして頂点シェーダーやピクセルシェーダーも設定します。ここでは私が作成したPipelineStateというクラスを利用しています。このクラスの中で3Dモデルの描画でよく使われる設定のパイプラインステートが作成されています。
4. **三角形の頂点バッファを作成**</br>
表示する三角形の頂点データを作成しています。今回の頂点データは座標のみのデータです。
5. **インデックスバッファを作成**</br>
ここでは気にしなくて構いません。

[リスト2.2 main.cpp(25行目～)]
```cpp
//１．ルートシグネチャを作成。
RootSignature rootSignature;
InitRootSignature(rootSignature);

//２．シェーダーをロード。
Shader vs, ps;
vs.LoadVS(L"Assets/shader/sample.fx", "VSMain");
ps.LoadPS(L"Assets/shader/sample.fx", "PSMain");

//３．パイプラインステートを作成。
PipelineState pipelineState;
InitPipelineState(pipelineState, rootSignature, vs, ps);

//４．三角形の頂点バッファを作成。
//頂点配列を定義。
SimpleVertex vertices[] = {
    { -0.5f, -0.5f, 0.0f },
    { 0.0f, 0.5f, 0.0f },
    { 0.5f, -0.5f, 0.0f },
};

VertexBuffer triangleVB;
triangleVB.Init(sizeof(vertices), sizeof(vertices[0]));
triangleVB.Copy(vertices);

//５．三角形のインデックスバッファを作成。
//インデックス配列
short indices[] = {
    0,1,2
};
IndexBuffer triangleIB;
triangleIB.Init(sizeof(indices), 2);
triangleIB.Copy(indices);
```

### 2.4.3 三角形を表示するためのドローコール
&emsp;頂点バッファやシェーダーのロードなどの準備が終わったら、次は三角形を表示するためのドローコールです。ドローコールはmain.cppの74行目(リスト2.3)から記述されています。ここで行われているのは「1.3.1 ドローコール」に書かれていた疑似コードと相当します。ドローコールを実行する前に、これから描画する絵の情報を設定しています。

1. **ルートシグネチャを設定**</br>
ここでは気にしなくて構いません。
2. **パイプラインステートの設定**</br>
ラスタライザ、入力アセンブラ、使用されるシェーダーなどの情報が一気に設定されます。
3. **プリミティブトポロジーの設定**</br>
ここでは気にしなくて構いません。
4. **頂点バッファの設定**</br>
今回は三角形を表示するので、さきほど作成した頂点バッファを指定しています。
5. **インデックスバッファの設定**</br>
ここでは気にしなくて構いません。
6. **ドローコール**</br>
これがGPUへの描画命令です。

[リスト2.3 main.cpp(25行目～)]
```cpp
//１．ルートシグネチャを設定。
renderContext.SetRootSignature(rootSignature);
//２．パイプラインステートを設定。
renderContext.SetPipelineState(pipelineState);
//３．プリミティブのトポロジーを設定。
renderContext.SetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
//４．頂点バッファを設定。
renderContext.SetVertexBuffer(triangleVB);
//５．インデックスバッファを設定。
renderContext.SetIndexBuffer(triangleIB);
//６．ドローコール
renderContext.DrawIndexed(3);
```
では、続いてGPU側のプログラムを見ていきましょう。

### 2.4.4 頂点シェーダー
&emsp;DirectXではHLSL(High Level Shader Language)という言語を使って、シェーダ―プログラミングを行います。文法はC言語によく似ているので、C言語系列の言語(C++、Java、C#など)を勉強した人であれば言語仕様は比較的簡単に理解できると思います。頂点シェーダーもHLSLで記述されます。</br>
&emsp;頂点シェーダーは3Dモデルの全ての頂点に対して実行されるプログラムです。2.4.3のドローコールで設定されている3Dモデルの頂点数が100頂点の場合は、設定されている頂点シェーダーが100回実行されます(厳密には少し違いますが・・・)。では、頂点シェーダーを見ていきましょう。Sample_02_04/Assets/shader/sample.fxを開いてください。

[リスト2.4 sample.fx(9行目～)]
```cpp
//頂点シェーダー。
//１．引数は変換前の頂点情報。
//２．戻り値は変換後の頂点情報。
//３．VSMainは
VSOutput VSMain(VSInput In) 
{
	VSOutput vsOut = (VSOutput)0;
	return vsOut;
}
```
&emsp;9行目からのプログラムが頂点シェーダーのエントリーポイントです。VSMainという関数が頂点の数分だけ実行されます。では、もう少し詳細に見ていきましょう。</br>

1. **引数は変換前の頂点情報**</br>
引数にはこれから処理される頂点１つ分の情報が入っています。入力アセンブラがグラフックメモリから持ってきた頂点情報が頂点シェーダーに渡されていることになります。VSInputはユーザー定義の構造体で、入力される頂点データ構造です。詳細については後述します。
2. **戻り値は変換後の頂点情報**</br>
戻り値は頂点シェーダーで変換された頂点情報です。頂点シェーダーは必ず処理した結果の頂点情報を戻り値として返す必要があります。VSOutputはユーザー定義の構造体で、出力される頂点データ構造です。詳細については後述します。</br>

&emsp;頂点シェーダーの典型的な処理は、ワールド行列、ビュー行列、プロジェクション行列を使って、頂点座標をスクリーン空間に変換することです。しかし今回のサンプルでは頂点シェーダーは何もしていません。ですからサンプルを実行しても灰色のウィンドウが表示されるだけなのです。

### 2.4.5 【ハンズオン】入力された頂点座標をそのまま出力に渡す

&emsp;では、Sample.fxを改造して、変換後の頂点データを返せるようにしてみましょう。リスト2.5のように頂点シェーダーを改造して下さい。

[リスト2.5 sample.fx(9行目～)]
```hlsl
//頂点シェーダー。
//１．引数は変換前の頂点情報。
//２．戻り値は変換後の頂点情報。
//３．VSMainは
VSOutput VSMain(VSInput In) 
{
	VSOutput vsOut = (VSOutput)0;
    //入力された頂点座標を変換せずに出力する。
    vsOut.pos = In.pos;
	return vsOut;
}
```
&emsp;リスト2.5のプログラムを入力すると図2.10のような三角形が表示されたと思います。</br></br>
**図2.10**</br>
<img src="fig/2_10.png" width="400"></img></br>
&emsp;今回入力してもらった頂点シェーダーは、頂点座標の変換は行わずに、そのまま出力しています。では、なぜ変換していないのに画面に絵が表示されたのでしょうか？答えは入力された頂点データがすでに変換済みのデータになっていたからです。たまたまスクリーンに映せる座標になっていたと考えてもらっても構いません。
<!-- 改ページ. -->
<div style="page-break-before:always"></div>

### 2.4.6 【ハンズオン】入力された頂点座標を拡大して出力に渡す
&emsp;では、次は頂点座標を２倍にして出力座標に渡してみましょう。リスト2.6のように頂点シェーダーを改造してください。</br>
[リスト2.6 sample.fx(9行目～)]
```cpp
//頂点シェーダー。
//１．引数は変換前の頂点情報。
//２．戻り値は変換後の頂点情報。
//３．VSMainは
VSOutput VSMain(VSInput In) 
{
	VSOutput vsOut = (VSOutput)0;
    //頂点座標を拡大して出力座標に渡す
    vsOut.pos = In.pos;
    vsOut.pos.x *= 2.0f; //X座標を２倍にする。
    vsOut.pos.y *= 2.0f; //Y座標を２倍にする。
	return vsOut;
}
```
&emsp;リスト2.6のプログラムを入力すると図2.10のような三角形が表示されたと思います。</br></br>
**図2.10**</br>
<img src="fig/2_11.png" width="400"></img></br>

### 2.4.7 【課題】入力されたX座標を1.5倍、Y座標を0.5倍して出力に渡す
&emsp;図2.12のように表示できるように、頂点シェーダーを改造してください。</br>

**図2.12**</br>
<img src="fig/2_12.png" width="400"></img></br>

答え:Sample_02_04/Assets/shader/sample_2_4_7.fx

### 2.4.8 入力頂点構造体
&emsp;では、ユーザー定義の入力頂点構造体について見ていきましょう。入力頂点構造体は次のように定義されています。

```hlsl
//頂点シェーダーへの入力頂点構造体。
struct VSInput{
	float4 pos : POSITION;
};
```
&emsp;C言語の構造体と非常によく似ていますが、少しだけ違う点があります。では、その違いについて見ていきましょう。

#### HLSLの組み込み型
まず、HLSLにはfloat4という型があります。float4はx,y,z,wからなる４要素のベクトル型です。下記のような構造体として定義されていると考えるとイメージしやすいのではないでしょうか。</br>

```cpp
struct float4{
	float x;
    float y;
    float z;
    float w;
};
```
&emsp;シェーダープログラミングでは、ベクトルと行列の演算を多用するため、それらを扱うための型が言語として組み込まれています。表2.2は利用頻度の高い、HLSL独自の組み込み型のリストです。</br>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>

**表 2.2**
|  型名  |  説明  |
| ---- | ---- |
| float2 | float型のx,yの２要素を持つ浮動小数ベクトル型 |
| float3 | float型のx,y,zの２要素を持つ浮動小数ベクトル型 |
| float4 | float型のx,y,z,wの２要素を持つ浮動小数ベクトル型 |
| int2 | int型のx,yの２要素を持つ浮動小数ベクトル型 |
| int3 | int型のx,y,zの２要素を持つ浮動小数ベクトル型 |
| int4 | int型のx,y,z,wの２要素を持つ浮動小数ベクトル型 |
| float3x3 | float型の３×３行列 |
| float4x3 | float型の４×３行列 |
| float4x4 | float型の４×４行列 |

&emsp;いきなり大量に型が出てきたので、辟易としたかもしれませんが、ベクトル型とマトリクス型があるということだけ押さえておけば十分です。

#### セマンティクス
&emsp;セマンティクスは、頂点のどのデータを頂点シェーダーで使用するのかを指定するためのものになります。3Dモデルの頂点が持っているデータというのは座標だけではありません。色を表すカラー、向きを表す法線、サンプリングするテクスチャの位置を表すUV座標など多岐にわたります。表2.3は代表的な頂点データです。

**表 2.3**
| 名前 | 説明 |
| ---- | ---- |
| 座標 | 頂点の位置を表すデータ。x,y,zの３成分があれば十分なのだが、行列演算との関係上wを含んだ４要素で扱われることが多い。|
| 法線 | 頂点の向きを表すデータ。x,y,zの３成分で扱われることが多い。|
| 接ベクトル | 法線マップを利用した法線の算出の際に使用される。|
| カラー | 頂点色を表すデータ。x,y,z,wの４成分で扱われることが多い。xがR成分、yがG成分、zがB成分、wがα成分になる。 |
| UV座標 | ポリゴンに貼り付けるテクスチャの位置を表す座標。x,yの２成分で扱われることが多い。|
| スキンウェイト | スキンアニメーションを行うときに使用される。関連付けされているボーンへの影響度。 |
| スキンインデックス |  スキンアニメーションを行うときに使用される。関連付けされているボーンの番号。 |

&emsp;その他にも頂点データはいくつか種類があります。実は頂点データは複数のデータの集合体なのです。次のプログラムは頂点バッファをC++で定義したものです。</br>
```cpp
//頂点構造体
struct Vertex{
	float position[4];      //座標
    float normal[3];        //法線
    float color[4];         //カラー
    float uv[2];            //UV座標
};
//頂点バッファ
Vertex vertexBuffer[5];
```
&emsp;次の図2.13は頂点バッファを図示化したものです。

**図2.13**</br>
<img src="fig/2_13.png"></img></br>

&emsp;さて、ここから本題です。図2.13のような頂点バッファと、リスト2.7のような頂点シェーダーが設定されてドローコールが実行されている場合を考えてください。</br>
[リスト2.7]
```hlsl
//頂点シェーダーへの入力頂点構造体。
struct VSInput{
	float4 hoge : POSITION;
};

//頂点シェーダーの出力。
struct VSOutput{
	float4 pos : SV_POSITION;
};

//頂点シェーダー。
VSOutput VSMain(VSInput In) 
{
	VSOutput vsOut = (VSOutput)0;
    vsOut.pos = In.hoge; //1.In.hogeは頂点のどのデータを参照している？？？
	return vsOut;
}
```
&emsp;この時、頂点シェーダーに入力されているIn.ほhogeは頂点データの何を引っ張ってきているのでしょうか？座標でしょうか？法線でしょうか？カラーでしょうか？答えは座標です。なぜ座標のデータが引っ張ってこれているかというと、頂点データから座標を取ってきなさいとセマンティクスで指定されているからです。

```hlsl
//頂点シェーダーへの入力頂点構造体。
struct VSInput{
	float4 hoge : POSITION;　//これがセマンティクス！！！
};
```
&emsp;下記のようにセマンティクスが指定されている場合は、hoge2はUV座標のデータを取ってきています。

```hlsl
//頂点シェーダーへの入力頂点構造体。
struct VSInput{
	float4 hoge : POSITION;　　
    float2 hoge2 : TEXCOORD;
};
```
&emsp;表2.4は代表的な入力セマンティクスの一覧です。</br>
**表 2.4**
| 名前 | 説明 |
| ---- | ---- |
| POSITION | オブジェクトスペースの頂点座標 |
| COLOR | 頂点カラー |
| NORMAL | 法線ベクトル | 
| TANGENT | 接ベクトル |
| TEXCOORD | UV座標 |
| BLENDWEIGHT | スキンアニメーションで使用するブレンディング率 |
| BLENDINDICES | スキンアニメーションで使用するボーン番号 |

&emsp;このようにセマンティクスの役割は、シェーダーでどの頂点データを使用するのかを指定することとなります。

### 2.4.9 出力頂点構造体
&emsp;最後に出力頂点構造体です。出力頂点構造体は頂点シェーダーから出力されるデータで、かならずしも入力頂点構造体とイコールではありません。また、この構造体もユーザー定義です。リスト2.7のプログラムであれば、VSOutput構造体が該当します。
#### セマンティクス
&emsp;出力頂点構造体のデータにもセマンティクスが指定されています。これは出力されるデータをどのようなデータとして扱うかを指定したものです。頂点シェーダーから出力されたデータはピクセルシェーダーに引き渡されます。この時に、頂点シェーダーから出力されたデータとバインドするために必要となります。考え方は入力構造体のセマンティクスと同じです。一点だけ注意が必要なのは、出力データとして座標を指定したい場合はSV_Positionを指定する必要があります。出力セマンティクスにPOSITIONを指定すると期待した動作にはならないので注意が必要です。

### 2.4.10 まとめ
1. ３Ｄの絵を描くためには、描きたい絵の頂点バッファ、インデックスバッファ、パイプラインステージなどを作成する必要がある。
2. 絵を描くためには、描きたい絵の情報を設定してドローコールを実行する必要がある。
3. ドローコールが実行されるとGPUが絵を描く仕事を始める。
4. 頂点シェーダーは絵を描く仕事(レンダリングパイプライン)の１行程である。
5. 頂点シェーダーはHLSLという言語で記述できるプログラマブルなステージである。
6. 頂点シェーダーで、どの頂点データを処理するのかということを指定するためにセマンティクスと呼ばれるものがある。

## 2.5 ピクセルシェーダー入門
&emsp;2.4節で頂点シェーダーについて見てきました。3Dモデルの頂点座標がスクリーン空間に変換されると、画面上に3Dモデルのポリゴンが表示される位置が確定します。ポリゴンを表示する位置が確定すると、続いてラスタライザステージで、そのポリゴンを表示するために塗りつぶす必要のあるピクセルが決定します。塗りつぶすピクセルが決定すると、その一つ一つのピクセルに対してピクセルシェーダーが実行されます。例えば、塗りつぶすピクセルの数が300ピクセルだった場合、ピクセルシェーダーは300回実行されます。頂点シェーダーが設定されている頂点の数分だけ実行されている関係とよく似ています。では、ピクセルシェーを見てみましょう。Sample_02_05/Assets/shader/sample.fxを開いてください。

[リスト2.8 sample.fx(21行目～)]
```hlsl
//ピクセルシェーダー。
float4 PSMain( VSOutput vsOut ) : SV_Target0
{
	return float4( 1.0f, 0.0f, 0.0f, 1.0f);
}
```
&emsp;18行目からのプログラムがピクセルシェーダーのエントリーポイントです。PSMainという関数が塗りつぶすピクセルの数分だけ実行されます。ピクセルシェーダーも頂点シェーダーと同様にHLSL言語で記述されています。では、もう少し詳細に見ていきましょう。</br>
1. 引数は頂点シェーダーから出力された頂点情報を元に計算されたデータ
ピクセルシェーダーの引数の型が頂点シェーダーからの出力頂点構造体のVSOutputになっていることに気づいた方がいるかもしれません。ピクセルシェーダーに渡されている情報は頂点シェーダーの出力結果を元に計算されたデータが渡ってきています。これについての詳細は後述します。
2. 戻り値はピクセルを塗りつぶすカラー
戻り値はピクセルのカラーで光の３原色のＲＧＢとαを返します。こちらも詳細は後述します。

&emsp;ピクセルシェーダーの典型的な処理はピクセルの陰影付けです。しかし、ピクセルシェーダーは頂点シェーダーと異なり、多様な処理を行います。ですので、ここではピクセルのカラーを決定するということだけ覚えておいてください。

### 2.5.1 【ハンズオン】三角形を青色にする
&emsp;では、sample.fxをリスト2.9のように改造して、三角形を青色にできるようにしてみましょう。
[リスト2.9 Sample.fx(21行目～)]
```hlsl
//ピクセルシェーダー。
float4 PSMain( VSOutput vsOut ) : SV_Target0
{
	return float4( 0.0f, 0.0f, 1.0f, 1.0f);
}
```
### 2.5.2 【ハンズオン】三角形を緑色にする
&emsp;続いて、sample.fxをリスト2.10のように改造して、三角形を緑色にできるようにしてみましょう。
[リスト2.10 Sample.fx(21行目～)]
```hlsl
//ピクセルシェーダー。
float4 PSMain( VSOutput vsOut ) : SV_Target0
{
	return float4( 0.0f, 1.0f, 0.0f, 1.0f );
}
```

### 2.5.3 ピクセルシェーダーの戻り値は光の三原色＋α
&emsp;さて、ここまでのハンズオンでピクセルシェーダーの戻り値が光の３原色を表していることは何となく分かったかもしれません。念のため光の３原色について説明をしておくと、光の三原色とは赤と緑と青のことです。そして、この３つの色を混ぜ合わせることで色を表現するのがＲＧＢ法です。各色には発色の強さがあり、最小で0.0、最大で1.0になります。ちなみにフォトショップやWindows標準ペイントツールなどでは、最小で0、最大で255で表現されます。ですが、シェーダーでは0.0～1.0の範囲で正規化されています。正規化されている方が色々な計算で都合がいいからだと思われます。さて、残りのαですが、ペイントツールではαは不透明度として扱われているともいますが、ここで出力されるαは必ずしも不透明度な分けではありません。これはアルファブレンディングの設定によって変わります。この詳細はChapter 7のレンダリングパイプライン発展で説明します。

### 2.5.4【課題】三角形を黄色にする
&emsp;図2.14のように、三角形を黄色で表示できるように、sample.fxを改造して下さい。</br>
(ヒント:黄色は赤と緑を混ぜ合わせることで表現できます。</br>

**図2.14**</br>
<img src="fig/2_14.png" width="400"></img></br>

答え：Sample_02_05/Assets/shader/sample_2_5_4.fx

### 2.5.5 頂点シェーダーからピクセルシェーダーに渡されるデータ
&emsp;ピクセルシェーダーに渡されるデータは、頂点シェーダーから出力されたデータを元に補完されたデータが渡されています。</br>
&emsp;頂点シェーダーで計算されるのはポリゴンの３頂点のデータのみです。しかし、そのポリゴンを表現するために塗りつぶす必要があるピクセルは100個かもしれません。その時、ピクセルシェーダーにはどの頂点のデータを渡せばいいのでしょうか。答えは、その３つの頂点のデータを使って、各ピクセルシェーダーに渡すデータを補完しています。図2.15を見てください。</br>
**図2.14**</br>
<img src="fig/ラスタライザでの値補間.png" width="400"></img></br>
&emsp;このポリゴンは頂点シェーダーでカラーの情報も出力しており、頂点ごとに異なるカラーを出力しています。この時、１と２のピクセルのカラーはどのように計算されるのでしょうか。赤でしょうか青でしょうか？正解は３つの頂点を使用して補完して計算されるになります。例えば１のピクセルであれば、恐らく赤と青のピクセルが半々に混ざった紫のっぽいカラーになります。２のピクセルは赤と青と緑が均等に混じったグレーのようなカラーになります。実はこの補完の計算はラスタライザで行われています。ラスタライザは塗りつぶすピクセルを決定するだけではなく、頂点シェーダーから渡されたデータを各ピクセルに渡すために補完するという仕事もあったのです。

### 2.5.6 【ハンズオン】頂点シェーダーから受け取ったカラーを出力する
&emsp;Sample_05は頂点データとしてカラーが設定されていて、リスト2.11のように頂点シェーダーから出力されています。</br>
[リスト2.11 Sample.fx(1行目～)]
```hlsl
//頂点シェーダーへの入力頂点構造体。
struct VSInput{
	float4 pos : POSITION;
	float3 color : COLOR; //頂点からカラーのデータを引っ張ってくる。
};
//頂点シェーダーの出力。
struct VSOutput{
	float4 pos : SV_POSITION;
	float3 color : COLOR; //カラーの情報も出力する。
};
//頂点シェーダー。
//１．引数は変換前の頂点情報。
//２．戻り値は変換後の頂点情報。
VSOutput VSMain(VSInput In) 
{
	VSOutput vsOut = (VSOutput)0;
	vsOut.pos = In.pos;
	vsOut.color = In.color; //カラーの情報を出力する。
	return vsOut;
}
```
&emsp;では、ピクセルシェーダーを下記のリスト2.12のように書き換えて、ラスタライザで補完されたデータをピクセルカラーとして出力するようにしてください。図2.16のようになったら正解です。</br>
[リスト2.11 Sample.fx(21行目～)]
```hlsl
//ピクセルシェーダー。
float4 PSMain( VSOutput vsOut ) : SV_Target0
{
	float4 color;
	color.x = vsOut.color.x;
	color.y = vsOut.color.y;
	color.z = vsOut.color.z;
	color.w = 1.0f;
	return color;
}
```
**図2.16**</br>
<img src="fig/2_16.png" width="400"></img></br>

### 2.5.7 まとめ
1. 頂点シェーダーの後でラスタライザが実行され、塗りつぶすピクセルが決定する。
2. ラスタライザではピクセルシェーダーに渡すためのデータも計算される。
3. ピクセルシェーダーは塗りつぶすピクセルの数分だけ実行される。
4. ピクセルシェーダーには頂点シェーダーから出力されたデータを元に計算したデータが渡される。
5. ピクセルシェーダーから出力されるデータは光の３原色＋α。

<!-- 改ページ. -->
<div style="page-break-before:always"></div>

# Chapter 3 シェーダー入門 その２
<lead>
&emsp;このチャプターではChapter２から引き続き、シェーダーの基礎的な部分を勉強していきます。Chapter２では触れなかった座標変換、CPUからGPUへのデータ転送、テクスチャマッピング、テクスチャサンプリングなどを学んでいきます。
</lead>

## 3.1 座標変換
&emsp;Chapter1で頂点シェーダーの仕事は、「3Dモデルの頂点をスクリーン空間に座標変換することである」ということを学びました。そして、Chapter2で簡単な頂点シェーダーを書いてみました。しかしChapter2の頂点シェーダでは座標変換済みの頂点が設定されていたので、シェーダーで座標変換は行っていませんでした。しかし、3Dモデルのキャラクターを画面上で移動させるということは、そのモデルの頂点座標に対して座標変換を行うことになります。しかし、近年のゲームであれば、一つの3Dモデルで頂点数が10万を超えることも珍しくありません。これだけの数の頂点の座標変換をCPUで行うということは現実的ではなく、一般的に座標変換はGPUで行われます。
### 3.1.1 行列とベクトルの乗算
&emsp;頂点の座標変換は行列とベクトルの乗算で計算されます。ベクトルに行列を乗算すると、別の空間にベクトルを変換することができます。ゲームでは大雑把に分類すると、スクリーンに絵を表示するために表3.1の行列が必要になります。</br>

**表3.1**
| 名前 | 説明 |
| ---- | ---- |
| ワールド行列 | ワールド空間に変換するための行列 |
| カメラ行列 | カメラ空間に変換するための行列 |
| 透視投影行列 | スクリーン空間に変換するための行列 | 

この３つの行列を頂点座標に乗算することで、３Ｄモデルをスクリーン空間に変換しているのです。変換の順番は、ワールド空間➡カメラ空間➡スクリーン空間です。これがそのまま乗算の順番になります。では、３つの座標変換を詳細に見ていきましょう。

### 3.1.2 ワールド行列
&emsp;ワールド行列は、3Dモデルをモデル空間からワールド空間に変換するための行列です。モデル空間というのは3DSMAx、Maya、Blenderなどの3DCGを作成するためのソフトウェアの空間です。この空間から、ゲームのワールドの空間に変換するための行列がワールド行列です。モデル空間では、多くの3Dモデルは足元が原点になります。もちろん、中にはモデルの中心が原点のものもありますし、遠く離れた場所が原点のモデルもあります。</br>

**図3.1 足元が原点**</br>
<img src="fig/足元が原点.png" width="400"></img></br>

**図3.2 原点が離れている**</br>
<img src="fig/足元がお留守.png" width="400"></img></br>

&emsp;モデル空間はアーディストがどのように3Dモデルを作成するのか次第の空間になります。モデル空間では、3Dモデルの足元は原点になっているので、ゲームの世界を歩き回ることができません。そこで、キャラクターの座標、回転クォータニオン、拡大率などから作成されるワールド行列をモデルの頂点に乗算することで、ワールド空間に変換する必要があります。図3.3は3Dモデルがモデル空間にいる状態です。

**図3.3 モデル空間**</br>
<img src="fig/モデル空間.png" width="400"></img></br>

&emsp;モデル空間にいる3Dモデルの全ての頂点座標にワールド行列を乗算することで、図3.4のように3Dモデルはワールド空間に移動することができるようになります。

**図3.4 ワールド空間に変換**</br>
<img src="fig/ワールド空間に変換.png" width="400"></img></br>

### 3.1.3 カメラ行列
&emsp;ワールド空間に変換することができたら、次はカメラ空間に変換します。カメラ空間はカメラを原点とする空間です。カメラ空間はカメラの場所を原点、カメラの横方向をＸ軸、上方向をＹ軸、前方向をＺ軸とする空間です。</br>

**図3.5 カメラ空間に変換**</br>
<img src="fig/カメラ空間に変換.png" width="400"></img></br>
&emsp;3Dモデルをカメラ空間に変換するためには、3Dモデルの全ての頂点に対して、カメラ行列を乗算する必要があります。カメラ行列が乗算されると、3Dモデルの頂点はカメラを原点とした空間に変換されます。図3.3ですと、ワールド空間では(10,20,30)だった座標はカメラ空間では(0,0,30)になることを表しています。

### 3.1.4 透視変換行列
&emsp;カメラ空間に変換することができたら、次はスクリーン空間に変換します。正確には正規化されたスクリーン空間ですが、今は気にしなくて構いません。スクリーン空間はスクリーンの中心を原点とする2次元空間です。ワールド空間とカメラ空間は3次元空間だったのですが、スクリーン空間は2次元空間になります。

### 3.1.5 行列を作るのはCPU？GPU？どっち？
&emsp;ここまでの話で、行列と頂点座標の乗算を行って空間変換を行い、画面に絵を出していることが分かりました。そして、行列と頂点座標の乗算を行っているのがGPUであることも分かりました。では、そもそも行列を作るのはCPUとGPUのどちらでしょうか？答えはCPUになります。ワールド行列を作成するためのキャラクターの座標、回転、拡大率や、カメラ行列を作成するための視点の位置、注視点の位置などの情報はCPUがアクセスできるメインメモリに載っています。また、行列と頂点の乗算の回数と比べると、行列を作成するための計算回数はそこまで多くありません。表3.2は10000頂点のモデルを表示するための計算回数を表しています。</br>

**表3.2**</br>
| 処理の名前 | 計算回数 | 計算するプロセッサ | 
| ---- | ---- | ---- |
| ワールド行列の作成 | 1キャラにつき数回 | CPU |
| カメラ行列の作成 | 1フレームにつき数回 | CPU |
| 透視投影行列の作成 | 1フレームにつき数回 | CPU |
| 頂点座標とワールド行列の乗算 | 1キャラにつき10000回以上 | GPU |
| 頂点座標とカメラ行列の乗算 | 1キャラにつき10000回以上 | GPU |
| 頂点座標とスクリーン行列の乗算 | 1キャラにつき10000回以上 | GPU |

表3.2が示すように、行列の作成の計算量は数回となっており、それほど多くありません。また、これらの行列の作成はゲームロジックと密接に関連づいているため、CPU(C++)で計算されることがほとんどです。

### 3.1.6 メモリ転送
&emsp;さて、絵を表示するために必要な行列はCPU側で計算されることが分かりました。そして、GPU側でこの行列を利用して、頂点座標の変換を行っていました。しかし、CPUで計算されたデータは基本的にメインメモリに記憶されています。ですが、GPUがアクセスできるメモリはグラフィックメモリのみとなります。ここで、Chapter1で勉強したメモリ転送が必要になってくるのです。
#### 定数バッファ
&emsp;DirectX12にはメインメモリからグラフィックメモリにデータを転送する仕組みとして定数バッファと呼ばれるものを用意しています。定数バッファはDirectX12のAPIを利用することで作成できます。メインメモリからグラフィックメモリへのデータのコピーもDirectX12のAPIを利用します。リスト3.1は定数バッファを利用する疑似コードです。</br>

[リスト3.1 定数バッファを利用する疑似コード]
```cpp
//GPUで使用する行列をまとめた構造体。
struct MatrixData{
	Matrix worldMatrix;		//ワールド行列
	Matrix cameraMatrix;	//カメラ行列
	Matrix projMatrix;		//透視変換行列
};
//メイン関数
int main()
{
	MatrixData matData;
	//グラフィックメモリ上に定数バッファを作成。
	ConstantBuffer cb;
	cb.Create( sizeof( matData ) ); 

	//ゲームループ。
	while(true){
		・
		・
		・
		//ワールド行列、カメラ行列、透視変換行列を計算する。
		matData.worldMatrix.MakeWorldMatrix( 
			charaPos, charaRot, charaScale );
		matData.viewMatrix.MakeViewMatrix( cameraPos, cameraTarget );
		matData.projMatrix.MakeProjMatrix( nearPlane, farPlane );

		//計算した行列データをグラフィックメモリにコピー
		cb.Copy( matData );
	}
}
```

#### ディスクリプタヒープ
&emsp;定数バッファは作成しただけではGPUで使用することはできません。頂点バッファやインデックスバッファと同じようにドローコールを行う前に使用する前に設定する必要があります。DirectX12では定数バッファやテクスチャ、ストラクチャバッファなどをまとめて設定するための「ディスクリプタヒープ」というものが用意されています。ディスクリプタヒープは料理を運ぶトレイのようなものです。</br>

**図3.6**</br>
<img src="fig/ディスクリプタヒープ.png" width="600"></img></br>

&emsp;図3.6のようにトレイにおかず(定数バッファ、テクスチャ、ストラクチャバッファー)を乗せるようなイメージです。
リスト3.2はディスクリプタヒープを利用して絵を描く疑似コードです。</br>
[リスト3.2 ディスクリプタヒープを利用する疑似コード]
```cpp
//メイン関数
int main()
{
	MatrixData matData;
	//グラフィックメモリ上に定数バッファを作成。
	ConstantBuffer cb;
	cb.Create( sizeof( matData ) );
	//ディスクリプタヒープを作成。 
	DescriptorHeap ds; 
	//ディスクリプタヒープに定数バッファを登録する。
	ds.RegistConstantBuffer( cb );
	//ゲームループ。
	while(true){
		・
		・
		・
		//ワールド行列、カメラ行列、透視変換行列を計算する。
		matData.worldMatrix.MakeWorldMatrix( 
			charaPos, charaRot, charaScale );
		matData.viewMatrix.MakeViewMatrix( cameraPos, cameraTarget );
		matData.projMatrix.MakeProjMatrix( nearPlane, farPlane );
		//計算した行列データをグラフィックメモリにコピー
		cb.Copy( matData );
		・
		・
		・
		//ディスクリプタヒープを設定してドロー。
		SetDescriptorHeap( ds );
		Draw();
	}
}

```

### 3.1.7 【ハンズオン】ワールド行列を作成して三角形を動かしてみよう
&emsp;では、Sample_03_01を改造して、三角形を動かかしてみましょう。`Sample_03_01/Sample_03_01.sln`をダブルクリックして、VisualStudioのプロジェクトを立ち上げてください。VisualStudioが立ち上がったら`main.cpp`を開いてください。
#### step-1 定数バッファを作成(C++)
&emsp;まずは、定数バッファを作成するプログラムを追加しましょう。リスト3.3のプログラムを入力してください。</br>

[リスト3.3 main.cpp 29行目～]
```cpp
//step-1 定数バッファを作成。
ConstantBuffer cb;
cb.Init( sizeof( Matrix ) ); //Init関数の引数は定数バッファのサイズ。
```
#### step-2 ディスクリプタヒープを作成(C++)
&emsp;続いて、ディスクリプタヒープを作成するプログラムを追加します。リスト3.4のプログラムを入力してください。</br>
[リスト3.4 main.cpp 32行目～]
```cpp
//step-2 ディスクリプタヒープを作成。
DescriptorHeap ds;
ds.RegistConstantBuffer( 0, cb ); //ディスクリプタヒープに定数バッファを登録。
ds.Commit();					  //ディスクリプタヒープへの登録を確定。
```
`DescriptorHeap`クラスはDirectX12のディスクリプタを簡単に扱えるように、著者の方で用意したクラスです。`DescriptorHeap::RegistConstantbuffer()`の第一引数はレジスタ番号です。入力アセンブラが定数バッファをレジスタに設定するときにこの情報を利用します。登録は`DescriptorHeap::Commit()`を呼び出すことで確定します。必ず呼び出すことを忘れないようにしてください。

#### step-3 ワールド行列を作成(C++)
&emsp;リスト3.5のプログラムを入力してください。ここでは、x方向に0.5、y方向に0.4移動するワールド行列を作成しています。</br>
[リスト3.5 main.cpp 54行目～]
```cpp
//step-3 ワールド行列を作成。
Matrix mWorld;
mWorld.MakeTranslation(0.5f, 0.4f, 0.0f);
```
#### step-4 ワールド行列をグラフィックメモリにコピー(C++)
&emsp;ワールド行列が計算できたら、メインメモリからグラフィックメモリにコピーをしましょう。リスト3.5のプログラムを入力してください。</br>
[リスト3.5 main.cpp 57行目～]
```cpp
//step-4 ワールド行列をグラフィックメモリにコピー。
cb.CopyToVRAM(mWorld);
```

#### step-5 ディスクリプタヒープを設定(C++)
&emsp;いよいよC++側の最後のプログラムです。ディスクリプタヒープを設定するプログラムを追加します。リスト3.6のプログラムを入力してください。</br>
[リスト3.6 main.cpp 60行目～]
```cpp
//step-5 ディスクリプタヒープを設定。
renderContext.SetDescriptorHeap(ds);
```
#### step-6 レジスタb0のデータにアクセスするための変数を定義する(HLSL)
&emsp;次はHLSL側のプログラムになります。Assets/shader/sample.fxを開いてください。まずはレジスタb0に設定されている定数バッファにアクセスするための変数を定義します。リスト3.7のプログラムを入力してください。</br>

```hlsl
//step-6 レジスタb0のデータにアクセスするための変数を定義する。
float4x4 g_worldMatrix : register( b0 );
```
#### step-7 ワールド行列と座標を乗算して座標変換を行う(HLSL)
&emsp;いよいよこれで最後です。定数バッファに設定されたワールド行列を利用して、座標変換を行います。リスト3.8のプログラムを入力してください。</br>
```hlsl
//step-7 ワールド行列と座標を乗算して座標変換を行う。
//元のコードはコメントアウト vsOut.pos = In.pos;
vsOut.pos = mul( g_worldMatrix, In.pos );
```
ここまで完了したらF5キーを押してプログラムを実行してみてください。図3.7のように三角形が少し右上に表示されていれば成功です。</br>
**図3.7**</br>
<img src="fig/3_7.png" width="600"></img></br>

<!-- 改ページ. -->
<div style="page-break-before:always"></div>

## 実習課題-1
`Kadai_03_01/Kdai_03_01.sln`を立ち上げて、次の課題を行いなさい。
「回転行列をGPUに送って三角形をZ軸周りに0.5(ラジアン単位)回す。」

## 実習課題-2
`Kadai_03_02/Kdai_03_02.sln`を立ち上げて、次の課題を行いなさい。
「X軸方向に3倍、Y軸方向に1.5倍、Z軸方向に1倍の拡大行列をGPUに送って三角形を拡大する。」

## 実習課題-3
`Kadai_03_03/Kdai_03_03.sln`を立ち上げて、次の課題を行いなさい。
「三角形のカラーをGPUに送って、三角形を緑色にしなさい。」

## 実習課題-4（ハンズオン）
`Kadai_03_04/Kdai_03_04.sln`を立ち上げて、次の課題を行いなさい。
### コントローラーの入力で三角形を左右に動かす。
step-1～step-8のプログラムを入力して下さい。
#### step-1 平行移動行列を送るための定数バッファを作成。
[`main.cpp`]
```cpp
//step-1 平行移動行列を送るための定数バッファを作成。
ConstantBuffer cb;
//行列は64バイトなので定数バッファのサイズに16を指定する。
cb.Init(64);
```

#### step-2 定数バッファをディスクリプタヒープに登録。
[`main.cpp`]
```cpp
//step-2 定数バッファをディスクリプタヒープに登録。
ds.RegistConstantBuffer(0, cb);
```

#### step-3 三角形の座標を表す変数を定義する。
[`main.cpp`]
```cpp
//step-3 三角形の座標を表す変数を定義する。
Vector3 trianglePos;
trianglePos.x = 0.0f;
trianglePos.y = 0.0f;
trianglePos.z = 0.0f;
```

#### step-4 コントローラーの入力で三角形を動かす。
[`main.cpp`]
```cpp
//step-4 コントローラーの入力で三角形を動かす。
if (g_pad[0]->IsPress(enButtonRight))
{
    trianglePos.x += 0.01f;
}
if (g_pad[0]->IsPress(enButtonLeft))
{
    trianglePos.x -= 0.01f;
}
```

#### step-5 三角形の座標を使って平行移動行列を作成する。
[`main.cpp`]
```cpp
//step-5 三角形の座標を使って平行移動行列を作成する。
Matrix mTrans;
mTrans.MakeTranslation(trianglePos);
```

#### step-6 定数バッファに平行移動行列をコピーする。
[`main.cpp`]
```cpp
//step-6 定数バッファに平行移動行列をコピーする。
cb.CopyToVRAM(mTrans);
```

#### step-7 レジスタb0のデータにアクセスするための変数を定義する。
[`Assets/shader/sample.fx`]
```cpp
//step-7 レジスタb0のデータにアクセスするための変数を定義する。
cbuffer cb : register( b0 ){
	float4x4 g_transMatrix;
};

```
#### step-8 平行移動行列と座標を乗算して座標変換を行う。
[`Assets/shader/sample.fx`]
```cpp
//step-8 平行移動行列と座標を乗算して座標変換を行う。
vsOut.pos = mul( g_transMatrix, In.pos );
```

## 実習課題-5
`Kadai_03_05/Kdai_03_05.sln`を立ち上げて、次の課題を行いなさい.
「三角形をコントローラーの左右の入力でZ軸周りに回転させなさい。」

## 実習課題-6
`Kadai_03_06/Kdai_03_06.sln`を立ち上げて、次の課題を行いなさい.
「三角形をコントローラーの左右の入力でX軸方向に拡大させなさい。」

## 実習課題-7
`Kadai_03_07/Kdai_03_07`を立ち上げて、次の仕様を実装しなさい。
1. 三角形をコントローラーの左右の入力で左右に移動する。
2. かつ、コントローラーのAボタンの入力でY軸周りに回転する。
3. かつ、コントローラーのBボタンの入力でY軸方向に拡大する。

<!-- 改ページ. -->
<div style="page-break-before:always"></div>

## 3.2 テクスチャマッピング
ここでは３Dモデルのポリゴンに画像を貼り付ける、テクスチャマッピングについて見ていきます。
### 3.2.1 テクスチャとは
3DCGの世界でテクスチャというと多くの場合で、３Ｄモデルの模様を表す画像データのことをさします。図3.8はUnity社がフリーで提供している３Ｄモデルのユニティちゃんとそのテクスチャです。</br>
**図3.8**</br>
<img src="fig/3.8.png" width="600"></img></br>
3Dモデルというのは３角形ポリゴンの集合体です。つまり3Dモデルの模様は、三角形のポリゴンにテクスチャの模様を貼り付けて表現しているのです。では、ポリゴンにテクスチャを貼り付ける方法を見ていきましょう。


### 3.2.2 UV座標
ポリゴンにテクスチャを貼り付けるときはUV座標というものを使用します。UV座標とはテクスチャ座標とも呼ばれ、図3.9のようにテクスチャの左上を(0,0)、右下を(1,1)とする座標系で、横方向をU座標、縦方向をV座標として表します。</br>
<!-- 改ページ. -->
<div style="page-break-before:always"></div>

**図3.9**</br>
<img src="fig/3.9.png" width="600"></img></br>
例えばUV座標が(0.2、0.5)の図3.10のテクセル(画素)を指します。</br>

**図3.10**</br>
<img src="fig/3.10.png" width="600"></img></br>

### 3.2.3 頂点UV座標
ではポリゴンにテクスチャを貼り付ける具体例を見ていきましょう。図3.11のようにポリゴンにテクスチャを貼り付けたい場合を考えてみましょう。</br>
**図3.11**</br>
<img src="fig/3.11.png"></img></br>
図3.11のポリゴンには図3.12のテクスチャが貼り付けされています。</br>

**図3.12**</br>
<img src="fig/3.12.jpg"></img></br>

このようにテクスチャを貼り付けるのは、図3.13のように頂点にUV座標を埋め込むことで実現できます。</br>
**図3.13**</br>
<img src="fig/3.13.png" width="400"></img></br>
頂点データには座標だけではなく、様々なデータを埋め込むことができます。テクスチャマッピングは、頂点にUV座標のデータを埋め込むことで実現できます。

### 3.2.4 テクスチャはグラフィックメモリ？メインメモリ？どっちに載る？
さて、テクスチャをポリゴンに貼り付けるためにはUV座標というデータを準備する必要があることが分かりました。しかし、そもそもテクスチャを貼り付けるためには、テクスチャの画像データをメモリ上に載せる必要があります。では、テクスチャのデータはグラフィックメモリとメインメモリのどちらに載せればいいのでしょうか？答えはグラフィックメモリとなります。ポリゴンにテクスチャを貼り付けるプログラムはピクセルシェーダーに記述することになります。ですので、GPUからアクセスできるグラフィックメモリに載せる必要があるのです。ここで、定数バッファの話を思い出してください。グラフィックメモリに載せられたデータにアクセスするためにはレジスタに関連付ける必要がありました。これはテクスチャも同じです。ただ、定数バッファではbレジスタを利用していましたが、テクスチャが使用するレジスタはtレジスタになります。

### 3.2.5 【ハンズオン】三角形にテクスチャを貼る。
&emsp;では、ハンズオンを通して、三角形にテクスチャを貼り付ける方法について見ていきましょう。`Sample_03_02/Sample_03_02.sln`を立ち上げて、step1～step5のプログラムを入力してください。</br>

#### step-1 三角形ポリゴンにUV座標を設定。
まずは三角形ポリゴンの各頂点にUV座標を設定していきましょう。main.cppにリスト3.9のプログラムを入力してください。</br>
[リスト3.9 `main.cpp` 33行目～]
```cpp
//step-1 三角形ポリゴンにUV座標を設定。
triangle.SetUVCoord(
	0,			//頂点の番号
	0.0f,		//U座標
	1.0f		//V座標
);

triangle.SetUVCoord(
	1,			//頂点の番号
	0.5f,		//U座標
	0.0f		//V座標
);

triangle.SetUVCoord(
	2,			//頂点の番号
	1.0f,		//U座標
	1.0f		//V座標
);
```

#### step-2 テクスチャをロード（C++）
続いて、ポリゴンに貼り付けるテクスチャをグラフィックメモリ上にロードしましょう。今回は著者の方で用意したTextureクラスを利用します。リスト3.10のプログラムを入力してください。</br>
[リスト3.10 `main.cpp`]
```cpp
//step-2 テクスチャをロード。
Texture tex;
tex.InitFromDDSFile(L"Assets/image/sample_00.dds");
```

#### step-3 テクスチャをディスクリプタヒープに登録（C++）
テクスチャがロードできたら、定数バッファと同じようにディスクリプタヒープに登録する必要があります。リスト3.11のプログラムを入力してください。</br>
[リスト3.11 `main.cpp`]
```cpp
//step-3 テクスチャをディスクリプタヒープに登録。
ds.RegistShaderResource(
	0,		//レジスタ番号
	tex	//レジスタに設定するテクスチャ
);
```

#### step-4 t0レジスタに設定されているテクスチャにアクセスするための変数を追加する（HLSL）
続いて、HLSL側を実装していきます。定数バッファと同じように、cpp側で設定されたテクスチャにアクセスするための変数を定義しましょう。ただし、テクスチャが設定されているレジスタはtレジスタですので注意してください。では、リスト3.12のプログラムを入力してください。</br>
[リスト3.12 `sample.fx`]
```cpp
//step-4 t0レジスタに設定されているテクスチャにアクセスするための変数を追加する。
Texture2D g_texture : register( t0 );
```

#### step-4 テクスチャカラーをサンプリングして返す。
これで最後です。テクスチャからカラーをサンプリングしてピクセルカラーを決定しましょう。ピクセルカラーを決定するというキーワードから分かるかもしれませんが、このプログラムはピクセルシェーダーに記述します。リスト3.13のプログラムを入力してください。</br>
[リスト3.13 `sample.fx`]
```cpp
//step-5 テクスチャカラーをサンプリングして返す。
float4 texColor = g_texture.Sample( 
	g_sampler, 	//第一引数はサンプラ。今は気にしなくてよい。
	vsOut.uv	//第二引数はUV座標。
) ;
//テクスチャからサンプリングしたカラーをピクセルカラーとして返す。
return texColor;	
//元々のコードはいらないので、コメントアウト 
//return float4( vsOut.color, 1.0f );

```
ここまで実装出来たら実行してください。正しく実装できていたら図3.14のようなプログラムが実行できます。</br>
**図3.14**
<img src="fig/3.14.png"></img></br>


<!-- 改ページ. -->
<div style="page-break-before:always"></div>

## 実習課題-8
Kadai_03_08を改造して、次の図のように三角形にテクスチャを貼り付けなさい。

<img src="fig/kadai/03_08.png" ></br>

プログラム中の次のコメントを参考にして実装しなさい。

1. step-1 三角形ポリゴンにUV座標を設定。(main.cpp)
2. step-2 Assets/image/sample_00.ddsをロードしてテクスチャを作成。(main.cpp)
3. step-3 テクスチャをディスクリプタヒープに登録。(main.cpp)
4. step-4 t0レジスタに設定されているテクスチャにアクセスするための変数を追加する。(sample.fx)
5. step-5 テクスチャカラーをサンプリングして返す。(sample.fx)


## 実習課題-9
Kadai_03_09を改造して、次の図のように三角形にテクスチャを貼り付けなさい。

<img src="fig/kadai/03_09.png" ></br>

プログラム中の次のコメントを参考にして実装しなさい。内容はほとんど実習課題-8と同じですがテクスチャの貼られ方が違います。実習課題-8との違いは三角形の頂点UV座標です。

1. step-1 三角形ポリゴンにUV座標を設定。(UV座標の値が演習課題_1と違う)
2. step-2 Assets/image/sample_00.ddsをロードしてテクスチャを作成。(演習課題_1と同じ)
3. step-3 テクスチャをディスクリプタヒープに登録。(演習課題_1と同じ)
4. step-4 t0レジスタに設定されているテクスチャにアクセスするための変数を追加する。(演習課題_1と同じ)
5. step-5 テクスチャカラーをサンプリングして返す。(演習課題_1と同じ)

## 実習課題-10

Kadai_03_10を改造して、次の動画のような処理を実装しなさい。

`Kadai_03_10/movie.wmv`

<!-- 改ページ. -->
<div style="page-break-before:always"></div>
[3Dモデル表示]</br>


# Optional_1 3Dモデル表示
## 概要
&emsp;Chapter2,3で単純な三角形ポリゴン表示について見てきました。単純な三角形ポリゴンを表示するためには、次の３つの情報が必要でした。</br>

1. 頂点バッファ
2. インデックスバッファ
3. テクスチャ(マテリアル情報)

&emsp;実は複雑な3Dモデルの表示というのも、この三角形ポリゴン表示の知識で行うことができます。ようは複雑な3Dモデルというのは、三角形ポリゴンがたくさんあるだけです。本書では、これ以降独自のモデルフォーマットのtkmファイルというものを利用してモデル表示が行えるModelクラスを利用して話を進めていきます。</br>
&emsp;tkmファイルというのは、3dsMaxやBlenderなどで、アーティストが作成したモデルデータから、頂点バッファ、インデックスバッファ、マテリアル情報を抽出したファイルです。次ページにtkmファイルのファイルフォーマットが記載されています。</br>

&emsp;これをプログラムで記述すると下記のような感じになります。</br>
```cpp
//マテリアルの数が３個の場合。
struct SMesh {
	SVertexBuffer	vertexBuffer;		//頂点バッファ。
	SMaterial 		materials[3];		//マテリアルの配列。
	SIndexBuffer 	indexBuffer[3];		//インデックスバッファの配列。マテリアルの数分だけインデックスバッファはあるよ。
};
```
&emsp;頂点バッファ、インデックスバッファ、マテリアル情報が入っているデータです。3Dモデルデータはパーツによってメッシュが分割されていることがあります（人型モデルであれば、髪の毛と体といった感じで分かれている場合があります）。なので、各メッシュごとに頂点バッファ、インデックスバッファ、マテリアル情報のデータを保持しています。</br>

&emsp;本書のサンプルプログラムでtkmファイルをロードする処理はMiniEngine/tkFile/TkmFile.h、TkmFile.cppに記載されています。tkmファイルをロードすることができたら、このデータを元にDirectX12のAPIを利用して、頂点バッファ、インデックスバッファ、テクスチャをグラフィックメモリ上に作成していきます。この処理を行っているのがMeshPartsクラスとなります。この処理はChapter2,3で勉強してきた内容となります。簡単にだけこれらを行っているソースの箇所を紹介します。</br>

[MiniEngine/MeshParts.cpp(83行目)]
```cpp
void MeshParts::CreateMeshFromTkmMesh(
	const TkmFile::SMesh& tkmMesh, 
	int meshNo,
	const wchar_t* fxFilePath,
	const char* vsEntryPointFunc,
	const char* psEntryPointFunc)
{
	 ・
	 ・
	 ・
	省略
	 ・
	 ・
 	 ・	
}
```
&emsp;コードの詳細は気にしなくて構いませんので、この関数内の次の３つのコメントに注目してください。

1. 頂点バッファを作成(90行目)
2. インデックスバッファを作成(108行目)
3. マテリアルを作成(137行目)

&emsp;このように、難しいことをやっているように見えますが、本質的には三角形を描画するときと同等のことを行っています。</br>
&emsp;各種データを作成することができたら、後は毎フレーム、ドローコールを実行するだけです。これもChapter2,3で見てきた内容となります。これも簡単にだけソースの箇所を紹介しておきます。</br>
[MiniEngine/MeshParts.cpp(159行目)]
```cpp
void MeshParts::Draw(
	RenderContext& rc,
	const Matrix& mWorld,
	const Matrix& mView,
	const Matrix& mProj
)
{
	 ・
	 ・
	 ・
	省略
	 ・
	 ・
	 ・
}
```
&emsp;こちらもコードの詳細は気にしなくて構いません。次の４つのコメントに注目してください。

1. 頂点バッファを設定。(187行目)
2. ディスクリプタヒープを登録。(193行目)
3. インデックスバッファを設定。(195行目)
4. ドローコールを実行。(199行目)

&emsp;このように、毎フレームの描画処理も本質的にはポリゴンを表示する処理と全く同じことをしているだけとなります。</br>
&emsp;本書ではモデル表示処理の詳細は説明はしませんが、処理を追いかけてみると基礎的な知識の理解が深まると思います。最後に、本書のモデル表示関連のクラス図を記載しておきます。</br>

## 【ハンズオン】3Dモデルを表示する処理を記述する。
Optional_01_01/Optional_01_01.slnを立ち上げて、step-1～step-7のプログラムを入力してください。
### step-1 3Dモデルをロードする。
[main.cpp]</br>
```cpp
//ロードするための初期化情報を作成。
ModelInitData initData;
//tkmファイルのファイルパス。
initData.m_tkmFilePath = "Assets/modelData/unityChan.tkm";
//使用するシェーダーのファイルパス。
initData.m_fxFilePath = "Assets/shader/NoAnimModel_Texture.fx";
//作成した初期化情報を使って、初期化する。
Model charaModel;
charaModel.Init(initData);
```
#### step-2 3Dモデルをドローする。
[main.cpp]</br>
```cpp
//step-2 3Dモデルをドローする。
charaModel.Draw(renderContext);
```

### step-4 コントローラーの入力でキャラを動かす。
[main.cpp]</br>
```cpp
pos.x += g_pad[0]->GetLStickXF();
```

### step-5 コントローラーの入力でキャラをY軸周りに回転させる。
[main.cpp]</br>
```cpp
//step-5 コントローラーの入力でキャラをY軸周りに回転させる。
Quaternion addRot;
addRot.SetRotationY(g_pad[0]->GetRStickXF() * 0.01f );
//クォータニオンは掛け算で回転を合成できる。
rot *= addRot ;
```

### step-6 コントローラーの入力でキャラをX軸方向に拡大させる。
[main.cpp]</br>
```cpp
//step-6 コントローラーの入力でキャラをX軸方向に拡大させる。
if (g_pad[0]->IsPress(enButtonLeft)) {
	scale.x += 0.01f;
}
if (g_pad[0]->IsPress(enButtonRight)) {
	scale.x -= 0.01f;
}
```

### step-7 平行移動、回転、拡大率を利用してワールド行列を計算する。
[main.cpp]</br>
```cpp
//step-7 平行移動、回転、拡大率を利用してワールド行列を計算する。
charaModel.UpdateWorldMatrix(pos, rot, scale);
```


